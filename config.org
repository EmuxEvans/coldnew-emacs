#+TITLE: coldnew's emacs
#+AUTHOR: Yen-Chin, Lee <coldnew>
#+email: coldnew.tw at gmail.com
#+STARTUP: overview indent align
#+BABEL: :cache yes
#+OPTIONS: ^:nil

* 基礎設置                                                             :base:

初始化的 emacs 設定，包含了加入 PATH 以及一些 OS 相關設定。

** TODO 打開 lexical-binding 功能

打開這個似乎會出現以下錯誤 ?

: void function closure

#+BEGIN_SRC emacs-lisp :padline no :tangle no
  ;; -*- lexical-binding: t -*-
#+END_SRC

** 預先載入 cl 套件

#+begin_src emacs-lisp
  (eval-when-compile (require 'cl))
#+end_src

** 資料夾相關變數設定                                             :variable:

這邊設定了各種類型資料夾的路徑，後面使用到的資教牙相關變數都直接定義在
這。

- emacs 設定檔預設所在的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-dir "~/.emacs.d/"
      "The top-level emacs-configure directory.")
  #+end_src

- 佈景主題的資料夾設定

  #+begin_src emacs-lisp
    (defconst emacs-themes-dir (concat emacs-dir "themes/")
      "directory to place emacs theme.")
  #+end_src

- el-get 安裝套件的路徑

  #+begin_src emacs-lisp
    (defconst emacs-lisp-dir   (concat emacs-dir "lisp/")
      "directory to place lisp packages from internet.")
  #+end_src

- el-get 的 recipes 路徑

  #+begin_src emacs-lisp
    (defconst emacs-recipes-dir (concat emacs-dir "recipes/")
      "directory to place local el-get recepies.")
  #+end_src

- elpa 安裝套件的路徑

  #+begin_src emacs-lisp
    (defconst emacs-elpa-dir   (concat emacs-lisp-dir "elpa/")
      "directory to place ELPA lisp packages from internet.")
  #+end_src

- yasnippet 使用的 snippet 路徑

  #+begin_src emacs-lisp
    (defconst emacs-snippets-dir (concat emacs-dir "snippets/")
      "directory to place yasnippet files.")
  #+end_src

- 放置 binary 檔案的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-bin-dir    (concat emacs-dir "bin/")
      "directory to place binary staff.")
  #+end_src

- 放置 cache 等暫存檔案的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-cache-dir  (concat emacs-dir "cache/")
      "cache file directory.")
  #+end_src

- 備份文件的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-backup-dir (concat emacs-dir "backup/")
      "directory to backup files.")
  #+end_src

- 放置紀錄的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-log-dir (concat emacs-dir "log/")
      "log file directory.")
  #+end_src

- 放置 jar 等其他文件的位置

  #+begin_src emacs-lisp
    (defconst emacs-etc-dir (concat emacs-dir "etc/")
      "etc file directory.")
  #+end_src

- Dropbox 資料夾

  #+begin_src emacs-lisp
    (defconst dropbox-dir "~/Dropbox"
      "Dropbox directory.")
  #+end_src

- Sparkleshare 資料夾

  #+begin_src emacs-lisp
    (defconst sparkleshare-dir "~/SparkleShare"
      "Sparkleshare directory.")
  #+end_src

- Copy 資料夾

  #+begin_src emacs-lisp
    (defconst copy-dir "~/Copy"
      "Copy directory.")
  #+end_src

** 複製系統的 PATH 變數

在一開始 emacs 啟動時，複製系統的 Shell PATH 給 emacs 知道，這樣有些額外安
裝的程式，比如 OSX 下的 homebrew 路徑，emacs 也可以知道他在那邊，當有需要呼
叫外部程式的時候會比較方便。

#+BEGIN_SRC emacs-lisp
  (defun set-exec-path-from-shell-PATH ()
    "Set up Emacs' `exec-path' and PATH environment variable to match that used by the user's shell.

  This is particularly useful under Mac OSX, where GUI apps are not started from a shell."
    (interactive)
    (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator))))

  (set-exec-path-from-shell-PATH)
#+END_SRC
** 關閉一些 emacs 預設的設定

emacs 有一些預設的設定我不太喜歡，這邊先將他們關掉。

*** 不啟用 startup message

啟動 emacs 時會出現的 GNU/Emacs 畫面，這裡將他關閉

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

*** 清空 *scratch* buffer 的文字

預設 =*scratch*= 這個緩衝區裡面會有幾行文字，直接將他清空。
#+begin_src emacs-lisp
  (setq initial-scratch-message "")
#+end_src

*** 關閉蜂鳴器

使用畫面閃爍代替電腦的蜂鳴器叫聲。
#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

*** 關閉工具列

不顯示工具列。
#+begin_src emacs-lisp
  (if (featurep 'tool-bar) (tool-bar-mode -1))
#+end_src

*** 關閉滾動條

關閉左側或右側的滾動條 (scrool-bar)。
#+begin_src emacs-lisp
  (if (featurep 'scroll-bar) (scroll-bar-mode -1))
#+end_src

*** 關閉游標閃爍與方塊狀的提示

不允許游標閃爍以及 Mac OSX 下的方塊狀提示。

#+begin_src emacs-lisp
  (blink-cursor-mode -1)
  (setq ring-bell-function #'ignore)
#+end_src

*** 關閉選單列

不顯示選單列

#+begin_src emacs-lisp
  (if (featurep 'menu-bar) (menu-bar-mode -1))
#+end_src

*** 回答問題時，使用 y 和 n 代替 yes/no

預設要使用 *yse* 或是 *no* 來回答問題，這裡將他改成用 *y* 或 *n* 。

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** 啟動 emacs-server

當啟用 emacs 時，啟動 emacs-server，如果使用者是 root 或已啟用 server，
則忽略這個步驟。

#+begin_src emacs-lisp
  ;; Only start server mode if I'm not root
  (unless (string-equal "root" (getenv "USER"))
    (require 'server)
    (unless (server-running-p) (server-start)))
#+end_src

** 在 X11 下將 Caps Lock 變成 Contrl

emacs 用很習慣的人都會知道，小拇指按左下角鍵盤的 Ctrl 按鍵久了會很酸，所
以將 Ctrl 綁到 Caps Lock 是比較好的選擇，這邊在 Linux 下透過系統的
=setxkbmap= 來將 Caps Lock 變成 Ctrl 按鍵。

#+BEGIN_SRC emacs-lisp
  ;; only disable capslock and make it as control
  (cond ((eq window-system 'x)
         ;; make caps lock a control key
         (shell-command "setxkbmap -option ctrl:nocaps")))
#+END_SRC

** 在 Mac OS X 下用 Command 按鍵替代 ALT

在 Mac OS X 下，我只有將 Control 綁定到 Caps lock 按鍵上面，至於原本
Mac 最常用的 Command 按鍵，在 emacs 下則將他當作是 Alt 按鍵使用，
至於 option 按鍵，則變成 super 按鍵使用。

#+BEGIN_SRC emacs-lisp
   (setq mac-option-modifier 'super)
   (setq mac-command-modifier 'meta)
#+END_SRC
** 關閉 emacs 時不詢問是否要刪除執行中的 process

#+BEGIN_SRC emacs-lisp
  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    "Prevent annoying \"Active processes exist\" query when you quit Emacs."
    (flet ((process-list ())) ad-do-it))
#+END_SRC

** 關閉 process 不進行詢問

#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

* 語言與編碼                                                         :locale:

emacs 編碼設定，大部份都設定成 utf-8。

- 系統編碼。

  #+begin_src emacs-lisp
    (prefer-coding-system 'utf-8 )
  #+end_src

- 語言環境。

 #+begin_src emacs-lisp
   (set-language-environment 'utf-8 )
 #+end_src

- 文件保存時的編碼設置

  #+begin_src emacs-lisp
    (set-buffer-file-coding-system 'utf-8 )
  #+end_src

- 鍵盤編碼設定

  #+begin_src emacs-lisp
    (set-keyboard-coding-system    'utf-8 )
  #+end_src

- 設定終端機的編碼

  #+begin_src emacs-lisp
    (set-terminal-coding-system    'utf-8 )
  #+end_src

- 選擇區域內編碼

  #+begin_src emacs-lisp
    (set-selection-coding-system   'utf-8 )
  #+end_src

- 剪貼簿編碼設定

  #+begin_src emacs-lisp
    (set-clipboard-coding-system   'utf-8 )
  #+end_src

- 使用 utf-8 編碼顯示文件名

  #+begin_src emacs-lisp
    (set-file-name-coding-system   'utf-8 )
  #+end_src

- 設定時間顯示使用英文

  時間顯示中文還是怪怪的，所以這邊設定成英文

  #+begin_src emacs-lisp
    (setq system-time-locale "en_US" )
  #+end_src

- 讀寫緩衝區或是檔案時使用的編碼

  #+BEGIN_SRC emacs-lisp
    (setq coding-system-for-read 'utf-8)
    (setq coding-system-for-write 'utf-8)
  #+END_SRC

* 常用的模組 / 函式庫                                               :plugin:

emacs 有一些套件本身不需要配置，或是只是函式庫，這一類的套件我設
定為預先載入，這樣在後面的設定裏面我就可以直接使用這些套件的功能。

設定比較簡單的獨立程式也放在這邊，和程式語言相關的則會整合進程式開發的
區塊。

** ascii :: 顯示 ASCII 表

ascii 是一個很不錯的 ascii 表顯示工具，你可以使用 ascii-on 來啟用
, 他會告訴你目前游標所在位置的 ASCII 碼，使用 ascii-off 可以關閉
ascii-mode。

#+begin_src emacs-lisp
  (require 'ascii)
#+end_src

增加額外的 function，這樣我可以使用 ascii 或是 ascii-toggle 來切換顯示 ascii 表。

#+begin_src emacs-lisp
  (eval-after-load 'ascii
    '(progn
       ;; ascii-toggle
       (defun ascii-toggle ()
         "Toggle ascii-mode."
         (interactive) (if (not (ascii-off)) (ascii-on)))

       ;; alias ascii to ascii-toggle
       (defalias 'ascii 'ascii-toggle)))
#+end_src

** htmlize :: 將緩衝區輸出成 html 檔案

htmlize 是 emacs 一個非常好用的模組，可以讓 emacs 輸出檔案成為
HTML 檔，org-mode 輸出成 html 時也是使用他。

#+begin_src emacs-lisp
  (require 'htmlize)
#+end_src

** iedit :: 快速修改緩衝區內相同的文字

我們有時候會希望可以快尋尋找某個字，並用新的文字來取代他，iedit-mode
就是做這種事情的好幫手，先將游標停在要尋找取代的文字上，並輸入
=M-x iedit-mode= 接著就會發現到同個緩衝區裏面所有和游標底下的文字相同的
文字都被標記起來，試著更改看看，你會發現到這些文字同時被更改了。

Github: https://github.com/victorhge/iedit

#+begin_src emacs-lisp
  (require 'iedit)
#+end_src

** scquential-command :: 整合多項命令到按鍵上

#+begin_src emacs-lisp
  (require 'sequential-command)
#+end_src

sequential-command 這個套件提供了整合多個命令到一個命令的能力，透過這
個套件，你可以使用下面的方式，定義一個名為 my-end 的命令，這個命令整合
了 end-of-line 以及 end-of-buffer 兩個命令。

#+begin_src emacs-lisp :tangle no
  (define-sequential-command my-end  end-of-line end-of-buffer)
#+end_src

定義完 my-end 後，我們將他綁到 C-e 上

#+begin_src emacs-lisp :tangle no
  (global-set-key "\C-e" 'my-end)
#+end_src

當你敲下第一次 C-e 的時候，你實際上執行的是 *end-of-line* 這個命令，如
果你想要執行 end-of-buffer 這個命令的話，使用 C-e C-e 就可以辦到。

想要看更多的例子，可以見以下連結:

http://www.emacswiki.org/cgi-bin/wiki/download/sequential-command-config.el

** dash :: 增強 list 處理用的 function

dash 提供了更多關於 list 處理用的函式，目前已經為許多 emacs plugin 所依
賴的模組。

#+begin_src emacs-lisp
  (require 'dash)
#+end_src

** s :: 增加字串處理用 function

s 提供了許多關於字串處理的函式

#+begin_src emacs-lisp
  (require 's)
#+end_src
** expand-region :: 快速進行區域選擇

GitHub: https://github.com/magnars/expand-region.el

#+BEGIN_SRC emacs-lisp
  (require 'expand-region)
#+END_SRC
** flycheck :: 程式碼檢查工具

GitHub: https://github.com/flycheck/flycheck

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)
  (global-flycheck-mode)

  (eval-after-load 'flycheck
    '(add-hook 'flycheck-mode-hook #'flycheck-cask-setup))
#+END_SRC

** yasnippet :: 樣板插入工具

#+BEGIN_SRC emacs-lisp
  (require 'yasnippet)
  (yas-global-mode 1)
  (add-to-list 'auto-mode-alist '("emacs.+/snippets/" . snippet-mode))
#+END_SRC

*** 設定 snippet 所在的資料夾

  我不想要使用 yasnippet 預設的 snippet, 這邊將他改成我自己定義的
  snippet 位置。

  #+begin_src emacs-lisp
    (setq yas/snippet-dirs emacs-snippets-dir)
  #+end_src

*** 選擇 snippet 時，使用 dropdown-list 而不是圖形介面

預設的 yansippet 是使用圖形介面的方式讓你選擇 snippet，我比較喜歡
dropdown-list 的形式。

#+BEGIN_SRC emacs-lisp
  (setq yas/prompt-functions '(yas-dropdown-prompt
                               yas-completing-prompt
                               yas-ido-prompt))
#+END_SRC

*** 使用 yasnippet 達到 org-mode 的 easy-template 功能

org-mode 的 easy-template 提供使用者輸入 <e 再按下 TAB 就可以進行自動補全的功能,
為了在任意模式下都可以辦到如同 org-mode 的 easy template 的功能，我
設計了以下的程式碼。

#+begin_src emacs-lisp
  (defadvice yas-expand (around coldnew/major-mode-expand activate)
    "Try to complete a structure template before point like org-mode does.
    This looks for strings like \"<e\" on an otherwise empty line and
    expands them.
    Before use this function, you must setup `major-mode-name'-expand-alist variable.

    Take emacs-lisp-mode as example, if you wand to use <r to expand your snippet `require'
    in yasnippet, you muse setup the emacs-lisp-mode-expand-alist variable.

     (setq emacs-lisp-expand-alist '((\"r\" . \"require\")))"
    (let* ((l (buffer-substring (point-at-bol) (point)))
           (expand-symbol (intern (concat (symbol-name major-mode) "-expand-alist")))
           (expand-alist (if (boundp expand-symbol) (symbol-value expand-symbol) nil))
           a)
      (when (and (looking-at "[ \t]*$")
                 (string-match "^[ \t]*<\\([a-zA-Z]+\\)$" l)
                 (setq a (assoc (match-string 1 l) expand-alist)))
        (backward-delete-char (1+ (length (car-safe a))))
        (if (symbolp (cdr-safe a))
            (funcall (cdr-safe a))
          (insert (cdr-safe a)))
        t)
      ad-do-it))
#+end_src

假如希望在 emacs-lisp-mode 輸入 <r 再按下 TAB 就可以使用 yasnippet 展開
require 的 snippet, 則添加以下程式

#+begin_src emacs-lisp :tangle no
 (setq emacs-lisp-mode-expand-alist '(("r" . "require")))
#+end_src

注意到 major-mode 是什麼，則添加相對應的 *major-mode-expand-alist*,
比如 major-mode 是 c-mode 則加入

#+begin_src emacs-lisp :tangle no
 (setq c-mode-expand-alist '(("i" . "include")))
#+end_src

其他以此類推

*** 在建立新的檔案時，自動插入樣板

#+begin_src emacs-lisp
  ;; Auto add HEADER in new file
  (add-hook 'find-file-hook
            '(lambda ()
               (when (and (buffer-file-name)
                          (not (file-exists-p (buffer-file-name)))
                          (= (point-max) 1))
                 (let ((header-snippet "HEADER")
                       (yas/fallback-behavior 'return-nil))
                   (insert header-snippet)
                   ;; if can't expand snippet, clear whole buffer
                   (if (not (yas/expand))
                       (delete-region (point-min) (point-max)))))))
#+end_src
** undo-tree :: undo/redo

undo-tree 是 emacs 與 vim 上面都有的一個套件，對於 emacs 使用者而言，
undo-tree 幫 emacs 增加了 redo 的功能。

#+BEGIN_SRC emacs-lisp
  (require 'undo-tree)
  (global-undo-tree-mode)
#+END_SRC
** pangu-spacing :: 自動在英文與中文之間加入空白

[[https://github.com/coldnew/pangu-spacing][pangu-spacing]] 是 emacs 上的一個 minor-mode, 啟用他後，他會在英文與中文
之間自動加入空白符號，讓你使用 emacs 在閱讀文章的時候能夠非常舒適 :)

#+begin_src emacs-lisp
  (require 'pangu-spacing)
  (global-pangu-spacing-mode 1)
#+end_src

只有在 org-mode 裏面真的添加空白進去

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
              (set (make-local-variable 'pangu-spacing-real-insert-separtor) t)))
#+end_src
** key-chord :: 快速點擊按鍵呼叫命令

emacswiki: http://www.emacswiki.org/emacs/KeyChord

#+BEGIN_SRC emacs-lisp
  (require 'key-chord)
#+END_SRC
** uzumaki :: 緩衝區切換

#+BEGIN_SRC emacs-lisp
  (require 'uzumaki)
  (uzumaki-minor-mode 1)
#+END_SRC
** rainbow-mode :: 將 CSS 之類的色彩編碼顯示顏色出來

#+BEGIN_SRC emacs-lisp
  (require 'rainbow-mode)
#+END_SRC

** lusty-explorer :: 很棒的檔案尋找程式

#+BEGIN_SRC emacs-lisp
  (require 'lusty-explorer)
#+END_SRC

*** 使用 <ENTER> 選擇目前的檔案

#+begin_src emacs-lisp
  (add-hook 'lusty-setup-hook
            '(lambda ()
               (define-key lusty-mode-map (kbd "RET") 'lusty-select-current-name)))
#+end_src

*** 讓 lusty-explorer 能夠使用 sudo 來打開檔案                    :command:

#+begin_src emacs-lisp
  (defun lusty-sudo-explorer ()
    "Launch the file/directory mode of LustyExplorer."
    (interactive)
    (let ((lusty--active-mode :file-explorer)
          (lusty-prompt "sudo: >>"))
      (lusty--define-mode-map)
      (let* ((lusty--ignored-extensions-regex
              (concat "\\(?:" (regexp-opt completion-ignored-extensions) "\\)$"))
             (minibuffer-local-filename-completion-map lusty-mode-map)
             (file
              (lusty--run 'read-file-name default-directory "")))
        (when file
          (switch-to-buffer
           (find-file-noselect (concat "/sudo:root@localhost:"
                                       (expand-file-name file))))))))
#+end_src

*** 讓 lusty-explorer 使用自己的補全方式，而不是 helm 的補全方式

當 helm-mode 載入完後，將和 lusty-explorer 相關的命令加入至 helm-completing-read-handlers-alist，
以避免 lusty-explorer 使用 helm-mode 提供的補全方法。
#+begin_src emacs-lisp
  (eval-after-load "helm-mode"
    '(progn
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-sudo-explorer . nil))
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-file-explorer . nil))
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-buffer-explorer . nil))))
#+end_src

* 自定義函式 / 方法                                                :function:

我所自定義或是我的 emacs 設定檔需要用到的 function，這裡面有些 function
其實可以被 dash.el 或是 s.el 替代掉，只是因為已經加進去了，就先寫在這邊。

** 排序
*** 使用正規表達式排序行

#+begin_src emacs-lisp
  (defun sort-lines-regex (reg)
    "This is a function to sort lines by regex,
  which are placing near by each other."
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (re-search-forward reg)
      (let ((point (point-to-beginnnig-line)))
        (while (re-search-forward reg nil t))
        (sort-lines nil point (point)))))
#+end_src

*** 快速排序

#+begin_src emacs-lisp
  (defun quicksort (lst)
    "Implement the quicksort algorithm."
    (if (null lst) nil
      (let* ((spl (car lst))
             (rst (cdr lst))
             (smalp (lambda (x)
                      (< x spl))))
        (append (quicksort (remove-if-not smalp rst))
                (list spl)
                (quicksort (remove-if smalp rst))))))
#+end_src

** 檔案相關

*** 查詢檔案大小

#+begin_src emacs-lisp
  (defun file-size (filename)
    "Return the size in bytes of file named FILENAME, as in integer.
  Returns nil if no such file."
    (nth 7 (file-attributes filename)))
#+end_src

*** 大量打開檔案

#+begin_src emacs-lisp
  (defun find-files (files)
    "Open the given files"
    (foreach (f files) (find-file f)))
#+end_src

*** 遞迴尋找檔案

若在當前目錄找不到此檔案，則去其父目錄進行尋找。如果該檔案或是目錄不存
在，則回傳 nil.

#+begin_src emacs-lisp
  (defun recursive-find-file (file &optional directory)
    "Find the first FILE in DIRECTORY or it's parents.
  If file does not exist return nil."
    (let ((directory (or directory
                         (file-name-directory (buffer-file-name))
                         (pwd))))
      (if (file-exists-p (expand-file-name file directory))
          (expand-file-name file directory)
        (unless (string= "/" directory)
          (recursive-find-file file (expand-file-name ".." directory))))))
#+end_src

** 系統相關

*** 取得目前的 IP 位址

取得目前的 IP 位置，預設為 eth0。（此 function 不能用於 windows 上）

#+begin_src emacs-lisp
  (defun get-ip-address (&optional dev)
    "get the IP-address for device DEV (default: eth0)"
    (let ((dev (if dev dev "eth0")))
      (format-network-address (car (network-interface-info dev)) t)))
#+end_src

** 緩衝區相關

*** 取得 major-mode 和要求符合的所有 buffer

假如我們希望可以列出所有為 emacs-lisp-mode 的 buffer，可以這樣做

#+begin_src emacs-lisp :tangle no
  (get-buffers-matching-mode 'emacs-lisp-mode)
#+end_src

#+begin_src emacs-lisp
  (defun get-buffers-matching-mode (mode)
    "Returns a list of buffers where their major-mode is equal to MODE"
    (let ((buffer-mode-matches '()))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (if (eq mode major-mode)
              (add-to-list 'buffer-mode-matches buf))))
      buffer-mode-matches))
#+end_src

*** 顯示 buffer 目前所處於的 major-mode

#+begin_src emacs-lisp :tangle no
  (show-buffer-major-mode "*scratch*")
#+end_src

#+begin_src emacs-lisp
  (defun show-buffer-major-mode (buffer-or-string)
    "Returns the major mode associated with a buffer."
    (with-current-buffer buffer-or-string major-mode))
#+end_src

** 尋找、取代

*** 向後搜尋一個字元

#+begin_src emacs-lisp
  (defun search-backward-to-char (chr)
    "Search backwards to a character"
    (while (not (= (char-after) chr))
      (backward-char 1)))
#+end_src

*** 向前搜尋一個字元

#+begin_src emacs-lisp
  (defun search-forward-to-char (chr)
    "Search forwards to a character"
    (while (not (= (char-before) chr))
      (forward-char 1)))
#+end_src

** 鏈表 (list) 處理

處理 List 所用的 function，有些功能 dash.el 也有提供。

*** 將一個 list 變成字串回傳

#+begin_src emacs-lisp
  (defun list->string (char-list)
    "RETURN: A new string containing the characters in char-list."
    (let ((result (make-string (length char-list) 0))
          (i 0))
      (dolist (char char-list)
        (aset result i char)
        (setq i (1+ i)))
      result))
#+end_src

*** 將巢狀的 list 變成單一 list :: flatten

flatten a list 是一種方法，可以用來將巢狀的 list 變成單一個 list。
舉例來說，假如目前有這樣一個 list:

#+begin_example
(1 (2 3) (4 (5 6 (7))) 8 9)
#+end_example

則使用 flatten 這個 function 可以將上面的巢狀 list 變成:

#+begin_example
(1 2 3 4 5 6 7 8 9)
#+end_example

#+begin_src emacs-lisp
  (defun flatten (structure)
    "Flatten the nesting in an arbitrary list of values."
    (cond ((null structure) nil)
          ((atom structure) `(,structure))
          (t (mapcan #'flatten structure))))
#+end_src

** 檔案/字串/數值轉換

進行轉換用的 function。

*** 將輸入的 buffer (DOS 格式)　轉換成 UNIX 格式

#+begin_src emacs-lisp
  (defun dos->unix (buf)
    "Convert buffer file from dos file to unix file."
    (let* (current-buf (current-buffer))
      (if (not (eq current-buf buf))
          (switch-to-buffer buf))
      (goto-char(point-min))
      (while (search-forward "\r" nil t) (replace-match ""))))
#+end_src

*** 將輸入的 buffer (UNIX 格式)　轉換成 DOS 格式

#+begin_src emacs-lisp
  (defun unix->dos (buf)
    "Convert buffer file from unix file to dos file."
    (let* (current-buf (current-buffer))
      (if (not (eq current-buf buf))
          (switch-to-buffer buf))
      (goto-char(point-min))
      (while (search-forward "\n" nil t) (replace-match "\r\n"))))
#+end_src

*** 將檔案變成字串

此 function 比較適用於該檔案只有一行（或少數幾行）的情況。
#+begin_src emacs-lisp
  (defun file->string (file)
    "Convert file to string in buffer with quote."
    (when (file-readable-p file)
      (with-temp-buffer
        (insert-file-contents file)
        (buffer-string))))
#+end_src

*** 十進位轉換成十六進位

#+begin_src emacs-lisp
  (defun dec->hex (decimal)
    "Convert decimal to hexdecimal number."
    (let ((hexstr))
      (if (stringp decimal)
          (setq decimal (string-to-number decimal 16)))
      (cond
       ;; Use #x as hex prefix (elisp, ....)
       ((or (eq major-mode 'emacs-lisp-mode)
            (eq major-mode 'lisp-interaction-mode)) (setq hexstr "#x"))
       ;; Use # as hex prefix (CSS, ....)
       ((eq major-mode 'css-mode) (setq hexstr "#"))
       ;; otherwise use 0x as hexprefix (C, Perl...)
       (t (setq hexstr "0x")))
      (format "%s%02X" hexstr decimal)))
#+end_src

*** 十六進位轉換成十進位

#+begin_src emacs-lisp
  (defun hex->dec (hex)
    "Convert hexdecimal number or string to digit-number."
    (let ((case-fold-search nil)
          (hex-regexp (rx (or
                           ;; elisp
                           (group bol "#x")
                           ;; C perl
                           (group bol "0x")
                           ;; CSS
                           (group bol "#")))))
      (if (not (stringp hex))
          (setq hex (symbol-name hex)))
      (string-to-number
       (replace-regexp-in-string hex-regexp "" hex)
       16)))
#+end_src
*** 十進位轉換成二進位

#+BEGIN_SRC emacs-lisp
  (defun dec->bin (n &optional length)
    "Convert integer N to bit string (LENGTH, default 8)."
    (let* ((i 0)
           (len (or length 8))
           (s (make-string len ?0)))
      (while (< i len)
        (if (not (zerop (logand n (ash 1 i))))
            (aset s (- len (1+ i)) ?1))
        (setq i (1+ i)))
      s))
#+END_SRC
** 作業系統測試

- MacOS X

  #+BEGIN_SRC emacs-lisp
    (defvar mac-p (eq system-type 'darwin)
      "Return nil if OS is not Mac.")
  #+END_SRC

- Linux

  #+BEGIN_SRC emacs-lisp
    ;; All linux device
    (defvar linux-p   (and (eq system-type 'gnu/linux) (not (eq system-type 'drawin)))
      "Return nil if OS is not Linux.")

    ;; linux 32-bit
    (defvar linux-32bit-p
      (and (string-match
            (rx (or bos "x86-" bos "i686-")) system-configuration) linux-p)
      "Return nil if OS is not 32-bit linux.")

    ;; linux 64-bit
    (defvar linux-64bit-p
      (and (string-match (rx bos "x86_64") system-configuration) linux-p)
      "Return nil if OS is not 64-bit linux.")
  #+END_SRC

- Windows

  #+BEGIN_SRC emacs-lisp
    (defvar windows-p (eq system-type 'windows-nt)
      "Return nil if OS is not Windows.")

    (defvar cygwin-p  (eq system-type 'cygwin)
      "Return nil if OS is not CygWin.")
  #+END_SRC

* 字體設置                                                             :font:

** 英文字體與中文字體設置

- 英文字體

  #+begin_src emacs-lisp
    (defvar emacs-english-font "Monaco"
      "The font name of English.")
  #+end_src

- 中文字體

  #+begin_src emacs-lisp
    (defvar emacs-cjk-font "Hiragino Sans GB W3"
      "The font name for CJK.")
  #+end_src

** 預設字體大小設定

為了可以在 org-mode 的表格中縮放字體也不會有中英文排版亂掉的情況，我的
字體設定是以 pair 的形式來進行設定，*emacs-font-size-pair* 存放預設的
字體，若有使用我自訂的字體放大/縮小命令，則這個變數也會更著被修改。

#+BEGIN_SRC emacs-lisp
  (defvar emacs-font-size-pair '(15 . 18)
    "Default font size pair for (english . chinese)")
#+END_SRC

** 在圖形介面下使用我所設定的字體

這邊主要定義 *set-font* 這個函式，他會根據傳送給他的字體資訊，即時設定
整個 emacs 的字體大小，這樣也不會有切換 buffer，但是字體確沒有跟著之前的
設定而變大/變小。

#+BEGIN_SRC emacs-lisp
  (defun font-exist-p (fontname)
    "test if this font is exist or not."
    (if (or (not fontname) (string= fontname ""))
        nil
      (if (not (x-list-fonts fontname))
          nil t)))

  (defun set-font (english chinese size-pair)
    "Setup emacs English and Chinese font on x window-system."

    (if (font-exist-p english)
        (set-frame-font (format "%s:pixelsize=%d" english (car size-pair)) t))

    (if (font-exist-p chinese)
        (dolist (charset '(kana han cjk-misc bopomofo))
          (set-fontset-font (frame-parameter nil 'font) charset
                            (font-spec :family chinese :size (cdr size-pair))))))

  ;; Setup font size based on emacs-font-size-pair
  (set-font emacs-english-font emacs-cjk-font emacs-font-size-pair)
#+END_SRC

** 使用 C-= 或是 C-- 來調整字體大小

這邊設定了一個 *emacs-font-size-pair-list* 變數，這個變數存放了即使使
用這一對字體大小，org-mode 的表格也不會走樣的中英字體設定。

#+BEGIN_SRC emacs-lisp
  (defvar emacs-font-size-pair-list
    '(( 5 .  6) (10 . 12)
      (13 . 16) (15 . 18) (17 . 20)
      (19 . 22) (20 . 24) (21 . 26)
      (24 . 28) (26 . 32) (28 . 34)
      (30 . 36) (34 . 40) (36 . 44))
    "This list is used to store matching (english . chinese) font-size.")

  (defun emacs-step-font-size (step)
    "Increase/Decrease emacs's font size."
    (let ((scale-steps emacs-font-size-pair-list))
      (if (< step 0) (setq scale-steps (reverse scale-steps)))
      (setq emacs-font-size-pair
            (or (cadr (member emacs-font-size-pair scale-steps))
                emacs-font-size-pair))
      (when emacs-font-size-pair
        (message "emacs font size set to %.1f" (car emacs-font-size-pair))
        (set-font emacs-english-font emacs-cjk-font emacs-font-size-pair))))

  (defun increase-emacs-font-size ()
    "Decrease emacs's font-size acording emacs-font-size-pair-list."
    (interactive) (emacs-step-font-size 1))

  (defun decrease-emacs-font-size ()
    "Increase emacs's font-size acording emacs-font-size-pair-list."
    (interactive) (emacs-step-font-size -1))

  (global-set-key (kbd "C-=") 'increase-emacs-font-size)
  (global-set-key (kbd "C--") 'decrease-emacs-font-size)
#+END_SRC

** 設定顯示字體時的格式

使用 *list-face-display* 可以看到所有的 face 顏色與字體。

#+begin_src emacs-lisp
  (setq list-faces-sample-text
        (concat
         "ABCDEFTHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz\n"
         "11223344556677889900       壹貳參肆伍陸柒捌玖零"))
#+end_src

* 佈景主題                                                            :theme:

佈景主題的設置，包含我自訂的佈景主題以及路徑。
** 設定佈景主題的位置。

佈景主題的路徑設定在 emacs-themes-dir 裡面。
#+begin_src emacs-lisp
  (setq custom-theme-directory emacs-themes-dir)
#+end_src

** 設定額外的佈景主題變數

#+begin_src emacs-lisp
  (defface mode-line-read-only-face
    '((t (:foreground "#C82829" :bold t)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface mode-line-modified-face
    '((t (:inherit 'font-lock-function-name-face :bolt t)))
    "face for mode-name-string in modeline."
    :group'mode-lin)

  (defface mode-line-mode-name-face
    '((t (:inherit font-lock-keyword-face)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface font-lock-escape-char-face
    '((((class color)) (:foreground "seagreen2")))
    "highlight c escapes char like vim"
    :group 'font-lock-faces)
#+end_src

** 設定預設讀取的佈景主題。

這邊載入我新設計的佈景主題。

#+begin_src emacs-lisp
  (require 'coldnew-theme)
  ;; TODO: use following to read theme
  ;;(load-theme 'coldnew-theme-night t)
  (coldnew-theme--define-theme night)
#+end_src

* Vim 摹擬                                                              :vim:

實在不能不佩服 vi 系列按鍵使用的高效率，將許多常用的巨集綁到一個按鍵上，
只要一個按鍵就可以呼叫，為了提升編輯效率，套用一些 Vim 的按鍵也是再所難免。

好用的 vim 快速鍵組合：[[http://dnquark.com/blog/2012/02/emacs-evil-ecumenicalism/][Emacs + Evil = ecumenicalism]]

- d/foo[RET] 從目前的游標位置刪除到字串 foo
- dfa        從目前的游標位置刪除到字元 a，包含 a 本身
- cta        從目前的游標位置刪除到字元 a，不包含 a 本身
- viw        將目前游標所在的 "字" 選擇起來
- vfa        從目前的游標位置選擇到字元 a，包含 a 本身
- yi)        複製括號內的東西，不包含括號本身
- di"        刪除雙引號內的文字

Evil 是 emacs 上最好用的 vim 摹擬程式。

#+BEGIN_SRC emacs-lisp
  (require 'evil)
  (evil-mode t)
#+END_SRC

evil-mdoe 預設會讓游標變成黑色，這對於習慣使用暗色系佈景主題的
使用者而言是一件很討厭的事情，設定 evil-default-cursor 為 true
後就可以使用使用者自訂的佈景主題來改變滑鼠了。

#+begin_src emacs-lisp
  (setq evil-default-cursor t)
#+end_src

** 將 Emacs 按鍵綁到 Insert 模式上

對我而言，Vim 的 Insert 模式是趨近於無用的，這邊將我的 Emacs 模式下的按鍵綁到
Insert 模式上，之後再來做其他設置。

#+begin_src emacs-lisp
  (setcdr evil-insert-state-map nil)
  (define-key evil-insert-state-map
    (read-kbd-macro evil-toggle-key) 'evil-emacs-state)
#+end_src

將 ESC 綁定成切換為 normal-state-map，因為我用自己的 emacs 按鍵綁定蓋掉了 evil-mode
裡面的 insert-state 按鍵綁定，所以這邊要先加入這個設定，才能夠用 ESC 來切換到
normal-state。

注意到除了 ESC 按鍵本身，使用 C-[ 也具有 ESC 按鍵的效果。

#+begin_src emacs-lisp
  (define-key evil-insert-state-map [escape] 'evil-normal-state)
#+end_src

** 讓 evil-mode 的區域選擇方式和 Vim 相同

在 emacs 中，最後一個被選擇的字元是游標的前一個字元，但是在 vim 中，卻是在游標
下的那個字元。

若要使用和 vim 相同的方式，則要進行下面的設定:

#+begin_src emacs-lisp
  (setq evil-want-visual-char-semi-exclusive t)
#+end_src

** 在 emacs-state 時將游標設定為 bar 形狀

在我的設定裡面 eacs-state 相當於 insert-state，因此使用相同的游標型態會
比較好

#+BEGIN_SRC emacs-lisp
  (setq evil-emacs-state-cursor '(bar))
#+END_SRC

** 將原本為 emacs-state 的緩衝區變成使用 insert-state

在我的設定中，insert-state 和 emacs-state 是相同的按鍵設定，因此直接榜定
到 insert-state，這樣要切換到 normal-state 也比較方便

#+BEGIN_SRC emacs-lisp
  (dolist (m evil-emacs-state-modes)
    (add-to-list 'evil-insert-state-modes m))
#+END_SRC

* Vim 模擬擴充                                                          :vim:

** 使用 evil-nerd-commenter 更簡單去將程式註解掉

[[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] 是一個用於 evil-mode 上面的註解輔助工具，使用他以
後，可以在 Normal-state 下面使用 =﻿,ci= 將當前行註解/反註解。

常用用法:

- =﻿,,,﻿= 註解/反註解當前行
- =﻿,,9j= 註解/反註解之後 9 行
- =﻿,,99G= 從當前行開始到 99 行進行註解/反註解
- =﻿,,a(= 對目前的 s-exp 進行註解
- =﻿,,ai= 僅註解當前的 s-exp 內容
- =﻿,,ao= 註解/反註解當前的符號
- =﻿,,aW= 註解/反註解當前的詞

#+BEGIN_SRC emacs-lisp
  (require 'evil-nerd-commenter)
  (evilnc-default-hotkeys)
#+END_SRC

** 使用 evil-numbers 遞增/遞減數字

evil-numbers 提供了更簡單的方式對數字進行遞增/遞減的動作

GitHub: https://github.com/cofi/evil-numbers

#+BEGIN_SRC emacs-lisp
  (require 'evil-numbers)
#+END_SRC

** 使用 evil-surround 快速切換配對符號

| 原本內文              | 命令    | 修改後的內文              |
|-----------------------+---------+---------------------------|
| "Hello *world!"       | ds"     | Hello world!              |
| [123+4*56]/2          | cs])    | (123+456)/2               |
| "Look ma, I'm *HTML!" | cs"<q>  | <q>Look ma, I'm HTML!</q> |
| if *x>3 {             | ysW(    | if ( x>3 ) {              |
| my $str = *whee!;     | vlllls' | my $str = 'whee!';        |
| <div>Yo!*</div>       | dst     | Yo!                       |
| <div>Yo!*</div>       | cst<p>  | <p>Yo!</p>                |

GitHub: https://github.com/timcharper/evil-surround

#+BEGIN_SRC emacs-lisp
  (require 'evil-surround)
  (global-evil-surround-mode 1)
#+END_SRC

* 緩衝區                                                             :buffer:

** 自動建立 *scratch* 緩衝區

*scratch* 在 emacs 下是非常好用的緩衝區，如果他不存在的話，自動建立他。

#+BEGIN_SRC emacs-lisp
  (run-with-idle-timer 1 t
                       '(lambda () (get-buffer-create "*scratch*")))
#+END_SRC

** ibuffer

#+BEGIN_SRC emacs-lisp
  (require 'ibuffer)
  (require 'ibuf-ext)
#+END_SRC

*** 基本設定

#+BEGIN_SRC emacs-lisp
  (setq ibuffer-always-compile-formats         t )
  (setq ibuffer-default-shrink-to-minimum-size t )
  (setq ibuffer-expert                         t )
  (setq ibuffer-show-empty-filter-groups     nil )
  (setq ibuffer-use-other-window             nil )
  (setq ibuffer-always-show-last-buffer      nil )
#+END_SRC

*** ibuffer 加入 git 支援

#+BEGIN_SRC emacs-lisp
  (require 'ibuffer-git)

  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000) (format "%7.3fK" (/ (buffer-size) 1000.0)))
     ((> (buffer-size) 1000000) (format "%7.3fM" (/ (buffer-size) 1000000.0)))
     (t (format "%8dB" (buffer-size)))))
#+END_SRC

*** 設定 ibuffer 欄位顯示格式

#+BEGIN_SRC emacs-lisp
  (setq ibuffer-formats
        '((mark modified read-only git-status-mini " "
                (name 23 23 :left :elide)
                " "
                (size-h 9 -1 :right)
                "  "
                (mode 16 16 :left :elide)
                " "
                (git-status 8 8 :left)
                "    "
                filename-and-process)))
#+END_SRC

*** 定義緩衝區分類方式

#+BEGIN_SRC emacs-lisp
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("*Buffer*" (or
                        (name . "^TAGS\\(<[0-9]+>\\)?$")
                        (name . "^\\**Loading Log\\*$")
                        (name . "^\\*coldnew/filelist\\*$")
                        (name . "^\\*Backtrace\\*$")
                        (name . "^\\*Buffer List\\*$")
                        (name . "^\\*CEDET Global\\*$")
                        (name . "^\\*Compile-Log\\*$")
                        (name . "^\\*Completions\\*$")
                        (name . "^\\*EGG:*")
                        (name . "^\\*Kill Ring\\*$")
                        (name . "^\\*Occur\\*$")
                        (name . "^\\*Customize*")
                        (name . "^\\*Process List\\*$")
                        (name . "^\\*Shell Command Output\\*")
                        (name . "^\\*Warnings\\*$")
                        (name . "^\\*compilation\\*$")
                        (name . "^\\*el-get*")
                        (name . "^\\*grep\\*$")
                        (name . "^\\*gud\\*$")
                        (name . "^\\*ielm\\*")
                        (name . "^\\*im.bitlbee.org\\*$")
                        (name . "^\\*scratch\\*$")
                        (name . "^\\*tramp")
                        (name . "^\\*wclock\\*$")
                        (name . "^ipa*")
                        (name . "^loaddefs.el$")
                        (name . "^\\*Messages\\*$")
                        (name . "^\\*WoMan-Log\\*$")
                        ))
           ("Version Control" (or (mode . svn-status-mode)
                                  (mode . svn-log-edit-mode)
                                  (name . "^\\*svn*\\*")
                                  (name . "^\\*vc*\\*$")
                                  (name . "^\\*Annotate")
                                  (name . "^\\*git-*")
                                  (name . "^\\*cvs*")
                                  (name . "^\\*vc-*")
                                  (mode . egg-status-buffer-mode)
                                  (mode . egg-log-buffer-mode)
                                  (mode . egg-commit-buffer-mode)))
           ("Help" (or (mode . woman-mode)
                       (mode . man-mode)
                       (mode . info-mode)
                       (mode . help-mode)
                       (name . "\\*Help\\*$")
                       (name . "\\*info\\*$")))
           ("Dired" (or (mode . dired-mode)
                        (mode . nav-mode)))
           ("IRC"   (or (mode . erc-mode)
                        (mode . rcirc-mode)))
           ("Jabber" (or (mode . jabber-roster-mode)
                         (mode . jabber-chat-mode)))
           ("Terminal" (or (mode . eshell-mode)
                           (mode . term-mode)
                           (mode . inferior-python-mode)
                           (mode . eshell-mode)
                           (mode . comint-mode)
                           (name . "\\*scheme\\*$")))
           ("Config" (name . "*.conf$"))
           ("Text" (or (mode . text-mode)
                       (name . "*.txt$")))
           ("w3m"   (or (mode . w3m-mode)
                        (name . "^\\*w3m*")))
           ("Org"   (mode . org-mode))
           ("LaTEX" (or (mode . latex-mode)
                        (name . "*.tex$")))
           ("Verilog" (mode . verilog-mode))
           ("Web Develop" (or (mode . html-mode)
                              (mode . css-mode)))
           ("Shell Script" (or (mode . shell-script-mode)
                               (mode . shell-mode)
                               (mode . sh-mode)
                               (mode . ruby-mode)))
           ("Perl"  (or (mode . cperl-mode)
                        (mode . perl-mode)))
           ("Python" (or (mode . python-mode)
                         (mode . ipython-mode)))
           ("Octave" (or (mode . octave-mode)
                         (mode . inferior-octave-mode)))
           ("Scala" (or (mode . scala-mode)
                        (name . "\\*inferior-scala\\*$")))
           ("Diff" (mode . diff-mode))
           ("JavaScript" (or (mode . js-mode)
                             (mode . js2-mode)))
           ("C++ . C#" (or (mode . c++-mode)
                           (mode . csharpmode)))
           ("C"          (mode . c-mode))
           ("Object-C"   (mode . objc-mode))
           ("Snippet" (or (mode . snippet-mode)
                          (name . "*.yas$")))
           ("newLisp"  (mode . newlisp-mode))
           ("Common Lisp"   (mode . slime-mode))
           ("Scheme"  (or (mode . scheme-mode)
                          (mode . gambit-mode)))
           ("Clojure" (or (mode . clojure-mode)
                          (name . "\\*slime-repl clojure\\*")))
           ("Emacs recipes" (name . "*.rcp$"))
           ("Emacs" (or (mode . emacs-lisp-mode)
                        (mode . lisp-interaction-mode)
                        ))
           )))

  ;; Use this filter groups
  (add-hook 'ibuffer-mode-hook '(lambda () (ibuffer-switch-to-saved-filter-groups "default")))
#+END_SRC

*** 設定不顯示在 ibuffer 中的緩衝區名稱

#+BEGIN_SRC emacs-lisp
  (setq ibuffer-never-show-predicates
        (list
         "^\\*Buffer List\\*$"
         "^\\*CEDET Global\\*$"
         "^\\*MiniBuf-*"
         "^\\*Egg:Select Action\\*$"
         "^\\*Ido Completions\\*$"
         "^\\*SPEEDBAR\\*$"
         "^\\*nav\\*$"
         "^\\*swank\\*$"
         "^\\*slime-events\\*$"
         "^\\*RE-Builder\\*$"
         "^\\*pomodoro\\*$"
         "^\\*Project Buffers\\*$"
         "^eproject$"
         "\\*fsm-debug\\*$"
         ;; "^"
         "^\\*.*\\(-preprocessed\\)\\>\\*"
         "^\\*ORG.*\\*"
         "^\\*ac-mode-*"
         ".loaddefs.el$"
         "^loaddefs.el$"
         "\\*GTAGS SELECT\\**"
         "\\*Symref*"
         "\\*cscope\\*"
         "\\*helm*"
         ))
#+END_SRC

*** 修改部分 ibuffer 預設的命令

#+begin_src emacs-lisp
  ;; Reverse group list
  (defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups () activate)
    (setq ad-return-value (nreverse ad-return-value)))

  ;; Switching to ibuffer puts the cursor on the most recent buffer
  (defadvice ibuffer (around ibuffer-point-to-most-recent activate)
    "Open ibuffer with cursor pointed to most recent buffer name"
    (let ((recent-buffer-name (buffer-name)))
      ad-do-it
      (ibuffer-jump-to-buffer recent-buffer-name)))

  ;; Kill ibuffer after quit
  (defadvice ibuffer-quit (after kill-ibuffer activate)
    "Kill the ibuffer buffer on exit."
    (kill-buffer "*Ibuffer*"))
#+end_src
*** 進入 ibuffer 後將游標當前行上色

#+BEGIN_SRC emacs-lisp
  (add-hook 'ibuffer-mode-hook 'hl-line-mode)
#+END_SRC
*** 進入 ibuffer 後自動排列檔案名稱

#+BEGIN_SRC emacs-lisp
  (add-hook 'ibuffer-mode-hook 'ibuffer-do-sort-by-filename/process)
#+END_SRC
*** 按鍵設定                                                     :noexport:

#+TBLNAME: ibuffer-keys
| 按鍵    | 命令                | 描述                                |
|---------+---------------------+-------------------------------------|
| C-x C-f | lusty-file-explorer | 使用 lusty-file-explorer 來尋找檔案 |

#+BEGIN_SRC emacs-lisp :noweb yes
  <<gen-keys-map2(map="ibuffer-mode", keys=ibuffer-keys)>>
#+END_SRC

* Org                                                                   :org:

org-mode 是非常強大的筆記管理系統，也是這整份 emacs 設定的核心，由於與
他設定相關的東西太多了，特別將設定獨立出來。

#+BEGIN_SRC emacs-lisp
  (require 'org)
  (require 'org-install)
  (require 'org-table)
#+END_SRC

如果遇到副檔名為 .org 或是 .org_archive 的情況，則自動將他們認定為
org-mode 的檔案。

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.org_archive$" . org-mode))
#+end_src

** 基本設定

- 預設讓 org-mode 使用自動縮排模式

  #+begin_src emacs-lisp
    (setq org-startup-indented t)
  #+end_src

- 預設將所有項目都隱藏，只保留最上層的父目錄

  #+begin_src emacs-lisp
    (setq org-startup-folded t)
  #+end_src

- 將前面的 *星號* 隱藏，只顯示最後一個

  #+begin_src emacs-lisp
    (setq org-hide-leading-stars t)
  #+end_src

- 直接在程式碼欄位上為程式碼上色

  #+begin_src emacs-lisp
    (setq org-src-fontify-natively t)
  #+end_src

- 切換成程式碼欄位時使用目前的視窗

  #+begin_src emacs-lisp
    (setq org-src-window-setup 'current-window)
  #+end_src

** 加強 org-mode 強調文句的正規表達式

org-mode 裏面的用來強調 (emphasize) 字體的正規表達式有一些缺點，
比如你想使用下面的表達方式就會出現問題。

: ~target="_self"~   =>  <code>target="_self"</code>

解決的方式有兩個

1. 如果你確定這個文句是要輸出成為 HTML 的話，你可以使用下面的方式強制
   將他轉換。

   :  @@html:<code> target="_self" </code>@@

   關於更多 @@html: ... @@ 區塊的資訊，請參考 [[http://orgmode.org/manual/Quoting-HTML-tags.html#Quoting-HTML-tags][Quoting-HTML-tags]]

2. 你也可以輸入特別的 Unicode 字元

   : <U200B> /xe2/x80/x8b ZERO WIDTH SPACE

   這個特殊的 Unicode 字元顯示出一個很微小的的空白，基本上你是看不出來
   的，插入的方式是使用 *C-x 8 RET 200b RET* 來輸入這個 Unicode 字元。

   此外，你也要修改 *org-emphasis-regexp-components* 的規則。

原始的規則如下

#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom org-emphasis-regexp-components
   '(" ​\t('\"{" "- ​\t.,:!?;'\")}\\" " \t\r\n,\"'" "." 1))
#+END_SRC

修改成如下 (其中的 *#* 代表剛剛所提及的 <U200B> 字元 )

#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom org-emphasis-regexp-components
   '(" #​\t('\"{" "- ​\t.,:!?;'\")}\\" " \t\r\n,\"'" "." 1))
#+END_SRC

因此以下就是我實際上修改過後的 *org-emphasis-regexp-components* 。

#+BEGIN_SRC emacs-lisp
  (setq org-emphasis-regexp-components '(" ​\t('\"{" "- \t.,:!?;'\")}\\" " \t\r\n,\"'" "." 1))
#+END_SRC

** 設定 Babel 支援的語言

org-mode 的 Bebel 有一個非常好用的功能，你可以對程式碼區塊使用 =C-c C-c=
進行運算(eval)，要使用這個功能，必須使用以下的程式碼將該﻿語言的 babel 功
能打開。

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (ditaa . t)
     (dot . t)
     (js . t)
     (latex . t)
     (perl . t)
     (python . t)
     (ruby . t)
     (sh . t)
     (plantuml . t)
     (clojure .t)
     ))
#+END_SRC

** 對程式碼區塊進行運算 (eval) 時不再詢問

預設情況下，當你對程式碼區塊使用 =C-c C-c= 進行運算的時候，emacs 會詢問
你是否真的要這樣作，這是一個很惱人厭的功能(基於安全考量)，我在這邊關掉
他，這樣我可以直接對這些程式碼區塊進行運算。

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src
** 使用 deft 快速瀏覽、尋找筆記

Homepage: http://jblevins.org/projects/deft/

#+BEGIN_SRC emacs-lisp
  (require 'deft)
#+END_SRC

*** 設定尋找得檔案副檔名為 *.org

deft 其實也可以用於 *.txt 檔案，不過我更偏好用在 org-mode 上。

#+BEGIN_SRC emacs-lisp
  (setq deft-extension "org")
#+END_SRC

建立名為 =deft-note-mode= 的 minor-mode，這個 monor-mode 將用在後面快速
刪除 deft-mode 的命令上。

#+BEGIN_SRC emacs-lisp
  (define-minor-mode deft-note-mode "Deft notes" nil " Deft-Notes" nil)
  (setq deft-text-mode 'deft-note-mode)
#+END_SRC

*** 尋找的目錄設定為 ~/Copy/org

我將我筆記類的 org-mode 文件都放在 =~/Copy/org/= 裡面。

#+BEGIN_SRC emacs-lisp
  (setq deft-directory "~/Copy/org/")
#+END_SRC

*** 設定檔案名稱即為標題

#+BEGIN_SRC emacs-lisp
  (setq deft-use-filename-as-title t)
#+END_SRC

*** 快速刪除 deft 的緩衝區                                        :command:

#+BEGIN_SRC emacs-lisp
  (defun kill-all-deft-notes ()
    (interactive)
    (save-excursion
      (let ((count 0))
        (dolist (buffer (buffer-list))
          (set-buffer buffer)
          (when (not (eq nil deft-note-mode))
            (setq count (1+ count))
            (kill-buffer buffer))))))
#+END_SRC

*** 開啟/關閉 deft                                                :command:

#+BEGIN_SRC emacs-lisp
  (defun deft-or-close ()
    (interactive)
    (if (or (eq major-mode 'deft-mode) (not (eq nil deft-note-mode)))
        (progn (kill-all-deft-notes) (kill-buffer "*Deft*"))
      (deft)))
#+END_SRC
*** 設定自動儲存的時間

預設的 deft-mode 會自動一段時間對文件進行儲存，這裡將他關閉。

#+BEGIN_SRC emacs-lisp
  (setq deft-auto-save-interval 0)
#+END_SRC

** 擴充 org-mode 的 easy-template

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
               (add-to-list 'org-structure-template-alist
               '("S" "#+BEGIN_SRC sh\n?\n#+END_SRC"))
               (add-to-list 'org-structure-template-alist
               '("p" "#+BEGIN_SRC plantuml :file uml.png \n?\n#+END_SRC"))
#+end_src

** 在 org-mode 裡面加密部分文章                                       :crypt:

用於加密 org-mode 裡面具有 :secret: 這個 TAG 的區塊。
注意到這需啟用 [[*Easy%20PG][Easy PG]] 才能夠使用。

#+begin_src emacs-lisp
  (require 'org-crypt)
#+end_src

*** 設定要加密的 tag 標籤為 *secret*

#+begin_src emacs-lisp
  (setq org-crypt-tag-matcher "secret")
#+end_src

*** 當被加密的部份要存入硬碟時，自動加密回去

如果 emacs 有打開檔案備份，在存回硬碟前必須要先加密在儲存，
否則加密的部份也會被備份起來。

#+begin_src emacs-lisp
  (org-crypt-use-before-save-magic)
#+end_src

*** 避免 encrypt 這個 tag 被子項目繼承

避免 secret 這個 tag 被子項目繼承 造成重複加密
(但是子項目還是會被加密喔)

#+begin_src emacs-lisp
  (setq org-tags-exclude-from-inheritance (quote ("secret")))
#+end_src

*** 設定 org-crypt-disable-auto-save 成 encrypt 模式。

此模式並不會停用 auto-save-mode，反之，當自動儲存時，解密過的區域將會加密回去。

#+begin_src emacs-lisp
  (setq org-crypt-disable-auto-save 'encrypt)
#+end_src

*** 設定用於加密的 GPG 金鑰

可以設定任何 ID 或是設成 nil 來使用對稱式加密 (symmetric encryption)

#+BEGIN_SRC emacs-lisp
  (setq org-crypt-key nil)
#+END_SRC
** 將 plantuml 加入 org-mode

plantuml 是一個用語言寫出 UML 架構圖的程式，使用他前必須將 Garphviz 裝上。

#+BEGIN_SRC emacs-lisp
  (setq org-plantuml-jar-path (concat emacs-etc-dir "plantuml.jar"))
#+END_SRC

** 將 ditaa 加入 org-mode

#+BEGIN_SRC emacs-lisp
  (require 'ob-ditaa)
  (setq org-ditaa-jar-path (concat emacs-etc-dir "ditaa.jar"))
#+END_SRC

* Helm                                                                 :helm:

Helm (領航員) 是 emacs 下非常強大的檔案尋找工具，可以用他快速的找尋已經
打開的緩衝區、檔案，或是透過 locate 命令來找尋檔案，此外 helm 也提供了
oscurr 功能，可以直接在目前的檔案裡找相同的字串。

#+BEGIN_SRC emacs-lisp
  (require 'helm)
  (require 'helm-config)
  (require 'helm-dash)
#+END_SRC

** 全域性啟用 helm-mode

#+begin_src emacs-lisp
  (helm-mode 1)
#+end_src

** 加入 git 支援

#+BEGIN_SRC emacs-lisp
  (require 'helm-ls-git)
#+END_SRC

** 禁止 helm 自動補全

默認的 helm 會自動幫使用者進行補全，但如果遇到名稱接近的資料夾、檔案，這
個時候 helm 就可能補全錯誤的資訊，解決的方式是使用 =C-<backspace>= 來切
換 helm 的自動補全模式。

這邊將預設的自動補全關閉，有需要再使用 =C-<backspace>= 來打開。

#+BEGIN_SRC emacs-lisp
  (setq helm-ff-auto-update-initial-value nil)
#+END_SRC

** 設定不啟用 helm-mode 的命令

helm 預設會變成全域性選項，所有 emacs 切換用的命令都會變成使用 helm 作為
backend，這邊設定某些命令不要使用 helm 作為 backend，而是使用該命令原生的
方式進行顯示。

#+BEGIN_SRC emacs-lisp
  (eval-after-load "helm-mode"
    '(progn
       (add-to-list 'helm-completing-read-handlers-alist '(erc-iswitchb . nil))))
#+END_SRC

** 按鍵設定                                                       :noexport:

#+TBLNAME: helm-keys
| 按鍵  | 命令                           | 描述                          |
|-------+--------------------------------+-------------------------------|
| <tab> | helm-execute-persistent-action | 使用 tab 對 helm 進行自動補全 |

#+BEGIN_SRC emacs-lisp :noweb yes
  <<gen-keys-map2(map="helm", keys=helm-keys)>>
#+END_SRC

* 自動補全 (AC)                                                :autocomplete:

auto-complete-mode 是目前使用 emacs 的人都會安裝的自動補全用的 backend，
他可以透過許多函式庫來協助你更好的在 emacs 中進行補全。在 emacs 中，
auto-complete 算是最熱門的補全方式，但是根據最近的 commit 紀錄以及 issue 來
看，進展緩慢，反而是 company-mode 一直有在更新。

Github: https://github.com/auto-complete/auto-complete

#+BEGIN_SRC emacs-lisp
  (require 'auto-complete)
  (require 'auto-complete-config)
#+END_SRC

** 使用 auto-complete-mode 提供的預設設定

auto-complete-mode 本身就提供了一些不錯的設定，這邊直接套用。

#+BEGIN_SRC emacs-lisp
  (ac-config-default)
#+END_SRC

** 啟用 fuzzy-match

啟用 fuzzy-match 讓尋找要補全的文字更輕鬆。

#+BEGIN_SRC emacs-lisp
  (setq ac-use-fuzzy t)
#+END_SRC

** 不自動啟用自動補全

預設的 auto-complete-mode 會自動啟動自動補全的選單，這邊將他關掉，當我用
按鍵觸發時再彈出來。

#+begin_src emacs-lisp
  (setq ac-auto-start nil)
#+end_src

** 全域性使用自動補全

global-auto-complete-mode 這個 function 只具有切換全部 buffer 的自動補全功能，
若想要一開始就全部的 mode 都具有自動補全能力，則必須用個 dirty hack 才行。

#+begin_src emacs-lisp
  (define-globalized-minor-mode real-global-auto-complete-mode
    auto-complete-mode (lambda ()
                         (if (not (minibufferp (current-buffer)))
                             (auto-complete-mode 1))
                         ))
  (real-global-auto-complete-mode t)
  (global-auto-complete-mode t)
#+end_src
** 啟用 ac-comphist 存放補全的歷史紀錄

啟用這項設定，auto-complete 會存放一些常用的資訊到自動補全記錄下。

#+BEGIN_SRC emacs-lisp
  (setq ac-use-comphist t)
#+END_SRC

auto-complete-mode 會產生一個名為 =auto-complete.dat= 的檔案來存放自動
補全的歷史紀錄，預設這個檔案會在 =~/.emacs.d/auto-complete.dat= 下面，
我不喜歡這樣，所以移到 =~/.emacs.d/cache/auto-complete.dat=

#+BEGIN_SRC emacs-lisp
  (setq ac-comphist-file "~/.emacs.d/cache/auto-complete.dat")
#+END_SRC

** 加入我自定義的補全字典

auto-complete-mode 本身已經包含一些常用的字典了，這邊加上我自己會用到
的字典。

#+begin_src emacs-lisp
  (add-to-list 'ac-dictionary-directories (concat emacs-dir "ac-dict"))
#+end_src

** 自動補全時候忽略大小寫

#+BEGIN_SRC emacs-lisp
  (setq ac-ignore-case nil)
#+END_SRC

** 顯示幫助選單

#+BEGIN_SRC emacs-lisp
  (setq ac-use-quick-help t)
#+END_SRC
** 允許設定選單彈出時的按鍵

在按鍵設定中，由於我想要可以設定選單彈出時的按鍵，因此要打開以下選項

#+BEGIN_SRC emacs-lisp
  (setq ac-use-menu-map t)
#+END_SRC

** 按鍵設定

#+TBLNAME: ac-keys
| map           | 按鍵  | 命令        | 描述           |
|---------------+-------+-------------+----------------|
| ac-menu       | C-n   | ac-next     | 下一個補全     |
| ac-menu       | C-p   | ac-previous | 上一個補全     |
| ac-completing | \"t\" | ac-complete | 選擇該補全設定 |

#+BEGIN_SRC emacs-lisp :noweb yes
  <<gen-keys-map(func="define-key", keys=ac-keys)>>
#+END_SRC

* 自動補全 (Company)                                                :company:

company-mode 是一個非常強大的補全程式，在 auto-complete-mode 出來之前，他
應該是最多人使用的。

GitHub: https://github.com/company-mode/company-mode

#+BEGIN_SRC emacs-lisp
  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

** 按鍵設定

#+TBLNAME: company-keys
| 按鍵  | 命令                       | 描述              |
|-------+----------------------------+-------------------|
| C-g   | company-abort              | 離開 company-mode |
| C-n   | company-select-next        | 下一個補全        |
| C-p   | company-select-previous    | 上一個補全        |
| TAB   | company-complete-selection | 選擇該補全設定    |
| <tab> | company-complete-selection | 選擇該補全設定    |

#+BEGIN_SRC emacs-lisp :noweb yes
  <<gen-keys-map2(map="company-active", keys=company-keys)>>
#+END_SRC

* 終端機                                                               :term:

emacs 本身內建了 term-mode、shell-mode 這類可以讓人在 emacs 當中使用終端機
功能的模式。

** 基本設定

term-mode 是 emacs 終端機最基本的 mode (自 emacs 24 之後開始可用 shell-mode
來替代 term-mode)，但是我用於串口通訊的 serial-term 仍舊是以 term-mode
為基礎，基於習慣，這邊會設置基本的 term-mode 配置。

#+begin_src emacs-lisp
  (require 'term)
  (require 'ansi-color)
#+end_src

*** 移除 term-mode 預設的前景與背景顏色。

我希望 term-mode 可以和我的 emacs 更完整結合，所以移除掉他的預設文字顏色以
及背景顏色，這樣會比較好看。

#+begin_src emacs-lisp
  (setq term-default-bg-color nil)
  (setq term-default-fg-color nil)
#+end_src

*** 修正與 yasnippet 相衝的問題

term-mode 似乎會和 yasnippet 的 TAB 按鍵相衝，使用這個設定讓 yasnippet 不
執行在 term-mode 中。

#+begin_src emacs-lisp
  (eval-after-load 'yasnippet
    (add-hook 'term-mode-hook (lambda() (yas-minor-mode -1))))
#+end_src

** multi-term 讓你方便管理多個 terminal 緩衝區

EmacsWiki: http://www.emacswiki.org/emacs//multi-term.el

#+BEGIN_SRC emacs-lisp
  (require 'multi-term)
#+END_SRC

*** 使用 bash 作為預設的 shell

#+begin_src emacs-lisp
  (setq multi-term-program "/bin/bash")
#+end_src
** shell-pop 彈出式終端

GitHub: https://github.com/kyagi/shell-pop-el

#+BEGIN_SRC emacs-lisp
  (require 'shell-pop)
#+END_SRC

** 設定預設的 shell 為 eshell
#+BEGIN_SRC emacs-lisp
  (setq shell-pop-term-shell "/bin/bash")
#+END_SRC

** 終端機類型設定為 ansi-term

#+BEGIN_SRC emacs-lisp
  (setq shell-pop-shell-type '("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell))))
#+END_SRC

** 設定 shell-pop 保持在最下面視窗

#+BEGIN_SRC emacs-lisp
(setq shell-pop-window-position "bottom")
#+END_SRC

** 當 emacs 有許多視窗時，讓 shell-pop 維持在最下面的視窗並最大化

#+BEGIN_SRC emacs-lisp
  (setq shell-pop-full-span t)
#+END_SRC

* eshell                                                             :eshell:

eshell 是 emacs 下一個非常特殊的終端機 (terminal) 模擬軟體，和一般的
xterm、konsole、gnome terminal 相比，eshell 完全使用 emacs-lisp 實現，
因此可以非常完整的和 emacs 結合。

#+BEGIN_SRC emacs-lisp
  (require 'eshell)
#+END_SRC

** 設定預設的 eshell 資料夾位置

eshell-directory-name 設定了 eshell 的資料夾，裡面可能存放一些和
eshell 相關的資訊。

#+BEGIN_SRC emacs-lisp
  (setq eshell-directory-name (concat emacs-cache-dir "eshell"))
#+END_SRC

** 將 eshell prompt 設定成 bash 預設的模式，並加上顏色

- 將 eshell 的 prompt 設定成和 bash 一樣

  下面這一組 emacs-lisp 可以讓你的 eshell prompt 設定的和 bash 相同，變成 =user@hostname directory $= 的形式。

  #+begin_src emacs-lisp
    (setq eshell-prompt-function
          '(lambda ()
             (concat
              user-login-name "@" system-name " "
              (if (search (directory-file-name (expand-file-name (getenv "HOME"))) (eshell/pwd))
                  (replace-regexp-in-string (expand-file-name (getenv "HOME")) "~" (eshell/pwd))
                (eshell/pwd))
              (if (= (user-uid) 0) " # " " $ "))))
  #+end_src

- 替 eshell 的 prompt 上色

  我不喜歡原本 eshell 那樣單一的顏色，用 Gentoo 系統預設的上色方式還比較好看 :)

  #+begin_src emacs-lisp
    (defun colorfy-eshell-prompt ()
      (let* ((mpoint)
             (user-string-regexp (concat "^" user-login-name "@" system-name)))
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward (concat user-string-regexp ".*[$#]") (point-max) t)
            (setq mpoint (point))
            (overlay-put (make-overlay (point-at-bol) mpoint) 'face '(:foreground "dodger blue")))
          (goto-char (point-min))
          (while (re-search-forward user-string-regexp (point-max) t)
            (setq mpoint (point))
            (overlay-put (make-overlay (point-at-bol) mpoint) 'face '(:foreground "green3"))
            ))))

    ;; Make eshell prompt more colorful
    (add-hook 'eshell-output-filter-functions 'colorfy-eshell-prompt)
  #+end_src

** 使用 eshell-autojump 快速跳轉資料夾

[[http://www.emacswiki.org/emacs/EshellAutojump][Eshell Autojump]] 提供了一個 =j= 的 eshell 命令，他會根據你之前使用 cd 切
換資料夾的紀錄，透過 regexp 的方式來批配你要切換的資料夾，舉例來說，
若我曾經在 eshell 裡面切換到 ~/.emacs.d 過，則只要使用

: j emacs

就可以在 emacs 中切換到 ~/.emacs.d 中了。

你可以使用

: cd =

來查看目前在列表中的資料夾有哪些

Site: http://www.emacswiki.org/emacs/EshellAutojump

#+BEGIN_SRC emacs-lisp
  (require 'eshell-autojump)
#+END_SRC
** 使用 multi-eshell 快速切換不同的 eshell

#+BEGIN_SRC emacs-lisp
  (require 'multi-eshell)
  (setq multi-eshell-shell-function '(eshell))
  (setq multi-eshell-name "*eshell*")
#+END_SRC

** eshell 命令 :: emacs

如果在 eshell 中呼叫 emacs 命令，實際上還是會打開另外一個 emacs 程式，
因此在這邊重弄 emacs 命令，這樣就可以很安心的在 eshell 中用 emacs 打開
檔案到緩衝區裏面。

#+begin_src emacs-lisp
  (defun eshell/emacs (&rest args)
    "Open a file in emacs. Some habits die hard."
    (if (null args)
        ;; If I just ran "emacs", I probably expect to be launching
        ;; Emacs, which is rather silly since I'm already in Emacs.
        ;; So just pretend to do what I ask.
        (bury-buffer)
      ;; We have to expand the file names or else naming a directory in an
      ;; argument causes later arguments to be looked for in that directory,
      ;; not the starting directory
      (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))

  (defalias 'eshell/e 'eshell/emacs)
#+end_src

** eshell 命令 :: clear

這個命令的作用和 Unix 下的 clear 功用相同，都是用來清空 shell 的內容。

#+begin_src emacs-lisp
  (defun eshell/clear ()
    "Clears the shell buffer ala Unix's clear or DOS' cls"
    ;; the shell prompts are read-only, so clear that for the duration
    (let ((inhibit-read-only t))
      ;; simply delete the region
      (delete-region (point-min) (point-max))))
#+end_src

* 窗口管理                                                           :window:

針對 emacs 視窗大小的設定，以及彈出視窗等設置。

** emacs 啟動後自動將視窗最大化

以前我曾經依據螢幕的解析度來調整視窗大小，仔細檢視過後，我發現最後我都
還是會將 emacs 視窗對大化，因此還是直接將視窗放到最大比較好。

#+BEGIN_SRC emacs-lisp
  (modify-all-frames-parameters '((fullscreen . maximized)))
#+END_SRC

** 使用 winner-mode 快速切換窗口佈局

winner-mode 是 emacs 自帶的窗口佈局管理器，可以對窗口的改變進行
undo/redo 的動作。

#+BEGIN_SRC emacs-lisp
  (require 'winner)
#+END_SRC

*** 不使用 winner 預設的按鍵

winner-mode 有自己預設好的按鍵方式，我習慣用自己的，因此取消掉他預設的
按鍵模式。

#+begin_src emacs-lisp
  (setq winner-dont-bind-my-keys t)
#+end_src

*** 全域啟用 winner-mode

讓 emacs 啟動後立刻打開 winner-mode，方便進行視窗管理。

#+begin_src emacs-lisp
  (winner-mode t)
#+end_src

** 使用 e2wm 進行窗口管理

GitHub: https://github.com/kiwanami/emacs-window-manager

#+BEGIN_SRC emacs-lisp
  (require 'e2wm)
#+END_SRC
** 使用 popwin 自動關閉彈出視窗

popwin is a popup window manager for Emacs which makes you free from
the hell of annoying buffers such like *Help*, *Completions*,
*compilation*, and etc. Take an example. When you complete file names
during find-file, the (annoying) *Completions* buffer will appear in a
newly splitted window. You might understand the necessity of the
window, but you may wonder why the window still remains after
completion... popwin resolves there problems. Windows of such
temporary buffers will be shown as a popup window, and you can close
them smoothly by typing C-g in anytime.

#+BEGIN_SRC emacs-lisp
  (require 'popwin)
  (setq display-buffer-function 'popwin:display-buffer)
#+END_SRC
* 文件加密                                                          :encrypt:

對於一些和隱私比較相關的文件，總是希望可以加密起來，讓自己可以更加放心。

在 emacs 中，提供了 [[http://www.emacswiki.org/emacs/EasyPG][Easy PG]] 來協助你加密存文字檔案，你只要很簡單的將你的
檔案副檔名再加上 *.gpg* ，這樣 emacs 就會向你詢問加密用的密碼。

#+BEGIN_SRC emacs-lisp
  (require 'epa-file)
#+END_SRC

** 使用自己設定的密碼加密文件

 這個變數用來控制 是否彈出選擇密碼類型的視窗 ，他的說明如下

#+BEGIN_EXAMPLE
  If t, always asks user to select recipients.
  If nil, query user only when `epa-file-encrypt-to' is not set.
  If neither t nor nil, doesn't ask user.  In this case, symmetric
  encryption is used.
#+END_EXAMPLE

也就是說，如果我們想要加密文件時，使用自己設置的密碼，就將其值設為不是
t 與 nil 的其他值就好，我的設定如下。

#+BEGIN_SRC emacs-lisp
  ;; Control whether or not to pop up the key selection dialog.
  (setq epa-file-select-keys 0)
#+END_SRC

這樣當你把文件的副檔名加上 .gpg 以後，emacs 會直接要求你輸入密碼，而不是再彈出一個選單來煩你。

** 使用快取來儲存密碼

emacs 預設不會快取你的密碼，也因此每次儲存文件都時候，他都會再來詢問一
次你的密碼，打開這個變數之後，emacs 就不會一直來詢問你密碼這一回事。

使用快取是否會有危險呢？其實不會，emacs 只會在目前的 session 記住這個密
碼，你開一個新的 emacs 再來打開這個文件，emacs 還是會要你再輸入一次密碼
的。

#+BEGIN_SRC emacs-lisp
  ;; Cache passphrase for symmetric encryption.
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)
#+END_SRC

* 書籤與暫存器                                                     :bookmark:

| 快捷鍵  | 命令                | 用途                                        |
|---------+---------------------+---------------------------------------------|
| C-x r m | bookmark-set        | 設置新的書籤                                |
| C-x r l | bookmark-bmenu-list | 列出所有已設置的書籤                        |
| C-x r b | bookmarj-jump       | 跳轉到書籤                                  |
|         | bookmark-delete     | 刪除書籤                                    |
|         | bookmark-load       | 讀取已儲存的書籤檔案                        |
|         | bookmark-save       | 儲存書籤至 bookmark-default-file 指定的地方 |

** 快速跳轉到檔案                                                 :register:

使用 Ctrl-x r j <char> 就可以進行快速跳轉至檔案，其中 <char> 為以下所設定。

#+begin_src emacs-lisp
  (dolist
      (r `(
           ;; emacs's config.org
           (?e (file . "~/.emacs.d/config.org"))
           ;; Offilce
           (?w (file . "~/Copy/org/Weintek.org"))
           ;; Note.org
           (?n (file . "~/Copy/org/Note.org"))))
    (set-register (car r) (cadr r)))
#+end_src

* 專案管理                                                          :project:

emacs 下有太多太多跟專案管理相關的套件了，目前先一一試用，再來
決定我要用什麼

** projectile

Site: http://batsov.com/projectile/

#+begin_src emacs-lisp
  (require 'projectile)
  ;; Globally enable projectile
;;  (projectile-global-mode)
#+end_src
* Eclim                                                               :eclim:

eclim 是在 emacs 下可以控制 Eclipse 或是透過他來進行 JAVA 等補全的工具

GitHub:

#+BEGIN_SRC emacs-lisp
  (require 'eclim)
  (require 'eclimd)
  (global-eclim-mode)
#+END_SRC

** 設定 Eclipse 以及 eclim 的位置

在一些特定的 OS 中，我可能把 eclipse 或是 eclim 置放在不同的地方，這邊針對這
種情況進行額外的設定。

#+BEGIN_SRC emacs-lisp
  (when mac-p
    (setq eclim-eclipse-dirs "/opt/homebrew-cask/Caskroom/eclipse-ide/4.3.2/eclipse/")
    (setq eclim-executable (concat eclim-eclipse-dirs "/eclim")))
#+END_SRC

** 讓 eclim 可以進行自動儲存

#+BEGIN_SRC emacs-lisp
;;  (setq eclim-auto-save t)
#+END_SRC

* ECB                                                                   :ecb:

#+begin_src emacs-lisp
  (require 'ecb)
#+end_src

** 不要顯示 tips-of-the-day，感覺很煩人

#+begin_src emacs-lisp
  (setq ecb-tip-of-the-day nil)
#+end_src

** 不要自動檢查版本是否相容，很煩人...

#+begin_src emacs-lisp
  (setq ecb-auto-compatibility-check nil)
#+end_src

* TAGS                                                                 :tags:

這邊放置和 tags 相關的功能

** 自動更新 TAGS

ctags-update 這個擴展會自動幫你更新目前的 TAGS, 這邊我打開 ctags-update-minor-mode,
這樣任何模式下，若我有 TAGS 檔案的話，他都會自動幫我更新。

我並沒有為他增加其他配置，因此預設為 5 分鐘更新一次 TAGS。

#+begin_src emacs-lisp
  (require 'ctags-update)
#+end_src

很令人討厭的一件事情是, helm-etags-plus 的作者有包了另外一個
ctags-update.el 檔案，所以如果載入順序出錯的話，會和另外一個同名的
ctags-update.el 衝突到，我這邊使用獨立的 ctags-update.el，當他不存在在使
用 helm-etags-plus 裡面附贈的 ctags-update.el。

#+BEGIN_SRC emacs-lisp
  ;; Use ctags-update function in ctags-update.el
  (if (fboundp 'ctags-auto-update-mode)
      (ctags-auto-update-mode 1)
    ;; if the function does not exist, use the ctags-update
    ;; in helm-etags-plus packages.
    (if (fboundp 'ctags-update-minor-mode)
        (ctags-update-minor-mode 1)))
#+END_SRC

** 用來產生 TAGS 的命令                                            :command:

我使用 TAGS 最多的地方應該就是 kernel code 以及 Linux 下的 C code 了，
由於 kernel code 可以用

: make TAGS

來產生 TAGS 檔案，因此此命令只是添加在這邊，若我有需要的話直接呼叫就可以很方便
的做出一個新的 TAGS 檔案。

#+begin_src emacs-lisp
  (defun create-tags ()
    "Create TAGS file in current directory."
    (interactive)
    (let ((dir (read-from-minibuffer "generate tags in: "
                                     (file-name-directory (or (buffer-file-name)
                                         default-directory))))
            (exp (read-from-minibuffer "suffix: ")))
      ;; if suffix is null, take it as c language
      (if (string-equal "" exp) (setq exp "*.[ch]"))
      (with-temp-buffer
        (shell-command
         (concat "find " dir " -name \"" exp "\" | xargs etags ")
         (buffer-name)))))
#+end_src

** 用來產生 GTAGS 的命令                                           :command:

#+begin_src emacs-lisp
  (defun create-gtags ()
    "create or update the gnu global tag file"
    (interactive)
    (if (not (= 0 (call-process "global" nil nil nil " -p")))
        ;; tagfile doesn't exist?
        (let ((olddir default-directory)
              (topdir (read-directory-name
                       "gtags: top of source tree:" default-directory)))
          (cd topdir)
          (message "Creating tags table...")
          (shell-command "gtags")
          (message "Creating tags table... Done")
          (cd olddir)) ;; restore
      ;; tagfile already exists; update it
      (message "Updating tags table...")
      (shell-command "global -u")
      (message "Updating tags table... Done")))
#+end_src

* Cscope                                                             :cscope:

#+BEGIN_SRC emacs-lisp
  (require 'xcscope)
  (cscope-setup)
#+END_SRC

** 設定 cscope 不要自動更新索引

#+BEGIN_SRC emacs-lisp
  (setq cscope-do-not-update-database t)
#+END_SRC

** 使用 Global 替代原本的 cscope

#+BEGIN_SRC emacs-lisp
  (setq cscope-program "gtags-cscope")
#+END_SRC

* Cedet                                                               :cedet:

#+BEGIN_SRC emacs-lisp
  (require 'semantic)
  (semantic-mode 1)
#+END_SRC

** 設定 semantic database 存放位置

#+BEGIN_SRC emacs-lisp
  (setq semanticdb-default-save-directory (concat emacs-cache-dir "semanticdb"))
#+END_SRC

* GDB                                                                   :gdb:

Emacs 本身有內建 GDB 的支援，在這邊主要我使用 realgud 這個重製版的 GDB 套件

GitHub: https://github.com/rocky/emacs-dbgr

#+BEGIN_SRC emacs-lisp
  (require 'realgud)
#+END_SRC

* 編輯器                                                             :editor:

** 基本編輯器設定

- 設定 TAB 的寬度為 8

  #+begin_src emacs-lisp
    (setq tab-width 8)
  #+end_src

- 不使用 TAB 進行縮排

  #+begin_src emacs-lisp
     (setq indent-tabs-mode nil)
  #+end_src
- 設定每行之間的間格為 4

  #+begin_src emacs-lisp
    (setq line-spacing 4)
  #+end_src

- 在檔案的最後一行加入一空白行

  #+begin_src emacs-lisp
    (setq require-final-newline t)
  #+end_src

- 全域使用色彩上色

  #+begin_src emacs-lisp
    (global-font-lock-mode t)
  #+end_src

- 高亮匹配的括號

  #+begin_src emacs-lisp
    (show-paren-mode t)
  #+end_src

** 建立編輯器的全域性 minor-mode

我希望能夠全域性的使用我所定義的編輯器，因此宣告一個 minor-mode，
並讓他可以直接啟用。

#+begin_src emacs-lisp
  (defvar coldnew-editor-map (make-keymap))

  (define-minor-mode coldnew-editor-mode
    "coldnew's editor minor mode."
    :init-value t
    :keymap coldnew-editor-map)

  (define-globalized-minor-mode global-coldnew-editor-mode
    coldnew-editor-mode (lambda ()
                          (if (not (minibufferp (current-buffer)))
                              (coldnew-editor-mode 1))))

  ;; Gloabal enable
  (global-coldnew-editor-mode t)
#+end_src

** 存檔前要執行的額外設定

*** 清除多餘的空白

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** 將 TAB 轉換為空格

#+BEGIN_SRC emacs-lisp
  ;; no tabs by default. modes that really need tabs should enable
  ;; indent-tabs-mode explicitly. makefile-mode already does that, for
  ;; example.
  (setq-default indent-tabs-mode nil)

  ;; if indent-tabs-mode is off, untabify before saving
  (add-hook 'before-save-hook
            (lambda () (if (not indent-tabs-mode)
                           (untabify (point-min) (point-max)))
              nil ))
#+END_SRC
** 自動回復檔案

當檔案被別的編輯器修改的時候，自動套用新的檔案到緩衝區上。

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq revert-without-query '(".*")) ;; disable revert query
#+end_src

** 允許文件使用特定的區域變數

有些時候我會在一些特定的文件使用區域變數，可是 emacs 就會跑過來問我說:
這個變數很危險，是否要啟用？ 這個功能真是麻煩，於是我決定將我會啟用的
變數資訊加入到 =safe-local-variable-values= 並且修改
=enable-local-variables= 的資訊，這樣以後 emacs 就不會再問我同樣的問題
了。

#+BEGIN_SRC emacs-lisp
  (setq enable-local-variables :safe)
  (setq safe-local-variable-values
        '((org-export-latex-title-command . "")))
#+END_SRC
** 替 FIXME 等關鍵字上色

很多時候我們會再程式碼裏面加上了 FIXME: 等字樣，這邊額外定義我需要高亮的文字。

我設定了對以下關鍵字上色

FIXME: BUG: HACK:
NOTE: TODO: DONE:

#+begin_src emacs-lisp
  (defun font-lock-comment-annotations ()
    "Highlight a bunch of well known comment annotations.
  This functions should be added to the hooks of major modes for programming."
    (font-lock-add-keywords
     nil
     '(("\\<\\(FIX\\(ME\\)?\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)
       ("\\<\\(NOTE\\):" 1 'org-level-2 t)
       ("\\<\\(TODO\\):" 1 'org-todo t)
       ("\\<\\(DONE\\):" 1 'org-done t))
     ))

  (add-hook 'prog-mode-hook 'font-lock-comment-annotations)
#+end_src

** 替逸脫字元上色 (escape char)

很多語言都有逸脫字元(escape char), 並且語法都是類似 c 語言那樣，這邊也將
這些字元進行上色。

#+begin_src emacs-lisp
  (defun font-lock-escape-char ()
    "Highlight for escape-char
    This functions should be added to the hooks of major modes for programming."
    (font-lock-add-keywords
     nil
     '(("\\\\\\(?:[abfnrtv'\"?\\0]\\|x[a-fA-F]\\{2\\}\\|[0-7]\\{3\\}\\)"
        0 '(:foreground "seagreen2") prepend))))

  (add-hook 'prog-mode-hook 'font-lock-escape-char)
#+end_src

** 行號顯示設定

在大多數的情況下，我會希望行號是可以顯示的

#+begin_src emacs-lisp
  (global-linum-mode 1)
#+end_src

設定某些 mode 不顯示行號

#+BEGIN_SRC emacs-lisp
  (require 'linum-off)
  (setq linum-disabled-mode-list
               '(eshell-mode shell-mode term-mode erc-mode compilation-mode
                 woman-mode w3m-mode calendar-mode org-mode
                 ))
#+END_SRC

** 自動將 lambda 顯示成符號

在 Lisp 程式下，我們很習慣將 lambda 顯示成希臘符號的 λ，由於現在越來越
多語言也開始引進 lambda 表示式，這邊使用 emacs 24.4 內建的功能來進行
lambda -> λ 的顯示。

#+BEGIN_SRC emacs-lisp
  (when (and (>= emacs-major-version 24) (>= emacs-minor-version 4))
    (global-prettify-symbols-mode 1))
#+END_SRC

** 對每一個括號進行上色

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

** 存檔後自動建立資料夾

當存檔的時候，如果這個緩衝區的父資料夾不存在，自動建立他。
#+begin_src emacs-lisp
  (add-hook 'before-save-hook
            (lambda ()
              (when buffer-file-name
                (let ((dir (file-name-directory buffer-file-name)))
                  (when (and (not (file-exists-p dir))
                             (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                    (make-directory dir t))))))
#+end_src

* 狀態欄                                                           :modeline:

GitHub: https://github.com/milkypostman/powerline

#+BEGIN_SRC emacs-lisp
  (require 'powerline)
  (require 'powerline-coldnew-theme)
  (powerline-coldnew-theme)
#+END_SRC

* 程式開發                                                         :language:

各種不同程式語言開發用的設定。

** Android                                                          :android:
#+begin_src emacs-lisp
  (require 'android-mode)

  ;; Set my android-emulator-path
  (when mac-p
    (setq android-mode-sdk-dir "~/Workspace/Android/android-sdks/"))

  (when linux-p
    (setq android-mode-sdk-dir "/opt/android-sdk-update-manager/"))
#+end_src

** CMake

#+begin_src emacs-lisp
  (require 'cmake-mode)
  (add-to-list 'auto-mode-alist '("\\.cmake\\'" . cmake-mode))
  (add-to-list 'auto-mode-alist '("CMakeLists\\.txt\\'" . cmake-mode))
#+end_src

** Rust

Rust 是由 Mozilla 所開發的語言。

#+BEGIN_SRC emacs-lisp
  (require 'rust-mode)
#+END_SRC

** Go

#+begin_src emacs-lisp
(require 'go-mode)
  (add-to-list 'auto-mode-alist '("\\.go$" . go-mode))
#+end_src

*** 儲存檔案的時候，使用 gofmt 進行格式化

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

** qmake

#+begin_src emacs-lisp
  (require 'qmake-mode)
  (add-to-list 'auto-mode-alist '("\\.pro$" . qmake-mode))
#+end_src

** Markdown

#+begin_src emacs-lisp
  (require 'markdown-mode)
  (add-to-list 'auto-mode-alist '("\\.\\(md\\|markdown\\)\\'" . markdown-mode))
#+end_src

** Clojure

#+BEGIN_SRC emacs-lisp
  (require 'clojure-mode)
  (require 'cider)
#+END_SRC

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))
  (add-to-list 'auto-mode-alist '("\\.cljs$" . clojure-mode))
#+end_src

** Python

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.py" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))
#+end_src

*** TODO 使用 elpy 增強 emacs 編輯 python 的能力

  [[https://github.com/jorgenschaefer/elpy][elpy]] 是一個用來增強 python 編輯能力的套件，使用這個套件之前必須先安裝
  elpy 與 rope 的 python 套件。

  : pip install elpy rope

  接著在 *scratch* 緩衝區對以下程式進行求值(eval)

  #+begin_src emacs-lisp :tangle no
    (add-to-list 'package-archives
                 '("marmalade" . "http://marmalade-repo.org/packages/"))
  #+end_src

  接著執行 M-x package-refresh-contents 來載入新的套件資訊，並安裝 elpy。

  : package-install elpy

  最後，在 .emacs 裏面加上下面兩行

  #+begin_src emacs-lisp :tnagle no
    (package-initialize)
  #+end_src

  #+begin_src emacs-lisp :tangle no
    (when (require 'elpy nil 'noerror)
      (elpy-enable))
  #+end_src

** C/C++ 通用設定

C/C++ 語言基本上很多設定都沒有差，因此將通用的設定寫在這邊。

*** 將 #if 0 #endif 區域上色為灰色

emacs 預設不會將 #if 0 到 #endif 之間的區域用其他顏色隔開，這邊將這種類型的
code 變成灰色，這樣在看 code 時比較不會吃力。

#+begin_src emacs-lisp
  (defun cc-mode:highlight-if-0 ()
    "highlight c/c++ #if 0 #endif macros"
    (interactive)
    (setq cpp-known-face 'default)
    (setq cpp-unknown-face 'default)
    (setq cpp-known-writable 't)
    (setq cpp-unknown-writable 't)
    (setq cpp-edit-list '(("0" '(foreground-color . "gray")  default both)
                          ("1" default font-lock-comment-face both)))
    (cpp-highlight-buffer t))

  ;; Add to c/c++ mode
  (add-hook 'c-mode-common-hook 'cc-mode:highlight-if-0)
#+end_src

*** 加入 eldoc 支援

#+begin_src emacs-lisp
  (require 'c-eldoc)
  (add-hook 'c-mode-common-hook
            '(lambda ()
               (setq c-eldoc-includes "`pkg-config gtk+-3.0 --cflags --libs` -I./ -I../")
               (c-turn-on-eldoc-mode)))
#+end_src

*** 使用 cwarn-mode 顯示可能有問題的代碼

cwarn-mode 會顯示出 C/++ 下面一些致命的錯誤，以下面的程式碼來說

#+begin_src c :tangle no
  void test ()
  {
          if (x = y);
                 printf("This is error example\n");
  }
#+end_src

這段程式碼包含了兩種致命的錯誤。第一個是 *=* 只有在指派變數的值時才會
使用到，而不會存在於判斷式裏面，這邊應該要修改成 *==* 。

另外一個問題是，這邊多添加了不必要的分號在 if 判斷式的尾巴，這會讓 if
判斷式出錯，拿掉就沒問題了。

簡單的來說，cwarn-mode 包含以下幾種語法檢查:

  - Semicolons right after conditions and loops

    #+BEGIN_SRC c :tangle no
      if (x == y);
    #+END_SRC

  - Assignments in tests

    #+BEGIN_SRC c :tangle no
      void test() {
              if (a = b) foo();
      }
    #+END_SRC

  - Functions with reference parameters

    #+begin_src c++ :tangle no
      void funct(string &p) {
    #+end_src

這邊將 cwarn-mode 加入到 c-mode-common-hook 裏面。

#+begin_src emacs-lisp
  (require 'cwarn)
  (add-hook 'c-mode-common-hook '(lambda () (cwarn-mode 1)))
#+end_src

*** 使用 ctypes 高亮 C/C++ 自行定義的 typedef

ctypes 這個套件可以識別 C/C++ 裏面的 typdef 定義，自動對他們進行語法高
亮。

#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook
            '(lambda ()
               (when (require 'ctypes nil 'noerror)
                 (ctypes-auto-parse-mode 1))))
#+end_src

*** 使用 dtrt-indent 自動猜測 coding style

GitHub: https://github.com/jscheid/dtrt-indent

#+BEGIN_SRC emacs-lisp
  (require 'dtrt-indent)
  (add-hook 'c-mode-common-hook
            (lambda()
              (dtrt-indent-mode t)))
#+END_SRC

** C

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.c$" . c-mode))
  (add-to-list 'auto-mode-alist '("\\.h$" . c-mode))
#+end_src


*** 預設使用 Linux Coding Style

#+begin_src emacs-lisp
  (add-hook 'c-mode-hook '(lambda () (c-set-style "linux")))
#+end_src

*** 進行多行註解時，多產生一行註解

預設的 emacs 會將一個區域變成如下的註解形式

#+BEGIN_SRC c :tangle no
  /*
   ,* int test_func()
   ,* {
   ,*      int i = 0;
   ,*      printf("i is  %d", i);
   ,* } */
#+END_SRC

如果我希望將其變成如下，則要將 =comment-style= 設定成 =extra-line=

#+BEGIN_SRC c :tangle no
  /*
   ,* int test_func()
   ,* {
   ,*      int i = 0;
   ,*      printf("i is  %d", i);
   ,* }
   */
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-hook '(lambda ()
                            (setq comment-style 'extra-line)))
#+END_SRC

*** 快速插入樣板

#+BEGIN_SRC emacs-lisp
  (setq c-mode-expand-alist
        '(("m" . "main")
          ))
#+END_SRC
** C++

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.hpp$" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.cpp$" . c++-mode))
#+END_SRC

*** 透過正規表達式判斷 .h 檔案是否為 C++ 檔案

大部分的 C++ 的標頭黨使用 include 的時候，並不會將副檔名(.h)包進去，此外，很
多 C++ 標頭亦會使用 std:: 以及 namespace 等字樣，可以用這些作為是否為
C++檔案的依據。

#+BEGIN_SRC emacs-lisp
  (add-to-list 'magic-mode-alist
               `(,(lambda ()
                    (and (string= (file-name-extension (or (buffer-file-name) "")) "h")
                         (or (re-search-forward "#include <\\w+>"
                                                magic-mode-regexp-match-limit t)
                             (re-search-forward "\\W\\(class\\|template\\namespace\\)\\W"
                                                magic-mode-regexp-match-limit t)
                             (re-search-forward "std::"
                                                magic-mode-regexp-match-limit t))))
                 . c++-mode))

#+END_SRC

*** 預設使用 Google Coding Style

#+BEGIN_SRC emacs-lisp
  (require 'google-c-style)
  (add-hook 'cpp-mode-hook 'google-c-style)
#+END_SRC

** newlisp

#+begin_src emacs-lisp
   (require 'newlisp)
    (add-to-list 'auto-mode-alist '("\\.lsp$" . newlisp-mode))
#+end_src

** Graphviz

#+BEGIN_SRC emacs-lisp
  (require 'graphviz-dot-mode)
  (defalias 'dot-mode 'graphviz-dot-mode)
#+END_SRC
** javascript

使用 js2-mode 替代原本系統內建的 js-mode。
#+begin_src emacs-lisp
  (require 'js2-mode)
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src

** QML

#+BEGIN_SRC emacs-lisp
  (require 'qml-mode)
  (add-to-list 'auto-mode-alist '("\\.qml$" . qml-mode))
#+END_SRC

** Vala

#+BEGIN_SRC emacs-lisp
  (require 'vala-mode)
  (add-to-list 'auto-mode-alist '("\\.vala$" . vala-mode))
#+END_SRC

** Emacs Lisp

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.el$" . emacs-lisp-mode))
  (add-to-list 'auto-mode-alist '("Cask" . emacs-lisp-mode))
#+end_src

*** 使用 eldoc 顯示目前所使用的函式宣告在 minibuffer 上面

eldoc 能夠將目前所使用的 elisp function 所需要的 argument 顯示在
minibuffer 上。

#+begin_src emacs-lisp
  (require 'eldoc)
  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               ;; enable eldoc
               (turn-on-eldoc-mode)
               ;; fix for paredit if exist
               (eval-after-load 'paredit
                 '(progn
                    (eldoc-add-command 'paredit-backward-delete
                                       'paredit-close-round)))))
#+end_src

*** 高亮屬於 cl.el 套件的 function 或是 macro

#+begin_src emacs-lisp
  (require 'highlight-cl)
  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               (highlight-cl-add-font-lock-keywords)))
#+end_src
** bitbake

#+BEGIN_SRC emacs-lisp
  (require 'bitbake)
#+END_SRC

** Lisp 通用設定

* 網頁開發                                                              :web:

** 網頁開發基本設定
*** 讓 emacs 能與 firefox 溝通

在讓 emacs 和 firefox 能互相溝通之前，兩邊都必須先裝上 moz-repl 這個外掛。
可以在 firefox 上的 moz-repl 選單，選擇 Active on startup 來確保當 firefox
啟動時會同時啟動 moz-repl

#+begin_src emacs-lisp
  (require 'moz)
#+end_src

*** 令 firefox 更新目前的頁面

#+begin_src emacs-lisp
  (defun firefox-refresh ()
    "Refresh the firefox browser"
    (interactive)
    (comint-send-string (inferior-moz-process)
                        "BrowserReload();"))
#+end_src

*** web-mode

URL: http://web-mode.org/
GitHub: https://github.com/fxbois/web-mode

#+BEGIN_SRC emacs-lisp
  (require 'web-mode)
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[gj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
#+END_SRC


** Less-CSS

#+BEGIN_SRC emacs-lisp
  (require 'less-css-mode)
  (add-to-list 'auto-mode-alist '("\\.less$" . less-css-mode))
#+END_SRC

** SCSS

#+BEGIN_SRC emacs-lisp
  (require 'scss-mode)
  (add-to-list 'auto-mode-alist '("\\.scss$" . scss-mode))
#+END_SRC

scss-mode 預設會在檔案儲存的時候自動編譯 scss 檔成為 css 檔，這邊關掉這項
設定。

#+BEGIN_SRC emacs-lisp
  (setq scss-compile-at-save nil)
#+END_SRC

** CSS

#+begin_src emacs-lisp
  (require 'css-mode)
  (add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
#+end_src

** HTML
*** 使用 zencoding-mode 讓寫 HTML 更方便

#+begin_src emacs-lisp
  (require 'zencoding-mode)
  (add-hook 'html-mode-hook 'zencoding-mode)
#+end_src

* 版本管理                                                               :vc:

#+BEGIN_SRC emacs-lisp
  ;; follow symlinks and don't ask
  (setq vc-follow-symlinks t)
#+END_SRC

** Git                                                                 :git:

git 是我最喜歡用的版本管理器，當然能夠在 emacs 下使用是最好的，emacs
有許多好用的 git 套件，諸如 egg, magit, git-emacs 之類，在這邊的設定
我整合了這幾種工具，選用我最喜歡的功能。

Magit Cheatsheet: http://daemianmack.com/magit-cheatsheet.html

#+BEGIN_SRC emacs-lisp
  (require 'magit)
  (require 'gitignore-mode)
  (require 'gitconfig-mode)
#+END_SRC

*** 當使用 magit 時，不使用 emacs 原生的 vc-mode 來處理和 git 相關的事情

emacs 本身具有一個 vc-mode 可以幫忙處理和版本管理相關的事情，但
是我覺的 magit 比較好用，所以當有載入 magit 時，就將 vc-mode 裏面
負責處理 git 的部份拿掉。

#+begin_src emacs-lisp
  (when (featurep 'magit)
    (setq vc-handled-backends (remq 'git vc-handled-backends)))
#+end_src

*** 在 fringe 顯示 git 的狀況

如果可以在 emacs 的 fringe 顯示文字的增加/減少的資訊，那是最好不過得。
git-gutter-fringe 就是這樣的好東西，他可以顯示哪些行和上一次的 commit 有
增加/減少的資訊。

#+begin_src emacs-lisp
  (require 'git-gutter-fringe)
  (global-git-gutter-mode)
#+end_src

*** 使用 git-flow

[[http://nvie.com/posts/a-successful-git-branching-model/][git-flow]] 是一套很推薦使用的 git 版本管理流程

GitHub: https://github.com/jtatarik/magit-gitflow

#+BEGIN_SRC emacs-lisp
  (require 'magit-gitflow)
  (add-hook 'magit-mode-hook 'turn-on-magit-gitflow)
#+END_SRC

*** 按鍵設定                                                     :noexport:

#+TBLNAME: magit-keys
| 按鍵 | 命令              | 描述            |
|------+-------------------+-----------------|
| C-g  | magit-quit-window | 跳出 magit 視窗 |

#+BEGIN_SRC emacs-lisp :noweb yes
  <<gen-keys-map2(map="magit-mode", keys=magit-keys)>>
#+END_SRC

* 檔案備份                                                           :backup:

雖然現在大家都有在使用 git、svn 等檔案管理系統，但我們最好還是有其他的
備份，這裡設定的是 emacs 內建的備份方式。

注意: 由於內建的備份方式是採用 =明碼= 來備份，所以若是加密的檔案也會直接被備份。

** 設定備份檔案的資料夾

這個資料夾將存放所有的備份檔案

#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,emacs-backup-dir)))
#+end_src

** 如果備份檔案用的資料夾不存在，重新建立他

#+begin_src emacs-lisp
  (if (not (file-exists-p emacs-backup-dir))
      (make-directory emacs-backup-dir t))
#+end_src

** 每當敲擊按鍵 50 下時，進行備份

#+begin_src emacs-lisp
  (setq auto-save-interval 50)
#+end_src

** 每 60 秒進行自動儲存

#+begin_src emacs-lisp
  (setq auto-save-timeout 60)
#+end_src

** 真的刪除檔案，而不是放入垃圾桶

#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash nil)
#+end_src

** 當讀取檔案時，不自動進行檔案儲存

#+begin_src emacs-lisp
  (setq auto-save-visited-file-name nil)
#+end_src

** 當緩衝區儲存後，刪除掉自動儲存的檔案

#+begin_src emacs-lisp
  (setq delete-auto-save-files t)
#+end_src

** 讓備份檔案具有版本控管的功能

當備份檔案的時候，可以透過設定 kept-old-versions 以及 kept-new-versions 來決定
要保留多少備份。

#+begin_src emacs-lisp
  (setq version-control t)
#+end_src

** 保留舊有的 10 個備份

當新的備份建立起來後，保留舊有的 10 個備份

#+begin_src emacs-lisp
  (setq kept-old-versions 10)
#+end_src

** 建立新的 20 個備份

建立新的 20 個備份，當備份數量超過 20 以後，第一個備份會變成舊有的備份。

#+begin_src emacs-lisp
  (setq kept-new-versions 20)
#+end_src

** 刪除舊有的備份

刪除非以上所述的 30 個備份

#+begin_src emacs-lisp
  (setq delete-old-versions t)
#+end_src

** 使用複製的方式來產生備份檔案

#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

** 其他設置

#+begin_src emacs-lisp
  (setq auto-save-default    t)           ; auto-save of every file-visiting buffer
  ;; change auto-save-list setting
  (setq auto-save-list-file-prefix (concat emacs-backup-dir "auto-saves-"))
  (setq auto-save-file-name-transforms `((".*"  ,emacs-backup-dir)))
#+end_src
* 命令欄 (minibuffer)                                            :minibuffer:

** 設定視窗高度最多為 4 行高

#+begin_src emacs-lisp
  (setq max-mini-window-height 4)
#+end_src

** 游標改成 bar 的形狀                                             :cursor:

我討厭在 minibuffer 時還是使用方塊狀的游標，這裡將他改變成 Bar 的形狀。

#+begin_src emacs-lisp
  (add-hook 'minibuffer-setup-hook '(lambda () (setq cursor-type 'bar)))
#+end_src
** 使用 smex 來替代原本的緩衝區功能                            :smex:

#+begin_src emacs-lisp
  (require 'smex)
  (smex-initialize)
#+end_src

設定 smex 暫存檔案在 =emacs-cache-dir= 裡面。
#+begin_src emacs-lisp
  (setq smex-save-file (concat emacs-cache-dir "smex.dat"))
#+end_src

** 紀錄 minibuffer 使用過的命令

透過 savehist 套件，我們可以將 Minibuffer 使用過的命令紀錄起來，
下次打開 emacs 仍可以知道之前呼叫過哪些 Minubuffer 的命令。

#+begin_src emacs-lisp
  (require 'savehist)
  (setq savehist-file (concat emacs-cache-dir "savehist.dat"))
  (savehist-mode 1)
#+end_src

** 按鍵設定                                                       :noexport:

#+TBLNAME: minibuffer-local-keys
| 按鍵 | 命令                                | 描述                      |
|------+-------------------------------------+---------------------------|
| M-l  | backward-kill-word                  | 刪除前一個詞              |
| M-p  | previous-history-element            | 前一個歷史紀錄            |
| M-n  | next-history-element                | 後一個歷史紀錄            |
| C-g  | minibuffer-keyboard-quit            | 離開 minibuffer           |
| C-u  | coldnew/minibuffer-clear            | 清空 minibuffer           |
| M-t  | coldnew/minibuffer-switch-tmpdir    | 切換到 /tmp 資料夾        |
| M-h  | coldnew/minibuffer-switch-homedir   | 切換到 ~/ 資料夾          |
| M-w  | coldnew/minibuffer-switch-workspace | 切換到 ~/Workspace 資料夾 |
| M-r  | coldnew/minibuffer-switch-rootdir   | 切換到 / 資料夾           |

#+BEGIN_SRC emacs-lisp :noweb yes
  <<gen-keys-map2(map="minibuffer-local", keys=minibuffer-local-keys)>>
#+END_SRC

** 按鍵相關函式/命令

#+BEGIN_SRC emacs-lisp
  (defun coldnew/minibuffer-clear ()
    "Clear minibuffer"
    (interactive) (kill-line 0))

  (defun coldnew/minibuffer-switch-dir (path)
    "Clear mimibuffer and insert dir path"
    (kill-line 0) (insert path))

  (defun coldnew/minibuffer-switch-rootdir ()
    "Switch to tmpdir in minibuffer"
    (interactive) (coldnew/minibuffer-switch-dir "/"))

  (defun coldnew/minibuffer-switch-tmpdir ()
    "Switch to tmpdir in minibuffer"
    (interactive) (coldnew/minibuffer-switch-dir "/tmp/"))

  (defun coldnew/minibuffer-switch-homedir ()
    "Switch to ~/ in minibuffer"
    (interactive) (coldnew/minibuffer-switch-dir "~/"))

  (defun coldnew/minibuffer-switch-workspace ()
    "Switch to ~/Workspace in minibuffer"
    (interactive) (coldnew/minibuffer-switch-dir "~/Workspace/"))
#+END_SRC

* 互動式命令                                                        :command:

互動式命令就是可以在 emacs 裏面使用 M-x 然後呼叫的那些 command,
這邊根據其用途進行分類。

*注意* : 這邊的命令可能依賴我所自訂的 function。

** 巨集相關                                                          :macro:

*** 動態切換開始/結束紀錄巨集

#+BEGIN_SRC emacs-lisp
  (let ((kbd-macro-state "off"))
    (defun toggle-kbd-macro-recording ()
      "Toggle recording on/off emacs kbd macro."
      (interactive)
      (cond
       ((string= "on" kbd-macro-state)
        (setq kbd-macro-state "off")
        (end-kbd-macro))
       ((string= "off" kbd-macro-state)
        (setq kbd-macro-state "on")
        (start-kbd-macro nil)))))
#+END_SRC

** 緩衝區處理                                                       :buffer:

*** 將 unix 格式的文件轉換成 dos 格式

#+begin_src emacs-lisp
  (defun unix2dos ()
    "Convert buffer file from unix file to dos file."
    (interactive)
    (unix->dos (current-buffer)))
#+end_src

*** 將 dos 格式的文件轉換成 unix 格式

#+begin_src emacs-lisp
  (defun dos2unix ()
    "Convert buffer file from dos file to unix file."
    (interactive)
    (dos->unix (current-buffer)))
#+end_src

*** 將緩衝區的編碼改成 utf8

#+begin_src emacs-lisp
  (defun encode-buffer-to-utf8 ()
    "Sets the buffer-file-coding-system to UTF8."
    (interactive)
    (set-buffer-file-coding-system 'utf-8 nil))
#+end_src

*** 讓 emacs 可以一直儲存緩衝區 (即使檔案未經修正)

預設的 save-buffer 在 buffer 沒有變動時，不會進行儲存，
使用此命令可以使得在呼叫 save-buffer-always 時，將 buffer 變更為修改過，
並進行儲存。

#+begin_src emacs-lisp
  (defun save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))
#+end_src

*** 關閉除了 *scratch* 以外的所有 buffer

當我想要讓我的 emacs 變得很乾淨的時候，這命令很好用。

#+begin_src emacs-lisp
  (defun nuke-all-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapcar (lambda (x) (kill-buffer x)) (buffer-list))
    (delete-other-windows))
#+end_src

*** 跳轉到 *scratch*

跳轉目前 buffer 與 =*scratch*= ，假如 =*scratch*= 不存在，
則建立一個 major-mode 為 lisp-interaction-mode 的 =*scratch*=

#+begin_src emacs-lisp
  (defun scratch-toggle ()
    "Toggle between *scratch* buffer and the current buffer.
     If the *scratch* buffer does not exist, create it."
    (interactive)
    (let ((scratch-buffer-name (get-buffer-create "*scratch*")))
      (if (equal (current-buffer) scratch-buffer-name)
          (switch-to-buffer (other-buffer))
        (progn
          (switch-to-buffer scratch-buffer-name)
          (unless (equal major-mode 'lisp-interaction-mode)
            (lisp-interaction-mode))))))
#+end_src
*** 清除除了目前的緩衝區以外的緩衝區

和 nuke-all-buffers 很像，但是這個命令只會保留目前的緩衝區。

#+begin_src emacs-lisp
    (defun kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+end_src

*** 縮排整個緩衝區

將整個緩衝區進行縮排的動作，同時移除多餘的空白以及將 TABS 轉換
成空白

#+begin_src emacs-lisp
  (defun indent-whole-buffer ()
    "Indent whole buffer and delete trailing whitespace.
  This command will also do untabify."
    (interactive)
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max))
    (untabify (point-min) (point-max)))
#+end_src

*** 縮牌選擇區域或是整個緩衝區

將整個緩衝區進行縮排的動作，同時移除多餘的空白以及將 TABS 轉換
成空白，如果有選取區域，則只對區域有效，反之種個緩衝區有效。

#+begin_src emacs-lisp
  (defun indent-region-or-buffer ()
    "Indents a region if selected, otherwise the whole buffer."
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (delete-trailing-whitespace (region-beginning) (region-end))
            (indent-region (region-beginning) (region-end))
            (untabify (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-region-or-buffer)
          (message "Indented buffer.")))))
#+end_src

** 檔案處理                                                           :file:

這編放的是和檔案處理，或是和檔案相關的緩衝區處理命令。

*** 刪除目前的檔案與 buffer

有些時候我們不只是想要關掉緩衝區，同時還要順便把這個檔案砍了，
使用這個命令可以同時將這兩個想法完成。

#+begin_src emacs-lisp
  (defun delete-file-and-buffer ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
#+end_src

*** 使用瀏覽器觀看目前的檔案

透過 emacs 的 browse-url function 來呼叫瀏覽器打開目前的檔案。

#+begin_src emacs-lisp
  (defun browse-current-file ()
    "Open the current file as a URL using `browse-url'."
    (interactive)
    (browse-url (concat "file://" (buffer-file-name))))
#+end_src

*** 重新載入緩衝區裏面的檔案

如果沒有設定 =(global-auto-revert-mode 1)= 的話，emacs 式不會自動重新載入檔案的，這個時候就會需要使用命令
來幫忙將所有緩衝區的檔案進行重新載入，避免寫入檔案時出現錯誤。

#+begin_src emacs-lisp
(defun revert-all-buffers ()
  "Revert all non-modified buffers associated with a file.
This is to update existing buffers after a Git pull of their underlying files."
  (interactive)
  (save-current-buffer
    (mapc (lambda (b)
            (set-buffer b)
            (unless (or (null (buffer-file-name)) (buffer-modified-p))
              (revert-buffer t t)
              (message "Reverted %s\n" (buffer-file-name))))
          (buffer-list))))
#+end_src

*** 複製並開啟檔案

使用這個命令，可以複製目前的緩衝區到另外一個檔案，同時打開那個檔案。

#+begin_src emacs-lisp
  (defun clone-file-and-open (filename)
    "Clone the current buffer writing it into FILENAME and open it"
    (interactive "FClone to file: ")
    (save-restriction
      (widen)
      (write-region (point-min) (point-max) filename nil nil nil 'confirm))
    (find-file filename))
#+end_src

*** 將目前緩衝區的檔案加上可執行權限

簡單的來說，這個功能就是

: chmod +x <file>

但是在以下的程式裏面，並未使用 chmod 的命令，而是使用 emacs 的
logior function 來改變檔案屬性。

這邊我只讓目前使用者可以執行這份檔案，至於群組、其他使用者則維持不動。

#+begin_src emacs-lisp
  (defun set-file-executable()
    "Add executable permissions on current file."
    (interactive)
    (when (buffer-file-name)
      (set-file-modes buffer-file-name
                      (logior (file-modes buffer-file-name) #o100))
      (message (concat "Made " buffer-file-name " executable"))))
#+end_src

** 視窗操作                                                         :window:

*** 將整個 emacs 全螢幕

有些時候我會很希望我的 emacs 可以全螢幕，用這個命令可以很方便達到我的想法。
#+begin_src emacs-lisp
  (defun fullscreen-window ()
    "Make the window full-screen."
    (interactive)
    (let ((current-value (frame-parameter nil 'fullscreen))
          (old-value nil))
      (set-frame-parameter nil 'fullscreen
                           (if (equal 'fullboth current-value)
                               'old-value
                             (progn
                               (setq old-value current-value)
                               'fullboth)))))
#+end_src

*** 旋轉視窗

有時候就是希望左右兩邊視窗可以對調，因此弄了以下的命令讓視窗可以進行旋
轉移動，若只有兩個視窗，則這個命令相當於 swap-windows 的功能，這邊設計
了兩種類型的旋轉視窗

- rotate-windows - 旋轉視窗，視窗焦點會落在原本的緩衝區內。
- rotate-windows-only - 旋轉視窗，但是視窗的焦點還是在原本的視窗內。

#+begin_src emacs-lisp
  (defun rotate-windows-helper (x d)
    "Helper function for rotate window."
    (if (equal (cdr x) nil)
        (set-window-buffer (car x) d)
      (set-window-buffer (car x) (window-buffer (cadr x)))
      (rotate-windows-helper (cdr x) d)))

  (defun rotate-windows ()
    "Rotate window but make the focus on the same bufer."
    (interactive)
    (rotate-windows-helper (window-list) (window-buffer (car (window-list))))
    (select-window (car (last (window-list)))))

  (defun rotate-windows-only ()
    "Rotate windows only, keep focus at the same window."
    (interactive)
    ;; sotre window
    (let ((cur (car (window-list))))
      (rotate-windows-helper (window-list) (window-buffer (car (window-list))))
      (select-window cur)))
#+end_src

** 文字編輯 (插入/移除)

*** 刪除重複行

#+BEGIN_SRC emacs-lisp
  (defun uniquify-all-lines-region (start end)
    "Find duplicate lines in region START to END keeping first occurrence."
    (interactive "*r")
    (save-excursion
      (let ((end (copy-marker end)))
        (while
            (progn
              (goto-char start)
              (re-search-forward "^\\(.*\\)\n\\(\\(.*\n\\)*\\)\\1\n" end t))
          (replace-match "\\1\n\\2")))))

  (defun uniquify-all-lines-buffer ()
    "Delete duplicate lines in buffer and keep first occurrence."
    (interactive "*")
    (uniquify-all-lines-region (point-min) (point-max)))
#+END_SRC
*** 刪除相對應的括號

#+begin_src emacs-lisp
  (defun delete-between-pair (char)
    "Delete in between the given pair"
    (interactive "cDelete between pair: ")
    (let ((pair-char))
      (search-backward-to-char char)
      (forward-char 1)
      (cond
       ((char-equal char ?\() (setq pair-char ?\)))
       ((char-equal char ?\") (setq pair-char ?\"))
       ((char-equal char ?\') (setq pair-char ?\'))
       ((char-equal char ?\[) (setq pair-char ?\]))
       ((char-equal char ?\{) (setq pair-char ?\}))
       ((char-equal char ?\<) (setq pair-char ?\>)))
      (zap-up-to-char 1 pair-char)))
#+end_src

*** 刪除一個 '字'

#+begin_src emacs-lisp
  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-region (point) (progn (forward-word arg) (point))))

#+end_src

*** 向左刪除一個 '字'
#+begin_src emacs-lisp
  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))
#+end_src

*** 將游標下的文字改用絕對路徑表示

這個命令可以再當你輸入 ~/ 時，使用他會將他變成絕對路徑。

#+begin_src emacs-lisp
  (defun resolve-sym-link ()
    "Replace the string at the point with the true path."
    (interactive)
    (beginning-of-line)
    (let* ((file (buffer-substring (point)
                                   (save-excursion (end-of-line) (point))))
           (file-dir (file-name-directory file))
           (file-true-dir (file-truename file-dir))
           (file-name (file-name-nondirectory file)))
      (delete-region (point) (save-excursion (end-of-line) (point)))
      (insert (concat file-true-dir file-name))))
#+end_src
*** 多次貼上

emacs 本身的 yank 命令是無法使用 universla-argument 的，
也就是說無法使用 C-u 80 C-y 來貼上複製的東西 80 次，
而是貼上前幾次紀錄在 kill-ring 的資訊。

yank-n-times 則可以重複的進行貼上。

當沒有使用 universal-argument 指定要貼上多少次時，
會使用 prompt 詢問貼上的次數。

#+begin_src emacs-lisp
  (defun yank-n-times (&optional arg)
    "yank multiple times."
    (interactive "P")
    (let ((times (if (equal current-prefix-arg nil)
                     (read-number "yank repet times: ")
                   arg)))
      (if (< times 1)
          (setq times 1)
        (dotimes 'times (yank)))))
#+end_src
*** 插入空白行

#+begin_src emacs-lisp
  (defun insert-empty-line ()
    "Insert an empty line after current line and position cursor on newline."
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line 1))
#+end_src
*** 切入 function 緩衝區或是跳回來

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, subtree, or defun, whichever applies
  first.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
          (t (narrow-to-defun))))
#+END_SRC

*** 插入 U200B 字元

#+BEGIN_SRC emacs-lisp
  (defun insert-U200B-char ()
    "Insert <U200B> char, this character is nice use in org-mode."
    (interactive)
    (insert "\ufeff"))
#+END_SRC

** 資訊收尋

*** 到 stackoverflow 收尋

#+BEGIN_SRC emacs-lisp
  (defun stackoverflow-search ()
    "Searches Stack Overflow for current region, or prompts for query if none exists."
    (interactive)
    (browse-url
     (concat
      "http://stackoverflow.com/search?q="
      (active-region-or-prompt "Search Stack Overflow for: "))))
#+END_SRC

** 其他命令

*** 連線到 IRC 或是切換到有新資訊的頻道                                  :irc:

注意到這邊使用加密(SSL)的 port 6697，而不是非加密的 port 6667

#+BEGIN_SRC emacs-lisp
  (defun erc-start-or-switch ()
    "Connect to IRC, if already connected, switch to active irc buffer."
    (interactive)
    (let ((irc-active-p (and (fboundp 'erc-buffer-list)
                             (erc-buffer-list))))
      ;; we track irc.freenode.net to make sure erc is already active
      (if irc-active-p
          (erc-track-switch-buffer 1)
        (progn
          ;; connect to irc server
          (erc-tls :server "irc.freenode.net" :port 6697 :nick erc-nick)
          (erc-tls :server "irc.debian.org" :port 6697 :nick erc-nick)
          (erc-tls :server "irc.mozilla.org" :port 6697 :nick erc-nick)))))
#+END_SRC

*** TODO 切換 Uart 終端機或是目前的緩衝區

#+BEGIN_SRC emacs-lisp
  (defun serial-term-or-switch ()
    "Switch to usb serial 1, 2, 3 when exist or switch back to current buffer."
    (interactive)
    (let ((serial-list))

      ;; In mac osx, usb serial start at /dev/tty.usbserial
      (when mac-p
        (setq serial-list '("/dev/tty.usbserial" "/dev/tty.usbserial1" "/dev/tty.usbserial2")))

      ;; In mac osx, usb serial start at /dev/ttyUSB0
      (when linux-p
        (setq serial-list '("/dev/ttyUSB0" "/dev/ttyUSB1" "/dev/ttyUSB2")))

      ;; Check for serial is exist or not, remove from list if not exist
      (dolist (s serial-list)
        (unless (and (file-exists-p s) (file-writable-p s))
          (setq serial-list (delete s serial-list))))

      ;; Do nothing if serial-list is empty list
      ;;      (unless serial-list

      (message (format "serial: %s" serial-list))

      ))
  ;;)
  ;;(serial-term-or-switch)
#+END_SRC

*** 顯示/隱藏 ECB

#+BEGIN_SRC emacs-lisp
  (defun toggle-ecb-mode ()
    "Toggle ecb-minor-mode and resize window accordingly"
    (interactive)
    (if ecb-minor-mode
        (progn
          (let ((w (frame-width ecb-frame)))
            (message "%i" w))
          (ecb-minor-mode))
      (progn
        (message "%s" "turning on, make frame wider")
        (ecb-minor-mode))))
#+END_SRC

** 複合式命令

這邊的命令比較特別，是 *複合式* 的，代表一個命令可能依據使用
的方式不同，而具有不同的功能。

*** 旋轉切換視窗/尋找並取代

#+BEGIN_SRC emacs-lisp
  (defun ~rotate-weindow/query-replace ()
    "If in region, us query replace, else use rotate-window-only."
    (interactive)
    (if (or mark-active (= (length (window-list)) 1))
        (call-interactively 'query-replace-regexp)
      (rotate-windows-only)))
#+END_SRC

*** 選取區域/選取矩形區域

#+BEGIN_SRC emacs-lisp
  (defun ~cua-set-mark/cua-rectangle-mark ()
    "toggle between cua-set-mark or cua-rectangle-mark"
    (interactive)
    (if (not mark-active)
        (call-interactively 'cua-set-mark)
      (cua-toggle-rectangle-mark)))
#+END_SRC

* IRC 聊天通訊                                                          :irc:

emacs 底下最常用的 IRC 軟體為 ERC 和 RCIRC，這邊我選用 ERC 作為 IRC 客戶端。

#+begin_src emacs-lisp
  (require 'erc)
  (require 'erc-notify)
  (require 'erc-spelling)
  (require 'erc-autoaway)
  (require 'erc-log)
#+end_src

** 基本設定
*** 設定 prompt 為 ->>

#+begin_src emacs-lisp
  (setq erc-prompt "->> ")
#+end_src

*** 編碼設定為 utf-8

#+begin_src emacs-lisp
  (setq erc-server-coding-system '(utf-8 . utf-8))
#+end_src

*** 設定聊天時的行寬為 100

#+begin_src emacs-lisp
  (setq erc-fill-column 100)
#+end_src

*** 當 ERC 啟動時，自動連入 IRC 伺服器

#+begin_src emacs-lisp
  (erc-autojoin-mode t)
#+end_src
*** 自動將太長的一行文字變成多行

#+BEGIN_SRC emacs-lisp
  (erc-truncate-mode +1)
#+END_SRC

** 設定自動連線的伺服器與聊天室

#+begin_src emacs-lisp
  (setq erc-autojoin-channels-alist
        '(
          ;; english channel
          (".*\\.freenode.net" "#emacs" "#clojure" "#wayland" "#libhybris")
          (".*\\.mozilla.org" "#b2g")
          ;; Chinese channel
          (".*\\.freenode.net" "#emacs.tw" "#tossug" "#coscup" "#g0v.tw" "#clojure.tw" "#lisp.tw")
          (".*\\.oftc.net" "#dot")))
#+end_src

** 設定部份類型訊息不進行顯示

#+begin_src emacs-lisp
  (setq erc-hide-list
        '(;; notices
          "JOIN" "PART" "QUIT" "LEFT" "NICK"
          ;; robot
          "^j[a-z]*bot!" "^fussbot!"
          ))
#+end_src

** 為訊息加上時間戳(timestamp)

為訊息加上時間戳，並請將時間設定在左手邊

#+BEGIN_SRC emacs-lisp
  (erc-timestamp-mode 1)
  (setq erc-insert-timestamp-function 'erc-insert-timestamp-left)
#+END_SRC

** 為聊天室裡的使用者暱稱上色

#+BEGIN_SRC emacs-lisp
  (require 'erc-hl-nicks)
#+END_SRC

** 使用系統視窗進行提醒

針對 OSX 平台，需要安裝 =terminal-notifier= ，這個程式可以透過 homebrew
來安裝

: brew install terminal-notifier

GitHub: https://github.com/julienXX/erc-terminal-notifier.el

#+BEGIN_SRC emacs-lisp
  (require 'erc-terminal-notifier)
#+END_SRC

如果是 Linux 平台，則只需要安裝 libnotify 並加上以下設定

#+BEGIN_SRC emacs-lisp

#+END_SRC

** 讓 erc 自動擷取連結的圖片

GitHub: https://github.com/kidd/erc-image.el

#+BEGIN_SRC emacs-lisp
  (require 'erc-image)
  (add-to-list 'erc-modules 'image)
  (erc-update-modules)

#+END_SRC

縮小圖片大小，避免圖片太大
#+BEGIN_SRC emacs-lisp
  ;; scale the image preven it too large
  (setq erc-image-inline-rescale 100)
#+END_SRC

** 啟用 track-mode

#+BEGIN_SRC emacs-lisp
  (erc-track-mode t)
#+END_SRC

** 設定在 erc-track-mode 中不追蹤的訊息類型

#+BEGIN_SRC emacs-lisp
  (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                  "324" "329" "332" "333" "353" "477"))
#+END_SRC

** 自動對 IRC 聊天進行紀錄

#+BEGIN_SRC emacs-lisp
  (erc-log-mode 1)
#+END_SRC

設定紀錄檔的位置，如果該資料夾不存在則自動建立他
#+BEGIN_SRC emacs-lisp
  (setq erc-log-channels-directory emacs-log-dir)
  (unless (file-exists-p erc-log-channels-directory)
    (mkdir erc-log-channels-directory t))
#+END_SRC

所有紀錄檔案編碼都該為 utf-8
#+BEGIN_SRC emacs-lisp
  (setq erc-log-file-coding-system 'utf-8)
#+END_SRC

除此之外，當送出或是收到新的訊息時，將訊息寫入到 log 中
#+BEGIN_SRC emacs-lisp
    (setq erc-log-write-after-send t)
    (setq erc-log-write-after-insert t)
#+END_SRC

* 電子郵件                                                            :email:

在 emacs 下有許多不錯用的電子郵件軟體，比如 GNUS、wanderlost 等。我則特別
偏好 [[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] 。mu4e 是 mu 的 elisp 接口，由 [[http://emacs-fu.blogspot.tw/][emacs-fu]] 的作者 [[http://www.djcbsoftware.nl/][djcb]] 所撰寫。

為什麼選擇使用 mu4e 呢，我的理由有以下幾點:

- 使用外部程式如 offlineimap 下載郵件，不會在下載郵件時讓 emacs 停住
- 使用 C 語言寫的 mu 進行郵件索引，速度快

mu4e 透過外部程式去取得 email 並進行 index，由於這邊的處理並不是 emacs 本身
處理，並不會因為 emacs 是單一 thread 的程式，而造成整個 emacs 卡住。

#+BEGIN_SRC emacs-lisp
  (when mac-p
    (add-to-list 'load-path "/usr/local/Cellar/mu/HEAD/share/emacs/site-lisp/mu4e"))

  (require 'mu4e)
#+END_SRC

由於我的信件是使用 offlineimap 進行下載，因此在使用 mu4e 之前，必須先
安裝 offlineimap，並對他進行配置。

** 讓 offlineimap 透過 emacs 取得密碼

我的信件密碼儲存在 =~/.authinfo.gpg= 裡面，因為是使用 gpg 進行加密，並且
我不希望在輸入密碼的過程中另外彈出討厭的視窗，而是讓輸入密碼的視窗
出現在 emacs 中，因此要讓 emacs 來進行讀取檔案並回傳密碼的動作。

要辦到這樣的狀況 offlineimap 可以在設定中加入

: pythonfile = ~/.offlineimap.py

來載入額外的 function，我在這個檔案裏面加入了

#+begin_src python :tangle no
  #!/usr/bin/env python

  import subprocess

  def get_output(cmd):
      # Bunch of boilerplate to catch the output of a command:
      pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
      (output, errout) = pipe.communicate()
      assert pipe.returncode == 0 and not errout
      return output

  def get_password_emacs(host, port):
      cmd = "emacsclient --eval '(offlineimap-get-password \"%s\" \"%s\")'" % (host,port)
      return get_output(cmd).strip().lstrip('"').rstrip('"')
#+end_src

讓 offlineimap 可以透過 get_password_emacs() 來從 emacs 裏面取得密碼。

#+begin_src emacs-lisp
  (defun offlineimap-get-password (host port)
    (require 'netrc)
    (let* ((netrc (netrc-parse (expand-file-name "~/.authinfo.gpg")))
           (hostentry (netrc-machine netrc host port port)))
      (when hostentry (netrc-get hostentry "password"))))
#+end_src

因此，在 .offlineimaprc 裏面加入這樣一行

: remotepasseval = get_password_emacs("imap.gmail.com")

即可透過 emacs 取得 password 這個密碼。

** 設定 mu4e 為預設的 email 系統

#+begin_src emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

** 郵件資料夾存放位置設定為 ~/Maildir

#+begin_src emacs-lisp
  (setq mu4e-maildir "~/Maildir")
#+end_src

** 使用 offlineimap 取得郵件

#+begin_src emacs-lisp
  (setq mu4e-get-mail-command "offlineimap")
#+end_src

** 每隔 60 秒 重新抓取郵件

#+begin_src emacs-lisp
  (setq mu4e-update-interval 60)
#+end_src

** 使用 w3m 將 HTML 轉換為 text 檔

#+begin_src emacs-lisp
  (setq mu4e-html2text-command "w3m -dump -T text/html")
#+end_src

** 在郵件中顯示圖片

#+begin_src emacs-lisp
  (setq mu4e-view-show-images t)
#+end_src

** 設定我的 email 帳戶列表

#+begin_src emacs-lisp
  (setq coldnew/mu4e-account-alist
        '(("Gmail"
           (mu4e-sent-folder "/Gmail/Sent")
           (mu4e-drafts-folder "/Gmail/Drafts")
           (mu4e-trash-folder "/Gmail/Trash")
           (user-mail-address "coldnew.tw@gmail.com")
           (smtpmail-smtp-server "smtp.gmail.com")
           (smtpmail-smtp-service 587)
           (smtpmail-smtp-user "coldnew.tw@gmail.com"))
          ))
#+end_src

** 設定預設的帳戶為 Gmail

#+begin_src emacs-lisp
  (defun coldnew/mu4e-set-default-account (account)
    "Setup the default account based on coldnew/mu4e-account-alist."
    (let* ((account (cdr (assoc account coldnew/mu4e-account-alist))))
      (when account (mapc #'(lambda (a)
                              (set (car a) (if (stringp (cadr a)) (cadr a) (eval (cadr a))))) account))))

  (coldnew/mu4e-set-default-account "Gmail")
#+end_src

** 設定 smtp 讓 emacs 可以發送 mail

#+BEGIN_SRC emacs-lisp
  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-stream-type 'starttls
        starttls-use-gnutls t)
#+END_SRC

** 在使用 mu4e 發送信件之前選擇要用的帳戶

#+BEGIN_SRC emacs-lisp
  (defun coldnew/mu4e-set-account ()
    "Set the account for composing a message."
    (interactive)
    (let* ((account
            (if mu4e-compose-parent-message
                (let ((maildir (mu4e-msg-field mu4e-compose-parent-message :maildir)))
                  (string-match "/\\(.*?\\)/" maildir)
                  (match-string 1 maildir))
              (completing-read (format "Compose with account: (%s) "
                                       (mapconcat #'(lambda (var) (car var)) coldnew/mu4e-account-alist "/"))
                               (mapcar #'(lambda (var) (car var)) coldnew/mu4e-account-alist)
                               nil t nil nil (caar coldnew/mu4e-account-alist))))
           (account-vars (cdr (assoc account coldnew/mu4e-account-alist))))
      (if account-vars
          (mapc #'(lambda (var)
                    (set (car var) (cadr var)))
                account-vars))))

  (add-hook 'mu4e-compose-pre-hook 'coldnew/mu4e-set-account)
#+END_SRC

** 針對看起來是 patch 的信件內容加上顏色

#+BEGIN_SRC emacs-lisp
  (defun mu4e~view-fontify-diff ()
    "Colorize diff message."
    (interactive)
    (let ((inhibit-read-only t))
      (save-excursion
        (goto-char (point-min))
        ;; consider only lines that heuristically look like a citation line...
        (while (re-search-forward "^\\(\\(\\+\\)[^+]\\|\\(-\\)[^-]\\)" nil t)
          (let ((cur-point (or (match-beginning 2) (match-beginning 3)))
                (color (if (match-beginning 2)
                           "green"
                         "deep pink")))
            (end-of-line)
            (add-text-properties cur-point (point)
                                 `(face ((foreground-color . ,color))))))
        (goto-char (point-min))
        (while (re-search-forward "^\\(\\+\\+\\+\\|---\\)" nil t)
          (let ((cur-point (match-beginning 1)))
            (end-of-line)
            (add-text-properties cur-point (point)
                                 '(face ((weight . bold)))))))))

  (add-hook 'mu4e-view-mode-hook 'mu4e~view-fontify-diff)
#+END_SRC

* 文檔幫助                                                             :help:

這邊放置 manpage、womanpage、info 等幫助文檔模式的設定。

** WoMan                                                             :woman:

woman 是 emacs 下顯示 manpage 最好的方式。

*** WoMan 快取儲存位置設定

#+begin_src emacs-lisp
  (setq woman-cache-filename (concat emacs-cache-dir "woman.cache"))
#+end_src

*** 對 WoMan 緩衝區上色

#+begin_src emacs-lisp
  (setq woman-fontify t)
#+end_src

*** 設定 WoMan doc 寬度

#+BEGIN_SRC emacs-lisp
  (setq woman-fill-column 100)
#+END_SRC

* TODO ----------------- Prepare for re-write ---------------------------------

ref : http://steckerhalter.co.vu/steckemacs.html

* 基礎設置                                                             :base:

#+begin_src emacs-lisp
  ;; TODO: add comment
  (setq stack-trace-on-error t)
  (setq imenu-auto-scan t)
  ;;(setq redisplay-dont-pause t)

  ;; xrelated srtting
  ;;设定剪贴板的内容格式 适应 Firefox
  (set-clipboard-coding-system 'utf-8)
  ;;允许 emacs 和外部其他程序的粘贴
  (setq x-select-enable-clipboard t)
  ;;使用鼠标中键可以粘贴
  (setq mouse-yank-at-point t)
  ;; 当光标在行尾上下移动的时候，始终保持在行尾。
  (setq track-eol t)
  ;; 当浏览 man page 时，直接跳转到 man buffer。
  (setq Man-notify-method 'pushy)
  (setq select-active-regions t)
  (setq x-gtk-use-system-tooltips nil)    ; disable gtk-tooltip

  (setq max-lisp-eval-depth '40000)
  (setq max-specpdl-size 1000)  ; default is 1000, reduce the backtrace level
  (setq debug-on-error t)    ; now you should get a backtrace
  ;;设置 sentence-end 可以识别中文标点。不用在 fill 时在句号后插入两个空格。
  (setq sentence-end "\\([。！？]\\|……\\|[.?!][]\"')}]*\\($\\|[ \t]\\)\\)[ \t\n]*")
  (setq sentence-end-double-space nil)
#+end_src

#+begin_src emacs-lisp
  ;; nice scrolling
  (setq scroll-margin                   0 )
  (setq scroll-conservatively      100000 )
  (setq scroll-preserve-screen-position 1 )
  (setq scroll-up-aggressively       0.01 )
  (setq scroll-down-aggressively     0.01 )
#+end_src

* 常用的模組 / 函式庫                                               :plugin:

emacs 有一些套件本身不需要配置，或是只是函式庫，這一類的套件我設
定為預先載入，這樣在後面的設定裏面我就可以直接使用這些套件的功能。

若是設定比較簡單的獨立程式也放在這邊。

** 內建套件

iimage 是讓 emacs 可以直接顯示圖片的模式。

#+begin_src emacs-lisp
  (require 'iimage)
#+end_src

** 透過 Paredit 來簡化 Lisp 類語言編輯                             :paredit:

[[http://www.emacswiki.org/emacs/ParEdit][ParEdit]] 是一個非常好用的括號批配模式，特別是在寫 lisp 程式的時候，使用
paredit 可以幫助傳寫程式的速度。

這邊設定部分我會用到的 paredit 函數，完整的按鍵綁定則在 [[*%E4%BD%BF%E7%94%A8%20paredit%20%E4%BE%86%E7%B0%A1%E5%8C%96%E6%8B%AC%E8%99%9F%E7%9A%84%E6%93%8D%E4%BD%9C][使用 paredit 來簡化括號的操作]]

- 載入 paredit 套件

  #+BEGIN_SRC emacs-lisp
    (require 'paredit)
  #+END_SRC

- 關閉 paredit 預設的閃爍同級括號功能

  #+BEGIN_SRC emacs-lisp
    (defun paredit-blink-paren-match (another-line-p)
      "redefine this function, i don't like paredit to blikn math paren")
  #+END_SRC

- 將 hungry-delete 功能加入到 paredit

  #+BEGIN_SRC emacs-lisp
    (defadvice paredit-backward-delete (around paredit-backward-delete activate)
      "Intergrated paredit-backward-delete with hungry-delete."
      ad-do-it
      (when (featurep 'hungry-delete)
        (if (eq (char-before) ?\s)
            (hungry-delete-backward))))

    (defadvice paredit-forward-delete (around paredit-forward-delete activate)
      "Intergrated paredit-forward-delete with hungry-delete."
      ad-do-it
      (when (featurep 'hungry-delete)
        (if (eolp)
            (hungry-delete-forward))))
  #+END_SRC

** TODO speedbar
#+begin_src emacs-lisp
  (require 'speedbar)
  (setq speedbar-use-images nil)
;;  (require 'sr-speedbar)
;;  (setq sr-speedbar-right-side nil)
;;  (setq sr-speedbar-refresh-turn-on t)
#+end_src
** TODO cua                                                            :cua:
#+begin_src emacs-lisp
  (require 'cua-base)
  (require 'cua-rect)
  ;; don't add C-x, C-c, C-v
  (setq cua-enable-cua-keys nil)
  (setq cua-rectangle-mark-key (kbd "C-c RET"))
  ;; Enable cua-mode
  (cua-mode t)

  (cua--init-rectangles)
  (cua--rect-M/H-key ?n   'cua-scroll-up)
  (cua--rect-M/H-key ?N   'cua-sequence-rectangle)
  (cua--rect-M/H-key ?p   'cua-scroll-down)
#+end_src
** TODO slime
#+begin_src emacs-lisp
  (require 'slime)
  (require 'ac-slime)
  ;; Save REPL history to emacs-cache-dir
  (setq slime-repl-history-file (concat emacs-cache-dir "slime-hist.dat"))

  ;; REPL history size set to 300
  (setq slime-repl-history-size 300)

  ;; Use global programming mode
  (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
#+end_src
** TODO uniquify

#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'reverse)
  (setq uniquify-separator "|")
  (setq uniquify-after-kill-buffer-p 1)
  (setq uniquify-ignore-buffers-re "^\\*")
#+end_src
* Vim 摹擬                                                              :vim:

** 綁定按鍵好用的巨集

我很喜歡以前用 vim-mode 時的按鍵定義方式，所以我定義了以下巨集來簡化
綁定按鍵的方法。

全域性的按鍵設置

- vim:nmap 綁定按鍵到 Normal 狀態下
- vim:imap 綁定按鍵到 Insert 狀態下
- vim:vmap 綁定按鍵到 Visual 狀態下
- vim:wmap 綁定按鍵到窗口切換的按鍵
- vim:map  綁定按鍵到 Normal, Insert 狀態下

使用方式：

: (vim:nmap (kbd "g") 'linum-ace-jump)

這樣在 Normal-state 時，按下 g 就可以呼叫 linum-ace-jump 這個命令。

#+begin_src emacs-lisp
  (defmacro vim:nmap (key cmd)
    "Binding keymap to evil-normal-state."
    `(define-key evil-normal-state-map ,key ,cmd))
  (defmacro vim:imap (key cmd)
    "Binding keymap to evil-insert-state."
    `(define-key evil-insert-state-map ,key ,cmd))
  (defmacro vim:vmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-visual-state-map ,key ,cmd))
  (defmacro vim:wmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-window-map ,key ,cmd))

  (defmacro vim:map (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-normal-state-map ,key ,cmd)
    `(define-key evil-insert-state-map ,key ,cmd))
#+end_src

區域性的按鍵設置

- vim:local-nmap 綁定按鍵到 Normal 狀態下，只作用於該緩衝區
- vim:local-imap 綁定按鍵到 Insert 狀態下，只作用於該緩衝區
- vim:local-vmap 綁定按鍵到 Visual 狀態下，只作用於該緩衝區

使用方式：

: (vim:local-nmap (kbd "g") 'linum-ace-jump)

這樣在目前的緩衝區時時， 切到 Normal-state，按下 g 就可以呼叫 linum-ace-jump 這個命令。

注意到這個是屬於 buffer-local 的設定方式，只會影響到該緩衝區，而不是影響整個 mode。

#+begin_src emacs-lisp
  (defmacro vim:local-nmap (key cmd)
    "Binding keymap to evil-normal-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
  (defmacro vim:local-imap (key cmd)
    "Binding keymap to evil-insert-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
  (defmacro vim:local-vmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
#+end_src

根據模式進行按鍵設置

- vim:mode-nmap 綁定按鍵到 Normal 狀態下，只作用於特定模式
- vim:mode-imap 綁定按鍵到 Insert 狀態下，只作用於特定模式
- vim:mode-vmap 綁定按鍵到 Visual 狀態下，只作用於特定模式
- vim:mode-map  綁定按鍵到 Normal, Insert 狀態下

使用方式：

: (vim:mode-nmap emacs-lisp-mode-map (kbd "g") 'linum-ace-jump)

這樣在 emacs-lisp-mode 時， 切到 Normal-state，按下 g 就可以呼叫 linum-ace-jump 這個命令。

#+begin_src emacs-lisp
  (defmacro vim:mode-nmap (map key cmd)
    "Binding keymap to evil-normal-state."
    `(evil-define-key 'normal ,map ,key ,cmd))
  (defmacro vim:mode-imap (map key cmd)
    "Binding keymap to evil-insert-state."
    `(evil-define-key 'insert ,map ,key ,cmd))
  (defmacro vim:mode-vmap (map key cmd)
    "Binding keymap to evil-visual-state."
    `(evil-define-key 'visual ,map ,key ,cmd))

  (defmacro vim:mode-map (map key cmd)
    "Binding keymap to evil-visual-state."
    `(evil-define-key 'normal ,map ,key ,cmd)
    `(evil-define-key 'insert ,map ,key ,cmd))
#+end_src

* 命令欄                                                         :minibuffer:

** 其他
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers     t )
  (setq minibuffer-electric-default-mode t )

  ;; Abort the minibuffer when using the mouse
  (add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)

  (defun stop-using-minibuffer ()
    "kill the minibuffer"
    (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
      (abort-recursive-edit)))
#+end_src

** ido
*** Depends
#+begin_src emacs-lisp
  (require 'ido)
#+end_src
*** Keybindings
#+begin_src emacs-lisp
  (add-hook 'ido-setup-hook
            '(lambda ()
               (define-key ido-completion-map (kbd "C-f") 'ido-next-match)
               (define-key ido-completion-map (kbd "C-b") 'ido-prev-match)
               ))
#+end_src

#+BEGIN_SRC emacs-lisp
  ;; Ignore .DS_Store files with ido mode ;;-
  (add-to-list 'ido-ignore-files "\\.DS_Store")
#+END_SRC

* org-mode                                                              :org:

因為 org-mode 在這個設定檔裡佔有非常重要的比例，所以獨立出來。

** 使用 org-mode 記事                                              :capture:

org-mode 也是非常強大的記事工具，我在這邊先設定我擺放 org-mdoe 檔案的資料
夾

#+BEGIN_SRC emacs-lisp
  (setq org-directory (concat sparkleshare-dir "/org/"))
#+END_SRC

而 agenda 的檔案則直接從 org-mode 檔案所在的資料夾去尋找

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-directory))
#+END_SRC

*** 當從 TODO 轉變成 DONE 的時候，加上時間標記 (logdone)

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

*** 設定預設的筆記檔案

我使用 TODO.org 當作預設的記事檔案。

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (concat org-directory "TODO.org"))
#+END_SRC

*** TODO 加上去

#+begin_src emacs-lisp
  (setq org-capture-templates '(("t" "TODO" entry (file+headline "" "Tasks")
                                 "* TODO %?\n %i\n")
                                ("f" "FIXME" entry (file+headline "" "Tasks")
                                 "* FIXME %?\n %i\n %a")
                                ("w" "Weintek" entry (file+headline "" "Weintek")
                                 "* TODO %?\n %i\n %a")
                                ))

#+end_src

*** TODO Keybinding
#+begin_src emacs-lisp
  (add-hook 'org-capture-mode-hook
            '(lambda ()
               ;;(define-key coldnew/command-mode-map "c" 'org-capture-finalize)
               (local-set-key (kbd "C-g") 'org-capture-kill)
               ))

#+end_src

** 讓 org-mode 與 cua-mode 相容

#+begin_src emacs-lisp
  (setq org-CUA-compatible t)
#+end_src

** 預設不要讓 org-mode 顯示 Latex 形式的下標與上標

org-mode 預設會把 A_2 變成下標形式，這邊設置這個變數全域性取消這個功能。

#+begin_src emacs-lisp
  (setq org-export-with-sub-superscripts nil)
#+end_src

** TODO Config

#+begin_src emacs-lisp
  (setq org-pretty-entities t)
  (setq org-use-speed-commands t)
#+end_src

** 設定 Agenda 顯示在目前的 window 上。

#+begin_src emacs-lisp
  (setq org-agenda-window-setup 'current-window)
#+end_src

** 在 Agenda mode 時啟用 hl-line

#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+end_src

** 使用 C-g 離開 Agenda

#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook
            '(lambda ()
               (local-set-key (kbd "C-g") 'org-agenda-exit)))
#+end_src

** 在 org-mode 裏面使用 C-c I 切換顯示圖片                          :keymap:

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-c I") 'org-toggle-inline-images)))
#+end_src
** 設定圖片的寬度

#+BEGIN_SRC emacs-lisp
  (setq org-image-actual-width nil)
#+END_SRC

** Keybinding
*** org-mode
設定自定義的按鍵。
#+begin_src emacs-lisp
    (add-hook 'org-mode-hook
              '(lambda ()
                 (define-key org-mode-map (kbd "C-c C-p") 'org-backward-same-level)
                 (define-key org-mode-map (kbd "C-c C-n") 'org-forward-same-level)
                 (define-key org-mode-map (kbd "C-c C-b") 'coldnew/org-up-parent)
                 (define-key org-mode-map (kbd "C-c C-f") 'coldnew/org-down-children)
                 (define-key org-mode-map (kbd "C-c i") 'org-insert-link)
                 ;;(define-key coldnew/command-mode-map "c" 'org-edit-special)
                 ))

  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-\'") nil)
               (define-key org-mode-map (kbd "C-,") nil)
               ;;(define-key org-mode-map (kbd "C-c C-e") nil)
               ))
#+end_src


#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-c b") 'org-metaleft)
               (define-key org-mode-map (kbd "C-c f") 'org-metaright)
               (define-key org-mode-map (kbd "C-c p") 'org-metaup)
               (define-key org-mode-map (kbd "C-c n") 'org-metadown)))
#+end_src
*** org-src-mode
#+begin_src emacs-lisp
  (add-hook 'org-src-mode-hook
            '(lambda ()
               ;;(local-set-key (kbd "C-c C-c") 'org-edit-src-exit)
               ;;(define-key coldnew/command-mode-map "c" 'org-edit-src-exit)
               ))
#+end_src
** Conflict Fix
some packages conflict with org-mode
*** windmove
#+begin_src emacs-lisp
  ;; Make windmove work in org-mode:
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src
** Commands
*** org-archive-done-tasks
將標記為 *DONE* 的結點收錄到 archive 裡。
#+begin_src emacs-lisp
  (defun org-archive-done-tasks ()
    "Make all DONE subtree to archive."
    (interactive)
    (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+end_src
*** coldnew/org-up-parent
跑到目前節點的父節點，並收起目前的結點。
#+begin_src emacs-lisp
  (defun coldnew/org-up-parent ()
    "Move to the parent of current point. If current is the parent heading,
            move to the previous parent heading."
    (interactive)
    (if (not (org-on-heading-p))
        (outline-back-to-heading)
      (let* ((level (funcall outline-level))
             (point-to-move-to
              (save-excursion
                (outline-previous-visible-heading 1)
                (while (>= (funcall outline-level) level)
                  (outline-previous-visible-heading 1))
                (point))))
        (if point-to-move-to
            (goto-char point-to-move-to))))
    (org-cycle))
#+end_src
*** coldnew/org-down-children
跑到目前節點的子節點，並展開子節點。
#+begin_src emacs-lisp
  (defun coldnew/org-down-children ()
    "Move to children of current heading. If current heading only has subtree,
          expand the subtree."
    (interactive)
    (outline-back-to-heading)
    (show-children)
    (let* ((level (funcall outline-level))
           (point-to-move-to
            (save-excursion
              (outline-next-visible-heading 1)
              (if (<= (funcall outline-level) level)
                  nil
                        (point)))))
              (if point-to-move-to
                  (goto-char point-to-move-to)
                (show-subtree))))
#+end_src
** 輸出成 PDF 檔案設定

#+BEGIN_SRC emacs-lisp
  (require 'ox-latex)
#+END_SRC

*** 使用 minted 將程式碼加上色彩

#+begin_src emacs-lisp :tangle no
  (require 'org-latex)
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-export-latex-listings 'minted)
  (setq org-export-latex-minted-options
        '(("frame" "lines")
          ("fontsize" "\\scriptsize")))
#+end_src

*** 使用 xelatex 產生 PDF 檔案

當系統有安裝 latexmk 時，使用 latexmk 呼叫 xelatex 進行編譯，
反之則直接呼叫 xelatex 進行二次編譯。
#+begin_src emacs-lisp
  (setq org-latex-pdf-process
        (if (executable-find "latexmk")
            '("latexmk -pdflatex=xelatex -pdf -silent --shell-escape -f %f")
          '("xelatex -interaction nonstopmode --shell-escape %f"
            "xelatex -interaction nonstopmode --shell-escape %f")))
#+end_src

*** 一般文章所使用的 latex 配置

#+begin_src emacs-lisp :tangle no
  (add-to-list 'org-latex-classes
               '("coldnew-article"
                 "\\documentclass[12pt,a4paper]{article}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{fontspec}
                  \\usepackage{xeCJK}
                  \\setCJKmainfont{Hiragino Sans GB W3}
                  \\XeTeXlinebreaklocale \"zh\"
                  \\XeTeXlinebreakskip = 0pt plus 1pt
                  \\xeCJKsetup{CJKglue=\hspace{0pt plus .08 \baselineskip }}
                  \\usepackage{graphicx}
                  \\usepackage{tikz}
                  \\usepackage[bookmarks=true,colorlinks,urlcolor=blue]{hyperref}
                  \\defaultfontfeatures{Mapping=tex-text}
                  \\setmonofont[Scale=0.8]{DejaVu Sans Mono}
                  \\usepackage{geometry}
                  \\usepackage{minted}
                  \\usemintedstyle{emacs}
                  \\geometry{a4paper, textwidth=6.5in, textheight=8in,
                              marginparsep=10pt, marginparwidth=.6in}
                  \\pagestyle{plain}
                  \\linespread{1.5}
                  \\title{}
                        [NO-DEFAULT-PACKAGES]
                        [NO-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))
#+end_src

*** 投影片所使用的 latex 配置

#+begin_src emacs-lisp
;;\\xeCJKsetup{CJKglue=\hspace{0pt plus .08 baselineskip }}
  (add-to-list 'org-latex-classes
               ;; beamer class, for presentations
               '("beamer"
                 "\\documentclass\[presentation\]\{beamer\}
                  \\usepackage[utf8]{inputenc}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{xeCJK}
                  \\setCJKmainfont{Hiragino Sans GB W3}
                  \\XeTeXlinebreaklocale \"zh\"
                  \\XeTeXlinebreakskip = 0pt plus 1pt
                  \\usepackage{minted}
                  \\usemintedstyle{emacs}
                  \\setmainfont{Monaco}
                  \\usepackage{hyperref}
                  \\usepackage{color}
                  \\usepackage{verbatim}
                  \\usepackage{upquote}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\begin{frame}[fragile]\\frametitle{%s}"
                  "\\end{frame}"
                  "\\begin{frame}[fragile]\\frametitle{%s}"
                  "\\end{frame}")))
#+end_src

** 網頁輸出設定

*** 不要在輸出的網頁上面加上 Validate 字樣

預設的 org-mode 會在輸出的網頁尾巴加上 Validate 字樣，看起來很討厭，
這裡將他移除。

#+BEGIN_SRC emacs-lisp
  (setq org-html-validation-link nil)
#+END_SRC

** major-mode-expand

#+BEGIN_SRC emacs-lisp
  (setq org-mode-expand-alist
        '(("t" . org-insert-export-options-template)
          ))
#+END_SRC

** screenshot

#+BEGIN_SRC emacs-lisp
  (require 'org-screenshot)
#+END_SRC

* 書籤與暫存器                                                     :bookmark:
** Config
#+begin_src emacs-lisp
;;  (setq bookmark-default-file emacs-bookmark-file)
  (setq bookmark-default-file (concat emacs-cache-dir "bookmarks"))
#+end_src

#+begin_src emacs-lisp
  (require 'bm)
#+end_src

* 編輯器                                                             :editor:

** 宣告寫程式、文學用的 mode list

- 定義寫程式用的 mode

  emacs 有一些 major 無法和 font-lock-add-keywords 相處融洽，
  會倒置整個緩衝區的顏色不見，因此最好的方式是定義要加入新的
  關鍵字上色用的 major-mode，或者說，這些 mode 是要用來寫程式的。

  #+begin_src emacs-lisp
    (defvar coldnew/programming-mode
      '(emacs-lisp-mode

        ;; lisp
        lisp-interaction-mode lisp-mode
        clojure-mode clojurescript-mode scheme-mode
        common-lisp-mode newlisp-mode

        ;; C/C++ like
        c-mode c++-mode objc-mode
        csharp-mode  d-mode
        java-mode jde-mode

        ;; Web
        html-mode javascript-mode js2-mode

        ;; script
        sh-mode python-mode ruby-mode cperl-mode

        ;; others
        erlang-mode sgml-mode qml-mode
        slime-mode haskell-mode tuareg-mode lua-mode
        pascal-mode fortran-mode prolog-mode asm-mode
        sml-mode
        )
      "Major mode for programming languages")
  #+end_src

- 定義寫文章的 mode

  #+begin_src emacs-lisp
    (defvar coldnew/literacture-mode
      '(org-mode text-mode latex-mode)
      "Major mode that i will use for writting")
  #+end_src

** TODO 替數字額外上色

vim 預設也會對數字進行別的上色動作。
ref: https://github.com/patriciogonzalezvivo/dot-emacs/blob/master/live-fontify-hex.el

#+begin_src emacs-lisp
  (dolist (mode coldnew/programming-mode)
    ;; (font-lock-add-keywords mode
    ;;  '(
    ;;    ;; hexadecimal
    ;;    ("\\b\\(0[00-9a-fA-F]+\\)" 1 font-lock-constant-face)
    ;;    ;; float
    ;;    ("\\b\\([+-]?[0-9]+\\.[0-9]+\\)" 1 font-lock-constant-face)
    ;;    ;; int
    ;;    ("[\`^(\{\[,\+\-\*/\%=\s-]\\(-?[0-9]+U?L?L?\\)" 1 font-lock-constant-face)

    (font-lock-add-keywords
     mode '(
            ("\\b\\(0x[0-9a-fA-F]+\\)" 1 font-lock-constant-face) ; hexa
            ("\\b\\(-?[0-9]+\\.[0-9]+\\(d\\|f\\)?\\)" 1
             font-lock-constant-face) ; float
            ("[\`^\(){\[,\+\\-\\*/\%><=\s-]\\(-?[0-9]+U?L?L?\\)" 1
             font-lock-constant-face) ; int
            )))
#+end_src

** 在寫文件或是程式註解時自動填滿行寬

- 在寫文章的時候啟用 auto-fill-mode

  #+begin_src emacs-lisp
    (dolist (mode coldnew/literacture-mode)
      (let ((hook (intern (concat (symbol-name mode) "-hook"))))
        (add-hook hook
                  (lambda ()
                    (auto-fill-mode 1)))))
  #+end_src


- 在寫程式時只在註解啟用 auto-fill-mode

  #+begin_src emacs-lisp
    (dolist (mode coldnew/programming-mode)
      (let ((hook (intern (concat (symbol-name mode) "-hook"))))
        (add-hook hook
                  (lambda ()
                    (auto-fill-mode 1)
                    (set (make-local-variable 'fill-nobreak-predicate)
                         (lambda ()
                           (not (eq (get-text-property (point) 'face)
                                    'font-lock-comment-face))))))))
  #+end_src

** 加入 Doxygen 支援

Doxygen 是一套非常棒的註解產生文件的程式，emacs 底下有 doxymacs, 可以
將 doxygen 的語法進行上色的動作。

#+begin_src emacs-lisp
  (add-hook 'coldnew-editor-mode-hook
            '(lambda ()
               (when (require 'doxymacs nil 'noerror)
                 (doxymacs-mode))))
#+end_src

** 加上貪婪刪除功能                                               :hungry@delete:

一般使用 backspace 都只刪除一個字元，hungry-delete 這個套件
加入了貪婪刪除功能，可以刪除前面一堆的空白字元。

#+begin_src emacs-lisp
  (add-hook 'coldnew-editor-mode-hook
            '(lambda ()
               (when (require 'hungry-delete nil 'noerror)
                 (turn-on-hungry-delete-mode))))
#+end_src

** TODO remember
*** electric-pair-mode
#+begin_src emacs-lisp
  (electric-pair-mode 1)
  ;; setting for auto-close brackets for electric-pair-mode regardless of current major mode syntax table
  (setq electric-pair-pairs '(
                              (?\" . ?\")
                              (?\{ . ?\})
                              ) )
#+end_src
#+begin_src emacs-lisp
  (setq fill-column      100 ) ; column beyond which automatic line-wrapping shold happen
  (setq kill-ring-max    3000 ) ; Maximum lenght of kill-ring
  (setq next-line-add-newlines t ) ;
  (setq shift-select-mode      t ) ; Enable shift-select mode

  ;; Enable delete-selection-mode
  (delete-selection-mode t)
#+end_src
* 編輯器按鍵設置

這邊是我定義的 coldnew-editor-mode 的按鍵設定，每個類型的標條都會附註這裏面的
按鍵是 Normal, Insert 或是其他模式下才會有的按鍵。

** 按鍵巨集錄製/播放 (N) (I)

| 按鍵  | 命令                       | 用途              |
|-------+----------------------------+-------------------|
| C-x q | toggle-kbd-macro-recording | 錄製/停止鍵盤巨集 |
| C-x e | call-last-kbd-macro        | 播放最後一個巨集  |
| C-.   | repeat                     | 重複上一個命令    |

#+begin_src emacs-lisp
    (vim:mode-map coldnew-editor-map (kbd "C-x q") 'toggle-kbd-macro-recording)
    (vim:mode-map coldnew-editor-map (kbd "C-x e") 'call-last-kbd-macro)
    (vim:mode-map coldnew-editor-map (kbd "C-.")   'repeat)
#+end_src

** 檔案相關 (N) (I)


| 按鍵 | 命令              | 用途                        |
|------+-------------------+-----------------------------|
| M-o  | coldnew/helm-mini | 使用自訂的 helm-mini 找檔案 |

#+begin_src emacs-lisp
  (eval-after-load 'helm
    '(progn
       (vim:mode-map coldnew-editor-map (kbd "M-o")
                     '(lambda ()
                        "coldnew's helm-mini"
                        (interactive)
                        (helm-other-buffer
                         '(helm-source-ls-git
                           helm-source-locate
                           helm-c-source-buffers-list
                           helm-c-source-recentf
                           helm-c-source-buffer-not-found)
                         "*coldnew helm mini*")))
       ))
#+end_src

** 緩衝區編輯 (I)

| 按鍵     | 命令                   | 用途         |
|----------+------------------------+--------------|
| C-d      | hyngry-delete-forward  | 向右貪婪刪除 |
| C-l      | hyngry-delete-backward | 向左貪婪刪除 |
| <delete> | hyngry-delete-backward | 向左貪婪刪除 |

#+begin_src emacs-lisp
  (eval-after-load 'hungry-delete
    '(progn
       (vim:mode-imap coldnew-editor-map (kbd "C-d") 'hungry-delete-forward)
       (vim:mode-imap coldnew-editor-map (kbd "C-l") 'hungry-delete-backward)
       (vim:mode-imap coldnew-editor-map (kbd "<delete>") 'hungry-delete-backward)))
  #+end_src

| 按鍵    | 用途         |
|---------+--------------|
| C-c C-h | 快速代碼折疊 |

#+begin_src emacs-lisp
  (vim:mode-imap coldnew-editor-map (kbd "C-c C-h")
                 '(lambda ()
                    ""
                    (interactive)
                    (set-selective-display
                     (if selective-display nil 1))))
#+end_src

** org-mode 相關按鍵

和 org-mode 相關的全域按鍵都整理到這裡

| 按鍵  | 命令           | 用途                         |
|-------+----------------+------------------------------|
| C-c a | org-agenda     | 呼叫 org-mode agenda 命令    |
| C-c l | org-store-link | 儲存目前游標位置作為連結使用 |
| C-c c | org-capture    |                              |

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-editor-map (kbd "C-c a")  'org-agenda)
  (vim:mode-imap coldnew-editor-map (kbd "C-c l")  'org-store-link)
  (vim:mode-imap coldnew-editor-map (kbd "C-c c")  'org-capture)
#+END_SRC

* Cedet                                                                :cedet:
#+begin_src emacs-lisp
  ;; Maintain tag database
  (global-semanticdb-minor-mode 1)
  ;; Reparse buffer when idle
  (global-semantic-idle-scheduler-mode 1)
  ;; Show completions when idle
  (global-semantic-idle-completions-mode 1)
  ;; Provide `switch-to-buffer'-like keybinding for tag names.
  (global-semantic-mru-bookmark-mode 1)
  ;; Show summary of tag at point
  (global-semantic-idle-summary-mode 1)
  ;;;; Disable
  ;; Highlight the current tag.
  (global-semantic-highlight-func-mode -1)
  ;; Show current fun in header line
  (global-semantic-stickyfunc-mode -1)
  ;; Additional tag decorations
  (global-semantic-decoration-mode -1)

  (set-default 'semantic-case-fold t)
#+end_src

* 程式開發                                                         :language:

各種不同程式語言開發用的設定。

** C/C++ 通用設定

C/C++ 語言基本上很多設定都沒有差，因此將通用的設定寫在這邊。

*** 縮排 #ifdef 語句

#+begin_src emacs-lisp :tangle no
  (defun cc-mode:indent-preprocessor ()
    "Indent #ifdef ... #else ... #endf region as if ... else ... statement.
      This code is based on ppindent.el

      Note: you must (require 's) to use this code."
    (let ((result
           (catch 'err
             (save-excursion
               (let* ((cnt 0)
                      (file-ext (file-name-extension (buffer-file-name (current-buffer))))
                      (header-p (or (string= "h" file-ext) (string= "hpp" file-ext))))
                 (flet ((make-space (x) (if (< x 0) "" (make-string x ?\s))))
                   (goto-char (point-min))
                   ;; We decrease cnt when this buffer is headerfile
                   (if header-p (decf cnt c-basic-offset))

                   (while (re-search-forward "^[ \t]*#[ \t]*\\(.*\\)" nil t)
                     (cond ((s-starts-with? "if" (match-string-no-properties 1))
                            (replace-match (concat (make-space cnt) "#\\1"))
                            (incf cnt c-basic-offset))
                           ((s-starts-with? "el" (match-string-no-properties 1))
                            (replace-match (concat (make-space (- cnt c-basic-offset)) "#\\1")))
                           ((s-starts-with? "endif" (match-string-no-properties 1))
                            (decf cnt c-basic-offset)
                            (replace-match (concat (make-space cnt) "#\\1")))
                           (t
                            (replace-match (concat (make-space cnt) "#\\1"))))))
                 )))))
      (when result
        (goto-line (car result))
        (error "Error: %s" (cadr result)))))

  (defun cc-mode:indent-preprocessor-check-pair ()
    "Check for #ifdef ... #endif pairs."
    (let ((result
           (catch 'err
             (save-excursion
               (let* ((cnt 0))
                 (goto-char (point-min))
                 (while (re-search-forward "^[ \t]*#[ \t]*\\(.*\\)" nil t)
                   (cond ((s-starts-with? "if" (match-string-no-properties 1))
                          (incf cnt c-basic-offset))
                         ((s-starts-with? "el" (match-string-no-properties 1))
                          (when (< (- cnt c-basic-offset) 0)
                            (throw 'err `(,(line-number-at-pos) "Unmatched #else or #elif"))))
                         ((s-starts-with? "endif" (match-string-no-properties 1))
                          (when (< (- cnt c-basic-offset) 0)
                            (throw 'err `(,(line-number-at-pos) "Unmatched #endif")))
                          (decf cnt c-basic-offset))
                         )))))))
      (when result
        (goto-line (car result))
        (error "Error: %s" (cadr result)))))

  ;; Advice th indent-region function
  (defadvice indent-region (after indent-preprocessor activate)
    "Indent #ifdef ... #else ... #endif region as if ... else ... statement for c/c++ mode."
    (let ((buffer-major-mode (with-current-buffer (current-buffer) major-mode)))
      (if (or (eq major-mode 'c-mode)
              (eq major-mode 'c++-mode))
          (progn
            (cc-mode:indent-preprocessor)
            (cc-mode:indent-preprocessor-check-pair)))))

  #+end_src

* 聊天軟體                                                             :chat:
** IRC

*** Misc

#+begin_src emacs-lisp
  ;; check channels
  ;; exclude boring stuff from tracking

  ;; Interpret mIRC-style color commands in IRC chats
  (setq erc-interpret-mirc-color t)
  ;; The following are commented out by default, but users of other
  ;; non-Emacs IRC clients might find them useful.
  ;; Kill buffers for channels after /part
  (setq erc-kill-buffer-on-part t)
  ;; Kill buffers for private queries after quitting the server
  (setq erc-kill-queries-on-quit t)
  ;; Kill buffers for server messages after quitting the server
  (setq erc-kill-server-buffer-on-quit t)
  ;; open query buffers in the current window
  (setq erc-query-display 'buffer)
  (setq erc-save-buffer-on-part t)
  (defadvice save-buffers-kill-emacs (before save-logs (arg) activate)
    (save-some-buffers t (lambda () (when (eq major-mode 'erc-mode) t))))
  ;; enable spell checking
  (erc-spelling-mode 0)
  ;; autoaway setup
  (setq erc-auto-discard-away t)
  (setq erc-autoaway-idle-seconds 600)
  (setq erc-autoaway-use-emacs-idle t)
#+end_src

* TODO 全域性按鍵設置                                            :global@key:
** 關閉預設的按鍵設定

關閉部份按鍵設定，在後面重新設定他。
#+begin_src emacs-lisp
  (global-unset-key (kbd "C-r"))
  (global-unset-key (kbd "C-x e"))
  (global-unset-key (kbd "C-x d"))
  (global-unset-key (kbd "C-x f"))
#+end_src


** Ctrl-r 暫存器、書籤、快速跳轉、矩型處理
預設的 C-r 其實是 isearch-backward, 這裡將他改掉。

| 按鍵           | 命令                       | 用途                                     |
|----------------+----------------------------+------------------------------------------|
| C-r s <char>   | copy-to-register           | 將區域(選擇)存入暫存器                   |
| C-r r <char>   | copy-rectangle-to-register | 將矩型區域存入暫存器                     |
| C-r i <char>   | insert-register            | 將暫存器內的東西插入                     |
| C-r SPC <char> | point-to-register          | 將檔案或是緩衝區位置存入暫存器           |
| C-r n          | cua-sequence-rectangel     | 對選取的矩型區域每行加入相對應的續列數字 |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-r j") 'jump-to-register)
  (global-set-key (kbd "C-r r") 'copy-rectangle-to-register)
  (global-set-key (kbd "C-r i") 'insert-register)
  (global-set-key (kbd "C-r <SPC>") 'point-to-register)
  (global-set-key (kbd "C-r n") 'cua-sequence-rectangle)
#+end_src

** Meta Prefix

#+begin_src emacs-lisp
  (global-set-key (kbd "M-.") 'helm-etags+-select)
#+end_src

* TODO ----------------- Following are re-write ---------------------------------
* 按鍵設定                                                           :keymap:

** 將按鍵表格轉換成 HTML 表格以及 elisp

這個設定主要是針對按鍵設定而增加，我希望可以使用表格來管理並分類我不同
的 emacs 按鍵設定，參照了 [[http://steckerhalter.co.vu/steckemacs.html][steckemacs]] 的設定，增加一些特殊的程式碼來將
org-mode 的表格轉換成 emacs 的按鍵設定程式碼。

#+NAME: keys-doc
#+BEGIN_SRC emacs-lisp :var keys=global-keys :tangle no :results output raw :exports results
  (let* ((header (car keys))
         (keys (delq header keys))
         (category))
    (pop keys)
    (mapcar (lambda (l) (if (listp l)
                       (progn
                         (unless (string= (nth 0 l) category)
                           (setq category (nth 0 l))
                           (princ (format "*** %s\n" category))
                           (princ "#+ATTR_HTML: :rules all :cellpadding 4\n")
                           (princ "| / | <r> | | \n")
                           )
                         (princ (format "| # | =%s= | %s |\n" (nth 1 l) (nth 3 l))))
                     (princ "|-\n")))
            keys))
  (princ "\n")
#+END_SRC

為了可以更簡單的去定義我的按鍵，我使用以下的 emacs-lisp 去處理 org-mode 的
表格，並自動將表格在 org-mode 進行 tangle 的時候，將表格變成程式碼輸出到我
的 emacs 中。

#+NAME: gen-keys
#+BEGIN_SRC emacs-lisp :results output :tangle no :exports none :colnames nil
    (mapcar (lambda (l)
              (let* ((key (nth 0 l))
                     (def (format "%s (kbd \"%s\")" func key))
                     (command (nth 1 l)))
                (princ (format "(%s '%s)\n" def command))))
            ;; remove all `hline' tag first line in list
            (cdr (remove 'hline keys)))
#+END_SRC

#+NAME: gen-keys-global
#+BEGIN_SRC emacs-lisp :results output :tangle no :exports none :colnames nil
  (mapcar (lambda (l)
            (let* ((key (nth 1 l))
                   (def (format "%s (kbd \"%s\")" func key))
                   (command (nth 2 l)))
              (princ (format "(%s '%s)\n" def command))))
          ;; remove all `hline' tag first line in list
          (cdr (remove 'hline keys)))
#+END_SRC

大部分 minor-mode 都有自己的 keymap，但是有一些會有多種 keymap，因此我定義
這部份的程式來避免一個 minor 有太多表格。

#+NAME: gen-keys-map
#+BEGIN_SRC emacs-lisp :results output :tangle no :exports none :colnames nil
  (mapcar (lambda (l)
            (let* ((kmap (nth 0 l))
                   (key (nth 1 l))
                   (def (format "%s %s-map (kbd \"%s\")" func kmap key))
                   (command (nth 2 l)))
              (princ (format "(%s '%s)\n" def command))))
          ;; remove all `hline' tag first line in list
          (cdr (remove 'hline keys)))
#+END_SRC

#+NAME: gen-keys-map2
#+BEGIN_SRC emacs-lisp :results output :tangle no :exports none :colnames nil
  (mapcar (lambda (l)
            (let* ((key (nth 0 l))
                   (def (format "define-key %s-map (kbd \"%s\")" map key))
                   (command (nth 1 l)))
              (princ (format "(%s '%s)\n" def command))))
          ;; remove all `hline' tag first line in list
          (cdr (remove 'hline keys)))
#+END_SRC

#+NAME: gen-keys-evil
#+BEGIN_SRC emacs-lisp :results output :tangle no :exports none :colnames nil
  (mapcar (lambda (l)
            (let* ((key (nth 0 l))
                   (def (format "define-key evil-%s-state-map (kbd \"%s\")" state key))
                   (command (nth 1 l)))
              (princ (format "(%s '%s)\n" def command))))
          ;; remove all `hline' tag first line in list
          (cdr (remove 'hline keys)))
#+END_SRC

** 全域性按鍵設定 (global-set-key) :noexport:

#+TBLNAME: global-keys
| 類別     | 按鍵    | 命令                         | 描述                               |
|----------+---------+------------------------------+------------------------------------|
| 文字編輯 | s-<RET> | insert-empty-line            | 插入空白行                         |
| 文字編輯 | C-l     | backward-delete-char         | 向前刪除字元                       |
| 文字編輯 | M-l     | backward-delete-word         | 向前刪除詞                         |
| 緩衝區   | C-x C-b | ibuffer                      | 切換到 ibuffer                     |
| 資料夾   | C-x C-d | dired                        | 切換到 dired                       |
| 視窗切換 | C-x F   | fullscreen-window            | 將視窗切換成全螢幕                 |
| 視窗切換 | M-[     | winner-undo                  | 回復上一個窗口佈局                 |
| 視窗切換 | M-]     | winner-redo                  | 切回上一組進行窗口復原時的窗口佈局 |
| 暫存器   | C-x rj  | jump-to-register             | 跳轉到暫存的檔案或是緩衝區位置     |
| 尋找取代 | M-s     | helm-occur                   | 使用 helm-occur 來進行尋找         |
| 版本管理 | C-x vl  | magit-log                    | 查看 git log                       |
| 版本管理 | C-x vs  | magit-status                 | 查看目前的 git status              |
| 版本管理 | C-x vc  | magit-checkout               | 切換到其他的 git branch            |
| 版本管理 | C-x vp  | magit-push                   | push 到遠端的 repo                 |
| 版本管理 | C-x vf  | magit-gitflow-feature-start  | 使用 git-flow 建立新的特色分支     |
| 版本管理 | C-x vF  | magit-gitflow-feature-finish | 使用 git-flow 結束新的特色分支     |
| 版本管理 | C-x vh  | magit-gitflow-hotfix-start   | 使用 git-flow 建立新的 hotfix 分支 |
| 版本管理 | C-x vH  | magit-gitflow-hotfix-finish  | 使用 git-flow 結束新的 hotfix 分支 |
| 文字編輯 | C-=     | increase-emacs-font-size     | 放大緩衝區的文字大小               |
| 文字編輯 | C--     | decrease-emacs-font-size     | 縮小緩衝區的文字大小               |
| 快速命令 | <f1>    | woman                        | 使用 woman 查看 man 手冊           |
| 快速命令 | <f2>    | shell-pop                    | 彈出 eshell 視窗                   |
| 快速命令 | M-`     | woman                        | 使用 woman 查看 man 手冊           |
| 快速命令 | M-1     | deft-or-close                | 開啟/關閉 deft-mode                |
| 快速命令 | M-2     | multi-eshell                 | 切換至完整的 eshell 視窗           |
| 快速命令 | M-3     | multi-eshell-switch          | 切換目前已打開的 eshell 視窗       |
| 快速命令 | M-4     | erc-start-or-switch          | 啟動或切換到 IRC 緩衝區            |
| 字體調整 | C-=     | increase-emacs-font-size     | 放大字體                           |
| 字體調整 | C--     | decrease-emacs-font-size     | 縮小字體                           |
| 檔案相關 | C-x C-f | lusty-file-explorer          | 查詢並打開檔案                     |
| 檔案相關 | C-x C-s | save-buffer-always           | 儲存檔案                           |
| 檔案相關 | C-x C-r | lusty-sudo-explorer          | 使用 sudo 打開檔案                 |
| 檔案相關 | C-x fx  | set-file-executable          | 為目前檔案加上可執行權限           |
| 檔案相關 | C-x fc  | clone-file-and-open          | 複製目前檔案到其他檔案並打開       |
| 檔案相關 | C-x fd  | delete-file-and-buffer       | 刪除目前的檔案與緩衝區             |
| 緩衝區   | C-x M-4 | erc-iswitchb                 | 切換到 IRC 緩衝區                  |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
  <<gen-keys-global(func="global-set-key", keys=global-keys)>>
#+END_SRC

** Vim 一般模式按鍵設定 <Normal>                                   :noexport:

#+TBLNAME: global-evil-normal
| 按鍵  | 命令                     | 描述                                  |
|-------+--------------------------+---------------------------------------|
| C-n   | evil-next-line           | 下一行                                |
| C-p   | evil-previous-line       | 上一行                                |
| <SPC> | ace-jump-mode            | 使用 ace-jump-mode 快速跳轉到符合的字 |
| M-u   | upcase-word              | 將整個英文字大寫                      |
| M-l   | downcase-word            | 將整個英文字小寫                      |
| M-c   | capitalize-word          | 將英文字字首大寫                      |
| j     | next-line                | 下一行                                |
| k     | previous-line            | 上一行                                |
| M-n   | scroll-other-window      | 瀏覽另外一個視窗的下一頁              |
| M-p   | scroll-other-window-down | 瀏覽另外一個視窗的上一頁              |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
  <<gen-keys-evil(state="normal", keys=global-evil-normal)>>
#+END_SRC

** Vim 編輯模式按鍵設定 <Insert>                                   :noexport:

#+TBLNAME: global-evil-insert
| 按鍵    | 命令                             | 描述                               |
|---------+----------------------------------+------------------------------------|
| C-;     | iedit-mode                       | 使用 iedit-mode 快速修改同樣的字詞 |
| M-v     | er/expand-region                 | 快速選取游標下的文字、區域         |
| C-x C-p | auto-complete                    | 呼叫 auto-complete-mode 的自動補全 |
| C-/     | undo-tree-undo                   | undo                               |
| M-/     | undo-tree-redo                   | redo                               |
| C-x C-n | company-complete                 | 呼叫 company-mode 的自動補全       |
| C-c C-e | eval-and-replace                 | eval emacs-lisp 命令               |
| C-x l   | hl-line-mode                     | 將游標目前行加上彩色條             |
| C-x L   | linum-mode                       | 切換顯示行號                       |
| C-x C-y | yank-n-times                     | 多次貼上                           |
| C-x C-l | recenter                         | 將游標至於緩衝區中間               |
| C-x C-i | indent-whole-buffer              | 縮排整個緩衝區                     |
| C-x C-q | toggle-read-only                 | 切換緩衝區變成唯讀/可寫的狀況      |
| C-M-,   | beginning-of-buffer              | 回到緩衝區開頭                     |
| C-M-.   | end-of-buffer                    | 回到緩衝區尾巴                     |
| M-<SPC> | insert-U200B-char                | 插入 <U200B> 字元                  |
| s-<SPC> | insert-U200B-char                | 插入 <U200B> 字元                  |
| M-r     | ~rotate-weindow/query-replace    | 旋轉切換視窗/尋找並取代            |
| C-v     | ~cua-set-mark/cua-rectangle-mark | 選取區域/選取矩形區域              |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
  <<gen-keys-evil(state="insert", keys=global-evil-insert)>>
#+END_SRC
