#+TITLE: coldnew 的 emacs 配置
#+AUTHOR: Yen-Chin, Lee <coldnew>
#+email: coldnew.tw at gmail.com
#+STARTUP: overview indent align
#+PROPERTY: noweb tangle
#+OPTIONS: ^:nil
#+INFOJS_OPT: view:info toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

* 關於這份檔案

用了 emacs 至今已有 6年了，最初我的 emacs 配置也是英文版，並且分散了許多檔案，
直到我知道了 org-mode 以及所謂的文學編程，我二話不說就將我的 emacs 設定移植到
org-mode 上面，並重新改寫用中文來寫配置的說明。

在這 6年的時間裡，用 emacs 學 emacs 以及配置 emacs 花費了我不少時間，網路上
太多太多中文的配置都是複製貼上複製貼上，連用途都不懂就轉用了別人的文章放到
自己的部若格上，讓我剛開始學 emacs 查找資料時有許多困擾， <待續>

* 基礎設置                                                             :base:

這邊放置的是 *初始化* 的設定，為了避免設定衝突，部份 Macro 和 Function 會放置於此。

** 預先載入 cl 套件。

#+begin_src emacs-lisp
  (eval-when-compile (require 'cl))
#+end_src

** 資料夾相關變數設定                                             :variable:

這邊設定了各種類型資料夾的路徑。

*** emacs 設定檔預設所在的資料夾

#+begin_src emacs-lisp
  (defconst emacs-dir "~/.emacs.d/"
    "The top-level emacs-configure directory.")
#+end_src

*** 佈景主題的資料夾設定

#+begin_src emacs-lisp
  (defconst emacs-themes-dir (concat emacs-dir "themes/")
    "directory to place emacs theme.")
#+end_src

*** el-get 安裝套件的路徑

#+begin_src emacs-lisp
  (defconst emacs-lisp-dir   (concat emacs-dir "lisp/")
    "directory to place lisp packages from internet.")
#+end_src

*** el-get 的 recipes 路徑

#+begin_src emacs-lisp
  (defconst emacs-recipes-dir (concat emacs-dir "recipes/")
    "directory to place local el-get recepies.")
#+end_src

*** elpa 安裝套件的路徑

#+begin_src emacs-lisp
  (defconst emacs-elpa-dir   (concat emacs-lisp-dir "elpa/")
    "directory to place ELPA lisp packages from internet.")
#+end_src

*** yasnippet 使用的 snippet 路徑

#+begin_src emacs-lisp
  (defconst emacs-snippets-dir (concat emacs-dir "snippets/")
    "directory to place yasnippet files.")
#+end_src

*** 放置 binary 檔案的資料夾

#+begin_src emacs-lisp
  (defconst emacs-bin-dir    (concat emacs-dir "bin/")
    "directory to place binary staff.")
#+end_src

*** 放置 cache 等暫存檔案的資料夾

#+begin_src emacs-lisp
  (defconst emacs-cache-dir  (concat emacs-dir "cache/")
    "cache file directory.")
#+end_src

*** 備份文件的資料夾

#+begin_src emacs-lisp
  (defconst emacs-backup-dir (concat emacs-dir "backup/")
    "directory to backup files.")
#+end_src

*** 放置紀錄的資料夾

#+begin_src emacs-lisp
  (defconst emacs-log-dir (concat emacs-dir "log/")
    "log file directory.")
#+end_src

*** 放置 jar 等其他文件的位置

#+begin_src emacs-lisp
  (defconst emacs-etc-dir (concat emacs-dir "etc/")
    "etc file directory.")
#+end_src

** 檔案相關變數設定                                               :variable:

這邊設定了各種檔案的路徑。

*** emacs 個人配置的檔案，也就是這個檔案

#+begin_src emacs-lisp
  (defconst emacs-config-file (concat emacs-dir "config.org")
    "File to place emacs configs.")
#+end_src

*** 客制化設定檔的位置

#+begin_src emacs-lisp
  (defconst emacs-custom-file (concat emacs-dir "custom.el")
    "store customize UI config.")
#+end_src

*** emacs-authinfo-file

#+begin_src emacs-lisp
  (defconst emacs-authinfo-file (concat emacs-dir ".authinfo.gpg")
    "file that save secret")
#+end_src

*** emacs-bookmark-file

#+begin_src emacs-lisp
  (defconst emacs-bookmark-file (concat emacs-cache-dir "bookmarks")
    "File to save bookmarks")
#+end_src

** 作業系統測試

放置用於測試目前 emacs 執行在何種作業系統上的變數。

*** MacOS X
#+begin_src emacs-lisp
  (defvar mac-p     (eq system-type 'darwin)
    "Return nil if OS is not Mac.")
#+end_src

*** Linux

#+begin_src emacs-lisp
  ;; linux device
  (defvar linux-p   (and (eq system-type 'gnu/linux) (not (eq system-type 'drawin)))
    "Return nil if OS is not Linux.")

  ;; linux 32-bit
  (defvar linux-32bit-p (and (string-match
                              (rx (or bos "x86-" bos "i686-")) system-configuration) linux-p)
    "Return nil if OS is not 32-bit linux.")

  ;; linux 64-bit
  (defvar linux-64bit-p (and (string-match (rx bos "x86_64") system-configuration) linux-p)
    "Return nil if OS is not 64-bit linux.")
#+end_src

*** Cygwin

#+begin_src emacs-lisp
  (defvar cygwin-p  (eq system-type 'cygwin)
    "Return nil if OS is not CygWin.")
#+end_src

*** Window$

#+begin_src emacs-lisp
  (defvar windows-p (eq system-type 'windows-nt)
    "Return nil if OS is not Windows.")
#+end_src

** 螢幕解析度測試                                               :resolution:

放置測試螢幕解析度用的變數

#+begin_src emacs-lisp
  ;; 1280x800
  (defvar display-1280x800-p   (and (= (display-pixel-width) 1280)
                                    (= (display-pixel-height) 800))
    "Return nil if current display's resolution is not 1280x800")

  ;; 1280x1024
  (defvar display-1280x1024-p  (and (= (display-pixel-width) 1280)
                                    (= (display-pixel-height) 1024))
    "Return nil if current display's resolution is not 1280x1024")

  ;; 1920x1080
  (defvar display-1920x1080-p  (and (= (display-pixel-width) 1920)
                                    (= (display-pixel-height) 1080))
    "Return nil if current display's resolution is not 1920x1080")
#+end_src

*** TODO Shell
#+begin_src emacs-lisp
  (defvar emacs-default-shell "/bin/bash"
    "Default shell for cemacs.")
  (defvar emacs-popup-shell-window-height 30
    "Window hight of popup shell.")
  (defvar emacs-popup-shell-window-position "bottom"
    "Make popup shell window at buttom by default.")
#+end_src

#+RESULTS:
: emacs-popup-shell-window-position

*** TODO Path
#+begin_src emacs-lisp
  ;; TODO: make it work on every platform, now only has Linux support
  (setenv "PATH"
          (concat
           emacs-bin-dir ":"
           "~/.lein/bin" ":"
           (getenv "PATH")
           ))

  (setq exec-path (cons emacs-bin-dir exec-path))
#+end_src

*** TODO Remember to remove
#+begin_src emacs-lisp
  (defun change-mouse-to-left ()
    (interactive)
    (shell-command "xmodmap -e \"pointer = 3 2 1\""))

  (defun change-mouse-to-right ()
    (interactive)
    (shell-command "xmodmap -e \"pointer = 1 2 3\""))

  (defun swap-ctrl-caps ()
    "swap control and capslock"
    (interactive)
    (shell-command "setxkbmap -option ctrl:swapcaps"))

  (defun make-caps-as-ctrl ()
    "make capslock as control-key"
    (interactive)
    (shell-command "setxkbmap -option ctrl:nocaps"))

  ;; only disable capslock and make it as control
  (cond ((eq window-system 'x)
         ;; make caps lock a control key
         (make-caps-as-ctrl)
         (change-mouse-to-left)))
#+end_src

*** TODO Face
#+begin_src emacs-lisp
  (defface mode-line-read-only-face
    '((t (:foreground "#C82829" :bold t)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface mode-line-modified-face
    '((t (:inherit 'font-lock-function-name-face :bolt t)))
    "face for mode-name-string in modeline."
    :group'mode-line)

  (defface mode-line-mode-name-face
    '((t (:inherit font-lock-keyword-face)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface mode-line-normal-state-face
    '((t (:inherit font-lock-function-name-face)))
    "face for emacs normal state"
    :group 'mode-line)

  (defface font-lock-escape-char-face
    '((((class color)) (:foreground "seagreen2")))
    "highlight c escapes char like vim"
    :group 'font-lock-faces)

  (defface mode-line-evil-state-string-N
    '((t (:inherit font-lock-function-name-face)))
    "face for vim-string in normal-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-I
    '((t (:inherit font-lock-constant-face)))
    "face for vim-string in insert-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-V
    '((t (:inherit font-lock-variable-name-face)))
    "face for vim-string in visual-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-E
    '((t (:inherit font-lock-string-face)))
    "face for vim-string in emacs-map on mode-line."
    :group 'mode-line)
#+end_src

** 使用者介面設定

關閉一些 emacs 預設的 UI 設定。

*** 不啟用 startup message

啟動 emacs 時會出現的 GNU/Emacs 畫面，這裡將他關閉
#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

*** 清空 **scratch** buffer 的文字。

預設 **scratch** 裡面會有幾行文字，直接將他清空。
#+begin_src emacs-lisp
  (setq initial-scratch-message "")
#+end_src

*** 關閉蜂鳴器

使用畫面閃爍代替電腦的蜂鳴器叫聲。
#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

*** 關閉工具列

不顯示工具列。
#+begin_src emacs-lisp
  (if (featurep 'tool-bar) (tool-bar-mode -1))
#+end_src

*** 關閉滾動條

關閉左側或右側的滾動條 (scrool-bar)。
#+begin_src emacs-lisp
  (if (featurep 'scroll-bar) (scroll-bar-mode -1))
#+end_src

*** 關閉游標閃爍

不允許游標閃爍。
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

*** 關閉選單列

不顯示選單列
#+begin_src emacs-lisp
  (if (featurep 'menu-bar) (menu-bar-mode -1))
#+end_src

*** TODO Time Stamp
#+begin_src emacs-lisp
  (setq time-stamp-active      t ) ; do enable time-stamps
  (setq time-stamp-line-limit 10 ) ; check first 10 buffer lines for Time-stamp:
  (setq time-stamp-format "%04y-%02m-%02d %02H:%02M:%02S (%u)") ; date format
#+end_src

*** 回答問題時，使用 *y* 和 *n* 代替 *yes/no* 。

預設要使用 *yse* 或是 *no* 來回答問題，這裡將他改成用 *y* 或 *n* 。
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** TODO Misc

#+begin_src emacs-lisp
  ;; TODO: add comment
  (setq stack-trace-on-error t)
  (setq imenu-auto-scan t)
  ;;(setq redisplay-dont-pause t)

  ;; xrelated srtting
  (setq x-select-enable-clipboard t)
  (setq select-active-regions t)
  (setq x-gtk-use-system-tooltips nil)    ; disable gtk-tooltip

  (setq max-lisp-eval-depth '40000)
  (setq max-specpdl-size 1000)  ; default is 1000, reduce the backtrace level
  (setq debug-on-error t)    ; now you should get a backtrace
#+end_src

#+begin_src emacs-lisp
  ;; nice scrolling
  (setq scroll-margin                   0 )
  (setq scroll-conservatively      100000 )
  (setq scroll-preserve-screen-position 1 )
  (setq scroll-up-aggressively       0.01 )
  (setq scroll-down-aggressively     0.01 )
#+end_src

** 設定 custom-file 到其他檔案

避免使用 *customize-UI* 時，會將設定寫入我的 init.el
#+begin_src emacs-lisp
  (setq custom-file emacs-custom-file)
#+end_src

** Daemon

當啟用 emacs 時，啟動 emacs-server，如果使用者是 root 或已啟用 server，則忽略。
#+begin_src emacs-lisp
  ;; Only start server mode if I'm not root
  (unless (string-equal "root" (getenv "USER"))
    (require 'server)
    (unless (server-running-p) (server-start)))
#+end_src

** 根據目前螢幕的解析度調整 emacs 視窗的大小。                  :resolution:

整個設定是使用 cond 來進行條件式的判斷，因此加入了 *設定起始位置* 和 *設定終止位置*
作為保護。
*** 設定起始位置
#+begin_src emacs-lisp
  (cond
#+end_src
*** 1920x1080
#+begin_src emacs-lisp
  (display-1920x1080-p
   (setq default-frame-alist
         (append (list
                  '(width  . 134)
                  '(height . 45)
                  '(top    . 90)
                  '(left   . 500))
                 default-frame-alist)))
#+end_src
*** 1280x1024
#+begin_src emacs-lisp
  (display-1280x1024-p
   (setq default-frame-alist
         (append (list
                  '(width  . 114)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 300))
                 default-frame-alist)))
#+end_src
*** 1280x800
#+begin_src emacs-lisp
  (display-1280x800-p
   (setq default-frame-alist
         (append (list
                  '(width  . 114)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 300))
                 default-frame-alist)))
#+end_src
*** 預設情況
#+begin_src emacs-lisp
  (t
   (setq default-frame-alist
         (append (list
                  '(width  . 100)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 100))
                 default-frame-alist)))
#+end_src
*** 設定終止位置
#+begin_src emacs-lisp
  )
#+end_src
* 語言與編碼                                                         :locale:

emacs 編碼設定，大部份都設定成 utf-8。

** 系統編碼。

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8 )
#+end_src

** 語言環境。

#+begin_src emacs-lisp
  (set-language-environment 'utf-8 )
#+end_src

** 文件保存時的編碼設置

#+begin_src emacs-lisp
  (set-buffer-file-coding-system 'utf-8 )
#+end_src

** 鍵盤編碼設定

#+begin_src emacs-lisp
  (set-keyboard-coding-system    'utf-8 )
#+end_src

** 設定終端機的編碼

#+begin_src emacs-lisp
  (set-terminal-coding-system    'utf-8 )
#+end_src

** 選擇區域內編碼

#+begin_src emacs-lisp
  (set-selection-coding-system   'utf-8 )
#+end_src

** 剪貼簿編碼設定

#+begin_src emacs-lisp
  (set-clipboard-coding-system   'utf-8 )
#+end_src

** 使用 utf-8 編碼顯示文件名

#+begin_src emacs-lisp
  (set-file-name-coding-system   'utf-8 )
#+end_src

** 設定時間顯示使用英文

時間顯示中文還是怪怪的，所以這邊設定成英文

#+begin_src emacs-lisp
  (setq system-time-locale "en_US" )
#+end_src

* 套件管理                                                          :package:

emacs 在 24 版後終於有自己的套件管理器 ELPA ，不過有些外部的套件沒
辦法透過他來安裝，所以我又使用了另外一個非常好用的套件管理器 el-get,
透過這兩個套件管理器，在 emacs 下安裝軟體是非常方便的。

** el-get
*** 設定 el-get-dir

我不喜歡 el-get 預設使用 el-get 目錄，這裡根據我的 emacs-lisp-dir 重新設定。
#+begin_src emacs-lisp
  (setq-default el-get-dir emacs-lisp-dir)
#+end_src

*** 如果 el-get 不存在的話，重新安裝 el-get

曾經有手殘不小心砍掉我整個 lisp 資料夾，因此特別加了這個 function 來進行
保護，如果 el-get 不存在，則重新安裝他。

#+begin_src emacs-lisp
      (unless (require 'el-get nil t)
        (setq el-get-install-branch "master")
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
          (end-of-buffer)
          (eval-print-last-sexp)))
#+end_src

*** 如果 elpa 的 recepies 不存在的話，自動建立他。

第一次下載 el-get 的時候，並不會自動建立 elpa 的 recipes, 這邊進行檢查，
若 elpa 的 recipes 不存在，則自動建立他。

#+begin_src emacs-lisp
  (unless (file-exists-p el-get-recipe-path-elpa)
    (el-get-elpa-build-local-recipes))
#+end_src

*** 將我的 recipes 加入 el-get-recipe-path

el-get 雖然好用，但是還是有一些 recipes 沒有，所以我自己維護另外
一份 recipes。

#+begin_src emacs-lisp
  (add-to-list 'el-get-recipe-path emacs-recipes-dir)
#+end_src

*** 設定 el-get 的 recipes 預設使用 emacs-list-mode

\\.rcp$ 為 el-get 的 recipes 副檔名。

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rcp$" . emacs-lisp-mode))
#+end_src

** ELPA                                                               :elpa:
*** 設定 elpa 安裝目錄到 emacs-elpa-dir

#+begin_src emacs-lisp
  (setq-default package-user-dir emacs-elpa-dir)
  (require 'package)
#+end_src

*** 添加我需要的庫到 ELPA 裏面

#+begin_src emacs-lisp
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (add-to-list 'package-archives '("ELPA" . "http://tromey.com/elpa/") t)
  (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/") t)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
#+end_src

** 套件檢查

為了避免有套件因為 *意外* 而不見，對套件進行檢查，若不存在則進行重新安裝的動作。
*注意* ：進行套件檢查時，必須確認 el-get 已經安裝至 emacs 裡面，否則會產生錯誤。

*** 存放套件資訊的變數

此變數用於存放系統裏面必須安裝的 emacs 套件。
#+begin_src emacs-lisp
   (defvar emacs-packages-list nil
     "A list of packages to ensure are installed at launch.")
#+end_src

*** 存放套件資訊的檔案

此檔案用於將 emacs-packags-list 暫存。
#+begin_src emacs-lisp
  (defvar emacs-packages-file
    (concat emacs-dir "pkglist.el")
    "Define where to store and read the installed packages list.")
#+end_src

*** 從硬碟中讀取檔案

#+begin_src emacs-lisp
  (defun emacs-packages-read-from-file ()
    "Read from emacs-packages-file and set the contents to emacs-packages-list."
    (when (file-exists-p emacs-packages-file)
      (setq emacs-packages-list
            (car
             (with-temp-buffer emacs-packages-file
                               (insert-file-contents-literally emacs-packages-file)
                               ;; if emacs-packages-file is an empty file
                               ;; return nil, else return buffer-string
                               (if (= 0 (buffer-size (current-buffer)))
                                   nil
                                 (read-from-string (buffer-string))
                                 ))))))

  ;; read installed packages info from file
  (emacs-packages-read-from-file)
#+end_src

*** 將套件資訊寫入到檔案

#+begin_src emacs-lisp
  (defun emacs-packages-write-to-file ()
    "Write emasc-packages-list to files."
    (with-temp-file emacs-packages-file
      (let ((l emacs-packages-list))
        (setq emacs-packages-list (sort l #'string-lessp))
        (insert (format "%s\n" "("))
        (dolist (pkg emacs-packages-list)
          (insert (format "\"%s\"\n" pkg)))
        (insert ")"))))
#+end_src

*** 當安裝新的套件時，更新套件資訊

#+begin_src emacs-lisp
  (defun emacs-packages-install (pkg)
    (unless (stringp pkg)
      (setq pkg (symbol-name pkg)))
    (add-to-list 'emacs-packages-list pkg)
    (emacs-packages-write-to-file))

  ;; add to hooks
  (add-hook 'el-get-post-install-hooks 'emacs-packages-install)
#+end_src

*** 當移除套件時，更新套件資訊

#+begin_src emacs-lisp
  (defun emacs-packages-remove (pkg)
    (setq emacs-packages-list (remove pkg emacs-packages-list))
    (emacs-packages-write-to-file))

  ;; add to hooks
  (add-hook 'el-get-post-remove-hooks 'emacs-packages-remove)
#+end_src

*** 檢查套件是否有在 emacs-packages-list 裡

#+begin_src emacs-lisp
  (defun emacs-packages-installed-p ()
    (loop for p in emacs-packages-list
          when (not (el-get-package-is-installed p)) do (return nil)
          finally (return t)))
#+end_src

*** 套件檢查，不存在則重新安裝

當發現有套件存在 emacs-package-list 裡面，但是卻被 emacs-packages-installed-p 回報為
此套件不存在時，重新安裝此套件。

#+begin_src emacs-lisp
  (defun emacs-packages-install-packages ()
    (unless (emacs-packages-installed-p)
      ;; install missing packages
      (dolist (p emacs-packages-list)
        (unless (el-get-package-is-installed p)
          (el-get-reinstall p)))))

  ;; install missing packages
  (emacs-packages-install-packages)
#+end_src

* 巨集                                                                :macro:
** Clojure
*** comment

comment 只是用來註釋用，並不會解析裏面的東西。

:  (comment "I am comment.")

#+begin_src emacs-lisp
  (defmacro comment (&rest body)
    "Comment out one or more s-expressions."
    nil)
#+end_src

*** ->
#+begin_src emacs-lisp
  (defmacro -> (x &optional form &rest more)
    (cond ((not (null more))
           `(-> (-> ,x ,form) ,@more))
          ((not (null form))
           (if (sequencep form)
               `(,(first form) ,x ,@(rest form))
             (list form x)))
          (t x)))
#+end_src
*** ->>
#+begin_src emacs-lisp
  (defmacro ->> (x form &rest more)
    (cond ((not (null more)) `(->> (->> ,x ,form) ,@more))
          (t (if (sequencep form)
                 `(,(first form) ,@(rest form) ,x)
               (list form x)))))
#+end_src
*** -?>
#+begin_src emacs-lisp
  (defmacro -?> (x form &rest more)
    (cond ((not (null more)) `(-?> (-?> ,x ,form) ,@more))
          (t (if (sequencep form)
                 `(if (null ,x) nil
                    (,(first form) ,x ,@(rest form)))
               `(if (null ,x) nil
                  ,(list form x))))))
#+end_src
*** -?>>
#+begin_src emacs-lisp
  (defmacro -?>> (x form &rest more)
    (cond ((not (null more)) `(-?>> (-?>> ,x ,form) ,@more))
          (t (if (sequencep form)
                 `(if (null ,x) nil
                    (,(first form) ,@(rest form) ,x))
               `(if (null ,x) nil
                  ,(list form x))))))
#+end_src
*** if-not
#+begin_src emacs-lisp
  (defmacro if-not (test then &optional else)
    "Evaluates test. If logical false, evaluates and returns then expr,
    otherwise else expr, if supplied, else nil."
    `(if (not ,test) ,then ,else))
#+end_src

** Scheme
*** define
#+begin_src emacs-lisp
  (defmacro define (what &rest rest)
    "Scheme-like alias to defvar/defun"
    (if (consp what)
        `(defun  ,(car what) ,(cdr what) ,@rest)
      `(defvar ,what ,@rest)))
  ;; Syntaxes:
  ;;  (define varname opt-defaultvalue "opt-docscring"
  ;;  (define (fname arg1 arg2...) "opt-docstring" (interactive) (stmt1) ...)
#+end_src
** Other
*** defclosure
#+begin_example
  (defclosure counter (&optional increment)
    "Iseless and bizar counter"
    ((one 0)
     (two 1))
    (incf two (incf one (or increment two))))

(counter) => 2
(counter) => 5
#+end_example

#+begin_src emacs-lisp
  (defmacro defclosure (name arglist docstring bindings &rest body)
    "Define NAME as a closure.

          DOCSTRING is *not* optional.
          BINDINGS is an alist of lexical bindings.
          The definition is (lambda ARGLIST DOCSTRING BODY...)."
    (declare (indent defun))
    `(lexical-let (,@bindings)
       (defun ,name (,@arglist)
         ,docstring
         ,@body)))
#+end_src
*** safe
ref: http://curiousprogrammer.wordpress.com/2009/06/08/error-handling-in-emacs-lisp/
#+begin_src emacs-lisp
  (defmacro safe-wrap (fn &rest clean-up)
    `(unwind-protect
         (let (retval)
           (condition-case ex
               (setq retval (progn ,fn))
             ('error
              (message (format "Caught exception: [%s]" ex))
              (setq retval (cons 'exception (list ex)))))
           retval)
       ,@clean-up))
#+end_src
* 常用的模組/函式庫                                                 :library:

emacs 有一些套件本身不需要配置，或是只是函式庫，這一類的套件我設
定為預先載入，這樣在後面的設定裏面我就可以直接使用這些套件的功能。

** 內建套件

有一些內建套件沒有預設載入，這邊將其載入使用。

#+begin_src emacs-lisp
  (require 'misc)
  (require 'cc-mode)
#+end_src

iimage 是讓 emacs 可以直接顯示圖片的模式。

#+begin_src emacs-lisp
  (require 'iimage)
#+end_src

** 輸出成 html 檔案

htmlize 是 emacs 一個非常好用的模組，可以讓 emacs 輸出檔案成為
HTML 檔， org-mode 輸出成 html 時也是使用他。

#+begin_src emacs-lisp
  (require 'htmlize)
#+end_src

** 顯示 ascii 表

ascii 是一個很不錯的 ascii 表顯示工具，你可以使用 ascii-on 來啟用
, 他會告訴你目前游標所在位置的 ASCII 碼，使用 ascii-off 可以關閉
ascii-mode。

#+begin_src emacs-lisp
  (require 'ascii)
#+end_src

** 縮短網址

smallurl 是一個很棒的短網址工具，他會幫你到遠端的 server 取得短網址。

#+begin_src emacs-lisp
  (require 'smallurl)
#+end_src

** 快速更改相同的英文字

我們有時候會希望可以快尋尋找某個字，並用新的文字來取代他， iedit-mode
就是做這種事情的好幫手，先將游標停在要尋找取代的文字上，並輸入
M-x iedit-mode 接著就會發現到同個緩衝區裏面所有和游標底下的文字相同的
文字都被標記起來，試著更改看看，你會發現到這些文字同時被更改了。

#+begin_src emacs-lisp
  (require 'iedit)
#+end_src

** TODO 其他
#+begin_src emacs-lisp
  (require 'rainbow-mode)
  (require 'ace-jump-mode)
  (require 'smarter-compile)
  (require 'unicad)
  (require 'expand-region)
  (require 'pretty-lambdada)
  (require 'rainbow-delimiters)
#+end_src

smart-tab 會幫你決定使用 yasnippet 或是 tab
#+begin_src emacs-lisp
  (require 'smart-tab)
  (global-smart-tab-mode 1)
#+end_src

* Function                                                         :function:
我所自定義或是我的 emacs 設定檔需要用到的 function。
** List Processing

處理 List 所用的 function。

*** flatten a list

flatten a list 是一種方法，可以用來將巢狀的 list 變成單一個 list。
舉例來說，假如目前有這樣一個 list:

#+begin_example
(1 (2 3) (4 (5 6 (7))) 8 9)
#+end_example

則使用 flatten 這個 function 可以將上面的巢狀 list 變成:

#+begin_example
(1 2 3 4 5 6 7 8 9)
#+end_example

#+begin_src emacs-lisp
  (defun flatten (structure)
    "Flatten the nesting in an arbitrary list of values."
    (cond ((null structure) nil)
          ((atom structure) `(,structure))
          (t (mapcan #'flatten structure))))
#+end_src

*** List to string

將一個 list 變成字串回傳。

#+begin_src emacs-lisp
  (defun list-to-string (char-list)
    "RETURN: A new string containing the characters in char-list."
    (let ((result (make-string (length char-list) 0))
          (i 0))
      (dolist (char char-list)
        (aset result i char)
        (setq i (1+ i)))
      result))
#+end_src

** Search

搜尋相關的 function。

*** search-backward-to-char

向後搜尋一個字元。
#+begin_src emacs-lisp
  (defun search-backward-to-char (chr)
    "Search backwards to a character"
    (while (not (= (char-after) chr))
      (backward-char 1)))
#+end_src

*** search-forward-to-char

向前搜尋一個字元。
#+begin_src emacs-lisp
  (defun search-forward-to-char (chr)
    "Search forwards to a character"
    (while (not (= (char-before) chr))
      (forward-char 1)))
#+end_src

*** recursive-find-file

遞迴尋找檔案，若在當前目錄找不到此檔案，則去其父目錄進行尋找。
如果該檔案或是目錄不存在，則回傳 nil.
#+begin_src emacs-lisp
  (defun coldnew/recursive-find-file (file &optional directory)
    "Find the first FILE in DIRECTORY or it's parents.
  If file does not exist return nil."
    (let ((directory (or directory
                         (file-name-directory (buffer-file-name))
                         (pwd))))
      (if (file-exists-p (expand-file-name file directory))
          (expand-file-name file directory)
        (unless (string= "/" directory)
          (coldnew/recursive-find-file file (expand-file-name ".." directory))))))
#+end_src

** Testing

測試用的 function，和測試用的變數很像，但是他允許參數的輸入。
*** font-exist-p

測試這個字體在系統內是否存在。
#+begin_src emacs-lisp
  (defun font-exist-p (fontname)
    "test if this font is exist or not."
    (if (not (x-list-fonts fontname))
        nil t))
#+end_src

** File
*** filesize
#+begin_src emacs-lisp
  (defun file-size (filename)
    "Return the size in bytes of file named FILENAME, as in integer.
  Returns nil if no such file."
    (nth 7 (file-attributes filename)))
#+end_src
** Convert

進行轉換用的 function。
*** 將輸入的 buffer (DOS 格式)　轉換成 UNIX 格式。　
#+begin_src emacs-lisp
  (defun dos->unix (buf)
    "Convert buffer file from dos file to unix file."
    (let* (current-buf (current-buffer))
      (if (not (eq current-buf buf))
          (switch-to-buffer buf))
      (goto-char(point-min))
      (while (search-forward "\r" nil t) (replace-match ""))))
#+end_src
*** 將輸入的 buffer (UNIX 格式)　轉換成 DOS 格式。　
#+begin_src emacs-lisp
  (defun unix->dos (buf)
    "Convert buffer file from unix file to dos file."
    (let* (current-buf (current-buffer))
      (if (not (eq current-buf buf))
          (switch-to-buffer buf))
      (goto-char(point-min))
      (while (search-forward "\n" nil t) (replace-match "\r\n"))))
#+end_src
*** 將檔案變成字串，此 function 比較適用於該檔案只有一行（或少數幾行）的情況。
#+begin_src emacs-lisp
  (defun file->string (file)
    "Convert file to string in buffer with quote."
    (when (file-readable-p file)
      (with-temp-buffer
        (insert-file-contents file)
        (buffer-string))))
#+end_src
*** 十進位轉換成十六進位
#+begin_src emacs-lisp
  (defun dec->hex (decimal)
    "Convert decimal to hexdecimal number."
    (let ((hexstr))
      (if (stringp decimal)
          (setq decimal (string-to-number decimal 16)))
      (cond
       ;; Use #x as hex prefix (elisp, ....)
       ((or (eq major-mode 'emacs-lisp-mode)
            (eq major-mode 'lisp-interaction-mode)) (setq hexstr "#x"))
       ;; Use # as hex prefix (CSS, ....)
       ((eq major-mode 'css-mode) (setq hexstr "#"))
       ;; otherwise use 0x as hexprefix (C, Perl...)
       (t (setq hexstr "0x")))
      (format "%s%02X" hexstr decimal)))
#+end_src
*** 十六進位轉換成十進位
#+begin_src emacs-lisp
  (defun hex->dec (hex)
    "Convert hexdecimal number or string to digit-number."
    (let ((case-fold-search nil)
          (hex-regexp (rx (or
                           ;; elisp
                           (group bol "#x")
                           ;; C perl
                           (group bol "0x")
                           ;; CSS
                           (group bol "#")))))
      (if (not (stringp hex))
          (setq hex (symbol-name hex)))
      (string-to-number
       (replace-regexp-in-string hex-regexp "" hex)
       16)))
#+end_src
** Sort
*** quicksort
#+begin_src emacs-lisp
  (defun quicksort (lst)
    "Implement the quicksort algorithm."
    (if (null lst) nil
      (let* ((spl (car lst))
             (rst (cdr lst))
             (smalp (lambda (x)
                      (< x spl))))
        (append (quicksort (remove-if-not smalp rst))
                (list spl)
                (quicksort (remove-if smalp rst))))))
#+end_src
** Buffer
*** get-buffers-matching-mode
取得 major-mode 和要求符合的所有 buffer，假如我們希望可以列出所有為
emacs-lisp-mode 的 buffer，可以這樣做
#+begin_src emacs-lisp :tangle no
  (get-buffers-matching-mode 'emacs-lisp-mode)
#+end_src

#+begin_src emacs-lisp
  (defun get-buffers-matching-mode (mode)
    "Returns a list of buffers where their major-mode is equal to MODE"
    (let ((buffer-mode-matches '()))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (if (eq mode major-mode)
              (add-to-list 'buffer-mode-matches buf))))
      buffer-mode-matches))
#+end_src
*** show-buffer-major-mode
顯示 buffer 目前所處於的 major-mode

#+begin_src emacs-lisp :tangle no
  (show-buffer-major-mode "*scratch*")
#+end_src

#+begin_src emacs-lisp
  (defun show-buffer-major-mode (buffer-or-string)
    "Returns the major mode associated with a buffer."
    (with-current-buffer buffer-or-string major-mode))
#+end_src
** System
和系統相關的 function。
*** get-ip-address
取得目前的 IP 位置，預設為 eth0。（此 function 不能用於 windows 上）
#+begin_src emacs-lisp
  (defun get-ip-address (&optional dev)
    "get the IP-address for device DEV (default: eth0)"
    (let ((dev (if dev dev "eth0")))
      (format-network-address (car (network-interface-info dev)) t)))
#+end_src
** Date
#+begin_src emacs-lisp
  (defun current-date-time ()
    "return current date in `%Y-%m-%d' format, ex:`2012-04-25'."
    (let ((system-time-locale "en_US")
          (format "%Y-%m-%d"))
      (format-time-string "%Y-%m-%d")))

  (defun day-of-week (year month day)
    "Returns the day of the week as an integer.
     Monday is 1."
    (nth 6 (decode-time (encode-time 0 0 0 day month year))))

  (defun day-of-week-in-string (year month day)
    "Return the day of the week as day name."
    (let* ((day-names '("Sunday" "Monday" "Tuesday" "Wednesday"
                        "Thursday" "Friday" "Saturday"))
           (day-index (nth 6 (decode-time (encode-time 0 0 0 day month year)))))
      (nth day-index day-names)))
#+end_src
** other
#+begin_src emacs-lisp
  (defun map-define-key (mode-map keylist fname)
    "Like define-key but the key arg is a list that should be mapped over.
     For example: (map-define-key '(a b c d) 'function-name)."
    (mapc (lambda (k) (define-key mode-map k fname))
          keylist))

  (defun emacs-process-p (pid)
    "If pid is the process ID of an emacs process, return t, else nil.
  Also returns nil if pid is nil."
    (when pid
      (let ((attributes (process-attributes pid)) (cmd))
        (dolist (attr attributes)
          (if (string= "comm" (car attr))
              (setq cmd (cdr attr))))
        (if (and cmd (or (string= "emacs" cmd) (string= "emacs.exe" cmd))) t))))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Region
  ;;;; ---------------------------------------------------------------------------
  (defun select-region-to-before-match (match &optional dir)
    "Selects from point to the just before the first match of
  'match'.  The 'dir' controls direction, if nil or 'forwards then
  go forwards, if 'backwards go backwards."
    (let ((start (point))
          (end nil))

      (transient-mark-mode 1)    ;; Transient mark
      (push-mark)                ;; Mark the start, where point is now

      (if (or (null dir)
              (equalp 'forwards dir))

          ;; Move forwards to the next match then back off
          (progn
            (search-forward match)
            (backward-char))

        ;; Or search backwards and move forwards
        (progn
          (search-backward match)
          (forward-char)))

      ;; Store, then hilight
      (setq end (point))
      (exchange-point-and-mark)

      ;; And return, swap the start/end depending on direction we're going
      (if (or (null dir)
              (equalp 'forwards dir))
          (list start end)
        (list end start))))
#+end_src
* 字體                                                                 :font:
** 英文字體
#+begin_src emacs-lisp
  (defvar emacs-english-font "Monaco"
    "The font name of English.")
  (defvar emacs-english-font-size 11.5
    "Default English font size.")
#+end_src
** 中文字體
#+begin_src emacs-lisp
  (defvar emacs-cjk-font "Hiragino Sans GB W3"
    "The font name for CJK.")
  (defvar emacs-cjk-font-size 13.5
    "Default CJK font size.")
#+end_src
** 符號字體
*** TODO 不能使用，為什麼？
#+begin_src emacs-lisp
  (defvar emacs-symbol-font "Monaco"
    "The font name for Synbol.")
  (defvar emacs-symbol-font-size 16
    "Default Symbol font size.")
#+end_src
** 在圖形介面下使用我所設定的字體
#+begin_src emacs-lisp
  (cond ((eq window-system 'x)
         ;; Setting English Fonts
         (if (font-exist-p emacs-english-font)
             (set-frame-font (format "%s-%s" (eval emacs-english-font) (eval emacs-english-font-size))))

         ;; Setting Chinese Fonts
         (if (font-exist-p emacs-cjk-font)
             (set-fontset-font (frame-parameter nil 'font)
                               'han (format "%s-%s" (eval emacs-cjk-font) (eval emacs-cjk-font-size))))

         ;; Setting Symbol Fonts
         (if (font-exist-p emacs-symbol-font)
             (set-fontset-font (frame-parameter nil 'font)
                               'symbol (format "%s-%s" (eval emacs-symbol-font) (eval emacs-symbol-font-size))))
         ))
#+end_src
** 設定顯示字體時的格式
使用 *list-face-display* 可以看到所有的 face 顏色與字體。

#+begin_src emacs-lisp
  (setq list-faces-sample-text
        (concat
         "ABCDEFTHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz\n"
         "11223344556677889900       壹貳參肆伍陸柒捌玖零"
         ))
#+end_src
* 佈景主題                                                            :theme:

佈景主題的設置，包含我自訂的佈景主題以及路徑。
** 設定佈景主題的位置。
佈景主題的路徑設定在 emacs-themes-dir 裡面。
#+begin_src emacs-lisp
  (setq custom-theme-directory emacs-themes-dir)
#+end_src
** coldnew-night
我自己設計的暗色系佈景主題，會輸出成 ~/.emacs.d/themes/coldnew-night-theme.el

:PROPERTIES:
:comments: org
:tangle:   ~/.emacs.d/themes/coldnew-night-theme.el
:cache: yes
:padline: no
:END:

*** 標頭檔
#+begin_src emacs-lisp
  ;;; coldnew-night-theme.el --- Custom face theme for Emacs

  ;; Copyright (C) 2012 coldnew.

  ;; This file is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This file is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

  ;;; Code:
#+end_src

*** 初始化

#+begin_src emacs-lisp
  (deftheme coldnew-night
    "coldnew's dark theme.")

  (custom-theme-set-faces
   'coldnew-night
#+end_src

*** 背景與文字

設定 emacs 的背景和文字顏色
#+begin_src emacs-lisp
  '(default ((t (:background "#0B0B0E" :foreground "#DCDCDC"))))
#+end_src

*** 游標

設定 emacs 的游標顏色
#+begin_src emacs-lisp
  '(cursor ((t (:background "#C2C2C2" :foreground "#0B0B0E"))))
#+end_src

*** Region

設定選重區域的顏色
#+begin_src emacs-lisp
  '(region ((t (:background "#444444" :foreground "#DCDCDC"))))
#+end_src

*** Mode Line

#+begin_src emacs-lisp
  '(mode-line ((t (:background "#0C0C0C" :foreground "#B1C3D4"
                               :box (:line-width 2 :color "#B184CB")))))
  '(mode-line-inactive ((t (:background "#343434" :foreground "#7B8793"
                                        :box (:line-width 2 :color "#565968")))))
  '(mode-line-buffer-id ((t (:foreground "#CDCDCD":bold t :italic t))))
#+end_src

*** fringe

#+begin_src emacs-lisp
  '(fringe ((t (:background "#2A2A2A"))))
#+end_src

*** Minibuffer

#+begin_src emacs-lisp
  '(minibuffer-prompt ((t (:foreground "#E52210" :bold t))))
#+end_src

*** 關鍵字上色

#+begin_src emacs-lisp
  '(font-lock-builtin-face ((t (:foreground "#4BC98A"))))
  ;; Comment
  '(font-lock-comment-face ((t (:foreground "#5D9AE4" :italic t))))
  ;; Constant
  '(font-lock-constant-face ((t (:foreground "#E53F3F" :bold t))))
  ;; Function name
  '(font-lock-function-name-face ((t (:foreground "#AD7FA8" :italic t :bold t))))
  ;; Keyword
  '(font-lock-keyword-face ((t (:foreground "#FFC125"))))
  ;; String
  '(font-lock-string-face ((t (:foreground "#95E454" :italic t))))
  ;; Type
  '(font-lock-type-face ((t (:foreground "#CAE682"))))
  ;; Variable
  '(font-lock-variable-name-face ((t (:foreground "#4BC98A"))))
  ;; Warning
  '(font-lock-warning-face ((t (:foreground "#E91303" :bold t))))
  ;; Doc
  '(font-lock-doc-face ((t (:foreground "#40AAFA"))))
#+end_src

*** Auto-Complete

#+begin_src emacs-lisp
  '(ac-candidate-face ((t (:background "#424242" :foreground "white"))))
  '(ac-selection-face ((t (:background "#CAE682" :foreground "#0C0C0C"))))

#+end_src

*** org-mode

#+begin_src emacs-lisp
  '(org-date ((t (:foreground "#4D85FF" :bold t))))
  '(org-agenda-date ((t (:foreground "#8AC6F2"))))
  '(org-agenda-date-weekend ((t (:bold t :foreground "#E65C00" :weight bold))))
  '(org-hide ((t (:foreground "#0B0B0E"))))
  '(org-todo ((t (:foreground "#F43012" :bold t))))
  '(org-hide ((t (:foreground "#0B0B0E"))))
  '(org-done ((t (:foreground "#4BC98A" :bold t))))
  '(org-link   ((t (:inherit (link)))))
#+end_src

#+begin_src emacs-lisp
  '(org-level-1 ((t (:foreground "#8AC6F2" :bold t))))
  '(org-level-2 ((t (:foreground "#ee9a49"))))
  '(org-level-3 ((t (:foreground "#ff83fa"))))
  '(org-level-4 ((t (:foreground "#efe500"))))
  '(org-level-5 ((t (:foreground "#ff4040"))))
  '(org-level-6 ((t (:foreground "#afe04e"))))
  '(org-level-7 ((t (:foreground "#0A4C64"))))
#+end_src

*** lusty-explorer

#+begin_src emacs-lisp
  '(lusty-match-face ((t (:inherit font-lock-function-name-face))))
  '(lusty-directory-face ((t (:inherit font-lock-type-face))))
  '(lusty-file-face ((t (:inherit font-lock-string-face))))
#+end_src

*** magit

移除掉 diff-mode 時候的背景色彩。
#+begin_src emacs-lisp
  '(magit-item-highlight ((t (:background "#0B0B0E" ))))
#+end_src

設定 add 和 remove 的色彩
#+begin_src emacs-lisp
  '(magit-diff-add ((t (:inherit (diff-added)))))
  '(magit-diff-del ((t (:inherit (diff-removed)))))
#+end_src

設定 diff 時，比對兩個檔案位置的色彩
#+begin_src emacs-lisp
  '(magit-diff-hunk-header ((t (:inherit (diff-hunk-header)))))
#+end_src

*** woman

#+begin_src emacs-lisp
  '(woman-italic-face ((t (:slant italic :weight bold))))
  '(woman-unknown ((t (:foreground "#EA0000" :weight bold))))
  '(woman-addition ((t (:foreground "cadet blue"))))
  '(woman-bold ((t (:inherit bold :foreground "CadetBlue3"))))
#+end_src

*** rainbow-delimiters

#+begin_src emacs-lisp
  '(rainbow-delimiters-depth-1-face ((t (:foreground "green"))))
  '(rainbow-delimiters-depth-2-face ((t (:foreground  "yellow"))))
  '(rainbow-delimiters-depth-3-face ((t (:foreground  "blue"))))
  '(rainbow-delimiters-depth-4-face ((t (:foreground "purple"))))
  '(rainbow-delimiters-depth-5-face ((t (:foreground "orange"))))
  '(rainbow-delimiters-depth-6-face ((t (:foreground  "magenta"))))
  '(rainbow-delimiters-depth-7-face ((t (:foreground  "spring green"))))
  '(rainbow-delimiters-depth-8-face ((t (:foreground  "coral"))))
  '(rainbow-delimiters-depth-9-face ((t (:foreground  "dodger blue"))))
  '(rainbow-delimiters-depth-10-face ((t (:foreground "violet red"))))
  '(rainbow-delimiters-depth-11-face ((t (:foreground "DarkOrange1"))))
  '(rainbow-delimiters-depth-12-face ((t (:foreground "chartreuse2"))))
#+end_src

*** hl-line

#+begin_src emacs-lisp
  '(hl-line ((t :background "#CAE682" :foreground "#0C0C0C")))
#+end_src

*** diff

#+begin_src emacs-lisp
  '(diff-added ((t (:foreground "#95E454"))))
  '(diff-removed ((t (:foreground "#E52210"))))
  '(diff-header ((t (:background "#0B0B0E"))))
  '(diff-hunk-header ((t (:foreground "yellow"))))
  '(diff-function ((t :foreground "green")))
  '(diff-file-header ((t (:foreground "#9FCC23" :slant italic :weight bold))))
  '(diff-header ((t (:foreground "VioletRed1"))))

  '(diff-index ((t (:foreground "yellow"))))
  '(diff-context ((t (:inherit font-lock-comment))))
  '(diff-refine-change ((t (:background "#0B0B0E" :foreground "#DCDCDC"))))
#+end_src

*** Other

#+begin_src emacs-lisp
  ;; Link
  '(link ((t (:foreground "dodger blue" :underline t))))
  ;; '(link-visited ((t (:foreground "#8b008b" :underline t))))

   ;;;; Show Paren
  '(show-paren-match ((t (:background "#E65C00" :foreground "#CDCDCD" :bold t))))
  '(show-paren-mismatch ((t (:background "#0C0C0C" :foreground "#E91303" :bold t))))

   ;;;; isearch
  '(isearch ((t (:background "#F57900" :foreground "#7F6BFF"))))
  '(lazy-highlight ((t (:background "#E9B96E" :foreground "#7F6BFF"))))

   ;;;; Comint
  '(comint-highlight-prompt ((t (:foreground "#5D9AE4" :bold t))))

   ;;;; selection
  '(secondary-selection ((t (:background "#CAE682" :foreground "#0c0c0c"))))

   ;;;; cua
  '(cua-rectangle ((t (:background "#444444" :foreground "#DCDCDC"))))

   ;;;; iBuffer
  '(ibuffer-deletion ((t (:foreground "#dfaf8f" :weight bold))))
  '(ibuffer-help-buffer ((t (:inherit font-lock-comment))))
  '(ibuffer-marked ((t (:foreground "#f0dfaf" :weight bold))))
  '(ibuffer-special-buffer ((t (:inherit font-lock-doc))))

   ;;;; iBuffer-git
  '(ibuffer-git-add-face ((t (:inherit (diff-added)))))
  '(ibuffer-git-del-face ((t (:inherit (diff-removed)))))

   ;;;; ECB
  '(ecb-default-highlight-face ((t (:background "#CAE682" :foreground "#0C0C0C" :bold t))))

#+end_src
*** elscreen
#+begin_src emacs-lisp
  '(elscreen-tab-background-face ((t (:background "#272729" ))))
  '(elscreen-tab-control-face ((t (:foreground "white" :background "black" :weight extra-bold))))
  '(elscreen-tab-current-screen-face ((t (:background "#250628" :foreground "Gray90" :bold t))))
  '(elscreen-tab-other-screen-face ((t (:background "#1D1D1F" :foreground "Gray85" :bold t))))
#+end_src
*** End of File
#+begin_src emacs-lisp
  )

  (provide-theme 'coldnew-night)

  ;; Local Variables:
  ;; no-byte-compile: t
  ;; End:

  ;;; coldnew-night-theme.el  ends here
#+end_src

** 設定預設讀取的佈景主題。
#+begin_src emacs-lisp
  (load-theme 'coldnew-night t)
#+end_src
* Vim 摹擬                                                              :vim:

實在不能不佩服 vi 系列按鍵使用的高效率，將許多常用的巨集綁到一個按鍵上，
只要一個按鍵就可以呼叫，為了提升編輯效率，套用一些 Vim 的按鍵也是再所難免。

好用的 vim 快速鍵組合[fn:1]：

- d/foo[RET] 從目前的游標位置刪除到字串 foo
- dfa        從目前的游標位置刪除到字元 a，包含 a 本身
- cta        從目前的游標位置刪除到字元 a，不包含 a 本身
- viw        將目前游標所在的 "字" 選擇起來
- vfa        從目前的游標位置選擇到字元 a，包含 a 本身
- yi)        複製括號內的東西，不包含括號本身
- di"        刪除雙引號內的文字

[fn:1] [[http://dnquark.com/blog/2012/02/emacs-evil-ecumenicalism/][Emacs + Evil = ecumenicalism]]

** 載入相關套件

Evil 是 emacs 上最好用的 vim 摹擬程式。

#+begin_src emacs-lisp
  (require 'evil)
#+end_src

** 預設使用 Insert state

為什麼要預設使用 Insert 模式？我記得曾經我放棄過一次 evil-mode，因為切換到不同模式時，
他會跑到我不喜歡的 state，比如 Normal-state，這樣讓我感到很煩，每次到新的 mode 就要加他加入到
evil-mode 的變數，讓他知道這個 mode 預設是用什麼 state，煩死了。

直接統一用 insert 模式比較快 :)

#+begin_src emacs-lisp
  (setq evil-default-state 'insert)
#+end_src


#+begin_src emacs-lisp
  ;;  (setq evil-normal- nil)
  ;;  (setq evil-emacs-state nil)
  ;;  (setq evil-motion-state nil)

  ;;evil-motion-state-modes
#+end_src

** 將 Emacs 按鍵綁到 Insert 模式上

對我而言， Vim 的 Insert 模式是趨近於無用的，這邊將我的 Emacs 模式下的按鍵綁到
Insert 模式上，之後再來做其他設置。

#+begin_src emacs-lisp
  (setcdr evil-insert-state-map nil)
  (define-key evil-insert-state-map
    (read-kbd-macro evil-toggle-key) 'evil-emacs-state)
#+end_src

將 ESC 綁定成切換為 normal-state-map，因為我用自己的 emacs 按鍵綁定蓋掉了 evil-mode
裡面的 insert-state 按鍵綁定，所以這邊要先加入這個設定，才能夠用 ESC 來切換到
normal-state。

注意到除了 ESC 按鍵本身，使用 C-[ 也具有 ESC 按鍵的效果。

#+begin_src emacs-lisp
  (define-key evil-insert-state-map [escape] 'evil-normal-state)
#+end_src

** 全域性啟用 evil-mode

#+begin_src emacs-lisp
  (evil-mode t)
#+end_src

** 讓 evil-mode 的區域選擇方式和 Vim 相同

在 emacs 中，最後一個被選擇的字元是游標的前一個字元，但是在 vim 中，卻是在游標
下的那個字元。

若要使用和 vim 相同的方式，則要進行下面的設定:

#+begin_src emacs-lisp
  (setq evil-want-visual-char-semi-exclusive t)
#+end_src

** 綁定按鍵好用的巨集

我很喜歡以前用 vim-mode 時的按鍵定義方式，所以我定義了以下巨集來簡化
綁定按鍵的方法。

全域性的按鍵設置

- vim:nmap 綁定按鍵到 Normal 狀態下
- vim:imap 綁定按鍵到 Insert 狀態下
- vim:vmap 綁定按鍵到 Visual 狀態下
- vim:wmap 綁定按鍵到窗口切換的按鍵
- vim:map  綁定按鍵到 Normal, Insert 狀態下

使用方式：

: (vim:nmap (kbd "g") 'linum-ace-jump)

這樣在 Normal-state 時，按下 g 就可以呼叫 linum-ace-jump 這個命令。

#+begin_src emacs-lisp
  (defmacro vim:nmap (key cmd)
    "Binding keymap to evil-normal-state."
    `(define-key evil-normal-state-map ,key ,cmd))
  (defmacro vim:imap (key cmd)
    "Binding keymap to evil-insert-state."
    `(define-key evil-insert-state-map ,key ,cmd))
  (defmacro vim:vmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-visual-state-map ,key ,cmd))
  (defmacro vim:wmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-window-map ,key ,cmd))

  (defmacro vim:map (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-normal-state-map ,key ,cmd)
    `(define-key evil-insert-state-map ,key ,cmd))
#+end_src

區域性的按鍵設置

- vim:local-nmap 綁定按鍵到 Normal 狀態下，只作用於該緩衝區
- vim:local-imap 綁定按鍵到 Insert 狀態下，只作用於該緩衝區
- vim:local-vmap 綁定按鍵到 Visual 狀態下，只作用於該緩衝區

使用方式：

: (vim:local-nmap (kbd "g") 'linum-ace-jump)

這樣在目前的緩衝區時時， 切到 Normal-state，按下 g 就可以呼叫 linum-ace-jump 這個命令。

注意到這個是屬於 buffer-local 的設定方式，只會影響到該緩衝區，而不是影響整個 mode。

#+begin_src emacs-lisp
  (defmacro vim:local-nmap (key cmd)
    "Binding keymap to evil-normal-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
  (defmacro vim:local-imap (key cmd)
    "Binding keymap to evil-insert-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
  (defmacro vim:local-vmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
#+end_src

根據模式進行按鍵設置

- vim:mode-nmap 綁定按鍵到 Normal 狀態下，只作用於特定模式
- vim:mode-imap 綁定按鍵到 Insert 狀態下，只作用於特定模式
- vim:mode-vmap 綁定按鍵到 Visual 狀態下，只作用於特定模式

使用方式：

: (vim:mode-nmap emacs-lisp-mode-map (kbd "g") 'linum-ace-jump)

這樣在 emacs-lisp-mode 時， 切到 Normal-state，按下 g 就可以呼叫 linum-ace-jump 這個命令。

#+begin_src emacs-lisp
  (defmacro vim:mode-nmap (map key cmd)
    "Binding keymap to evil-normal-state."
    `(evil-define-key 'normal ,map ,key ,cmd))
  (defmacro vim:mode-imap (map key cmd)
    "Binding keymap to evil-insert-state."
    `(evil-define-key 'insert ,map ,key ,cmd))
  (defmacro vim:mode-vmap (map key cmd)
    "Binding keymap to evil-visual-state."
    `(evil-define-key 'visual ,map ,key ,cmd))
#+end_src

** 綁定 ex 命令的巨集

Vim 另外一個好用的東西是 ex 命令，這邊另外綁定 evil-ex-define-cmd。

#+begin_src emacs-lisp
  (defmacro vim:ex-cmd (cmd func)
    "Binding to evil-ex-define-cmd."
    `(evil-ex-define-cmd ,cmd ,func))
#+end_src

** Normal-state 按鍵設定

將一些非常慣用的 emacs 按鍵綁到 Normal-state 上面。

#+begin_src emacs-lisp
  (vim:nmap (kbd "C-n") 'evil-next-line)
  (vim:nmap (kbd "C-p") 'evil-previous-line)
#+end_src

| 按鍵 | 命令            | 用途             |
|------+-----------------+------------------|
| M-u  | upcase-word     | 將整個英文字大寫 |
| M-l  | downcase-word   | 將整個英文字小寫 |
| M-c  | capitalize-word | 將英文字字首大寫 |

#+begin_src emacs-lisp
  (vim:nmap (kbd "M-u") 'upcase-word)
  (vim:nmap (kbd "M-l") 'downcase-word)
  (vim:nmap (kbd "M-c") 'capitalize-word)
#+end_src

** Insert-state 按鍵設定

這邊設定我的 Insert-state 的按鍵，部份會和我原本的 emacs 按鍵設置不太一樣。

#+begin_src emacs-lisp
  (vim:imap (kbd "C-o") 'evil-execute-in-normal-state)
  (vim:imap (kbd "C-l") 'backward-delete-char)
#+end_src

* 自動補全                                                         :complete:
** 載入相關套件

#+begin_src emacs-lisp
  (require 'auto-complete)
  (require 'auto-complete-config)
  (require 'auto-complete-clang)
#+end_src

** 使用預設的設定。

#+begin_src emacs-lisp
  (ac-config-default)
#+end_src

** 不使用 fuzzy-match

#+begin_src emacs-lisp
  (setq ac-use-fuzzy nil)
#+end_src

** 不自動啟用自動補全

#+begin_src emacs-lisp
  (setq ac-auto-start nil)
#+end_src

** 加入我自定義的補全字典

#+begin_src emacs-lisp
  (add-to-list 'ac-dictionary-directories (concat emacs-dir "ac-dict"))
#+end_src

** 全域性使用自動補全

global-auto-complete-mode 這個 function 只具有切換全部 buffer 的自動補全功能，
若想要一開始就全部的 mode 都具有自動補全能力，則必須用個 dirty hack 才行。

#+begin_src emacs-lisp
  (define-globalized-minor-mode real-global-auto-complete-mode
    auto-complete-mode (lambda ()
                         (if (not (minibufferp (current-buffer)))
                             (auto-complete-mode 1))
                         ))
  (real-global-auto-complete-mode t)
#+end_src

** TODO 位分類
#+begin_src emacs-lisp
  ;; Ignore case if completion target string doesn't include upper characters
  (setq ac-ignore-case nil)

  ;; Enable auto-complete quick help
  (setq ac-use-quick-help t)

  ;; After 0.01 sec, show help window
  (setq ac-quick-help-delay 0.5)

  ;; Enable ac-comphist
  (setq ac-use-comphist t)

  ;; Setting ac-comphist data
  (setq ac-comphist-file (concat emacs-cache-dir "auto-complete.dat"))

  ;; Show menu
  (setq ac-auto-show-menu t)
  ;; Enable ac-menu-map
  (setq ac-use-menu-map t)
#+end_src
** 按鍵設定
auto-complete-mode 的按鍵設定。
#+begin_src emacs-lisp
  (define-key ac-menu-map (kbd "C-n") 'ac-next)
  (define-key ac-menu-map (kbd "C-p") 'ac-previous)
  (define-key ac-completing-map "\t" 'ac-complete)
  (define-key ac-complete-mode-map[tab] 'ac-expand)
#+end_src
* Mode
** elscreen                                                       :elscreen:
*** 載入相關模組

#+begin_src emacs-lisp
  (require 'elscreen)
#+end_src

*** 自動啟用 elscreen

#+begin_src emacs-lisp
  (elscreen-start)
#+end_src

*** 分頁上顯示 *控制* 圖示

#+begin_src emacs-lisp
  (setq elscreen-tab-display-control t)
#+end_src

*** 分頁上不顯示 *關閉* 圖示

#+begin_src emacs-lisp
  (setq elscreen-tab-display-kill-screen nil)
#+end_src

*** 功能強化

當目前只有一個 elscreen-tab 存在時，呼叫 *elscreen-next* 、 *elscreen-previous*
或是 *elscreen-toggle* 會自動建立另外一個 elscreen-tab。
#+begin_src emacs-lisp
  (defmacro elscreen-create-automatically (ad-do-it)
    (` (if (not (elscreen-one-screen-p))
           (, ad-do-it)
         (elscreen-create)
         (elscreen-notify-screen-modification 'force-immediately)
         (elscreen-message "New screen is automatically created"))))

  (defadvice elscreen-next (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))

  (defadvice elscreen-previous (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))

  (defadvice elscreen-toggle (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))
#+end_src

** lusty-explorer
*** 載入相關套件

#+begin_src emacs-lisp
  (require 'lusty-explorer)
#+end_src

*** 使用 <ENTER> 選擇目前的檔案

#+begin_src emacs-lisp
  (add-hook 'lusty-setup-hook
            '(lambda ()
               (define-key lusty-mode-map (kbd "RET") 'lusty-select-current-name)))
#+end_src

*** 讓 lusty-explorer 能夠使用 sudo 來打開檔案                    :command:

#+begin_src emacs-lisp
  (defun lusty-sudo-explorer ()
    "Launch the file/directory mode of LustyExplorer."
    (interactive)
    (let ((lusty--active-mode :file-explorer)
          (lusty-prompt "sudo: >>"))
      (lusty--define-mode-map)
      (let* ((lusty--ignored-extensions-regex
              (concat "\\(?:" (regexp-opt completion-ignored-extensions) "\\)$"))
             (minibuffer-local-filename-completion-map lusty-mode-map)
             (file
              (lusty--run 'read-file-name default-directory "")))
        (when file
          (switch-to-buffer
           (find-file-noselect (concat "/sudo:root@localhost:"
                                       (expand-file-name file))))))))
#+end_src

*** 讓 lusty-explorer 使用自己的補全方式，而不是 helm 的補全方式

當 helm-mode 載入完後，將和 lusty-explorer 相關的命令加入至 helm-completing-read-handlers-alist，
以避免 lusty-explorer 使用 helm-mode 提供的補全方法。
#+begin_src emacs-lisp
  (eval-after-load "helm-mode"
    '(progn
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-sudo-explorer . nil))
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-file-explorer . nil))
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-buffer-explorer . nil))))
#+end_src

** yasnippet                                                     :yasnippet:
*** 設定 snippet 所在的資料夾
#+begin_src emacs-lisp
  (setq-default yas/snippet-dirs emacs-snippets-dir)
#+end_src
*** 載入相關套件
#+begin_src emacs-lisp
  (require 'yasnippet)
  (require 'dropdown-list)
#+end_src
*** 初始化 yasnippet
#+begin_src emacs-lisp
  ;;  (yas/initialize)
  (yas-global-mode 1)
#+end_src
*** 設定 yasnippet 讀取 snippet 的資料夾
#+begin_src emacs-lisp
  (yas/load-directory emacs-snippets-dir)
#+end_src
*** 設定 yasnippet 提示用的 function
#+begin_src emacs-lisp
  (setq yas/prompt-functions '(yas/dropdown-prompt yas/ido-prompt yas/completing-prompt))
#+end_src
*** 增加類似 org-mode 那樣使用 < 進行補全的方法 (easy-template)
#+begin_src emacs-lisp
  (defadvice yas-expand (around coldnew/major-mode-expand activate)
    "Try to complete a structure template before point like org-mode does.
    This looks for strings like \"<e\" on an otherwise empty line and
    expands them.
    Before use this function, you muse setup `major-mode-name'-expand-alist variable.

    Take emacs-lisp-mode as example, if you wand to use <r to expand your snippet `require'
    in yasnippet, you muse setup the emacs-lisp-mode-expand-alist variable.

     (setq emacs-lisp-expand-alist '((\"r\" . \"require\")))"
    (let* ((l (buffer-substring (point-at-bol) (point)))
           (expand-symbol (intern (concat (symbol-name major-mode) "-expand-alist")))
           (expand-alist (if (boundp expand-symbol) (symbol-value expand-symbol) nil))
           a)
      (when (and (looking-at "[ \t]*$")
                 (string-match "^[ \t]*<\\([a-zA-Z]+\\)$" l)
                 (setq a (assoc (match-string 1 l) expand-alist)))
        (backward-delete-char (1+ (length (car-safe a))))
        (if (symbolp (cdr-safe a))
            (funcall (cdr-safe a))
          (insert (cdr-safe a)))
        t)
      ad-do-it
      ))
#+end_src
*** Functions
#+begin_src emacs-lisp
  (defun yas/dir ()
    (file-name-directory (buffer-file-name)))
  (defun yas/file ()
    (file-name-nondirectory (buffer-file-name)))
  (defun yas/file-sans ()
    (file-name-sans-extension (file-name-nondirectory (buffer-file-name))))
  (defun yas/file-ext ()
    (file-name-extension (file-name-nondirectory (buffer-file-name))))
  (defun yas/file-sans-upcase ()
    (upcase (yas/file-sans)))
  (defun yas/year ()
    (format-time-string "%Y"))
  (defun yas/user-name ()
    (insert user-full-name))
  (defun yas/login-name ()
    (insert user-login-name))
  (defun yas/user-email ()
    (insert user-mail-address))
  (defun yas/user-nickname ()
    (insert user-nickname))
#+end_src
** ibuffer                                                         :ibuffer:
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'ibuffer)
  (require 'ibuf-ext)
#+end_src
*** Config
#+begin_src emacs-lisp
  ;;;; Settings
  (setq ibuffer-always-compile-formats         t )
  (setq ibuffer-default-shrink-to-minimum-size t )
  (setq ibuffer-expert                         t )
  (setq ibuffer-show-empty-filter-groups     nil )
  (setq ibuffer-use-other-window             nil )
  (setq ibuffer-always-show-last-buffer      nil )
#+end_src
integrate ibuffer with git
#+begin_src emacs-lisp
  (require 'ibuffer-git)
  (setq ibuffer-formats
        '((mark modified read-only git-status-mini " "
                (name 23 23 :left :elide)
                " "
                (size-h 9 -1 :right)
                "  "
                (mode 16 16 :left :elide)
                " "
                (git-status 8 8 :left)
                "    "
                ;;              (eproject 16 16 :left :elide)
                ;;              "      "
                filename-and-process)))
#+end_src
buffer list
#+begin_src emacs-lisp
  ;;;; buffer-list
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("*Buffer*" (or
                        (name . "^TAGS\\(<[0-9]+>\\)?$")
                        (name . "^\\**Loading Log\\*$")
                        (name . "^\\*coldnew/filelist\\*$")
                        (name . "^\\*Backtrace\\*$")
                        (name . "^\\*Buffer List\\*$")
                        (name . "^\\*CEDET Global\\*$")
                        (name . "^\\*Compile-Log\\*$")
                        (name . "^\\*Completions\\*$")
                        (name . "^\\*EGG:*")
                        (name . "^\\*Kill Ring\\*$")
                        (name . "^\\*Occur\\*$")
                        (name . "^\\*Customize*")
                        (name . "^\\*Process List\\*$")
                        (name . "^\\*Shell Command Output\\*")
                        (name . "^\\*Warnings\\*$")
                        (name . "^\\*compilation\\*$")
                        (name . "^\\*el-get*")
                        (name . "^\\*grep\\*$")
                        (name . "^\\*gud\\*$")
                        (name . "^\\*ielm\\*")
                        (name . "^\\*im.bitlbee.org\\*$")
                        (name . "^\\*scratch\\*$")
                        (name . "^\\*tramp")
                        (name . "^\\*wclock\\*$")
                        (name . "^ipa*")
                        (name . "^loaddefs.el$")
                        (name . "^\\*Messages\\*$")
                        (name . "^\\*WoMan-Log\\*$")
                        ))
           ("Version Control" (or (mode . svn-status-mode)
                                  (mode . svn-log-edit-mode)
                                  (name . "^\\*svn*\\*")
                                  (name . "^\\*vc*\\*$")
                                  (name . "^\\*Annotate")
                                  (name . "^\\*git-*")
                                  (name . "^\\*cvs*")
                                  (name . "^\\*vc-*")
                                  (mode . egg-status-buffer-mode)
                                  (mode . egg-log-buffer-mode)
                                  (mode . egg-commit-buffer-mode)))
           ("Help" (or (mode . woman-mode)
                       (mode . man-mode)
                       (mode . info-mode)
                       (mode . help-mode)
                       (name . "\\*Help\\*$")
                       (name . "\\*info\\*$")))
           ("Dired" (or (mode . dired-mode)
                        (mode . nav-mode)))
           ("IRC"   (or (mode . erc-mode)
                        (mode . rcirc-mode)))
           ("Jabber" (or (mode . jabber-roster-mode)
                         (mode . jabber-chat-mode)))
           ("Terminal" (or (mode . eshell-mode)
                           (mode . term-mode)
                           (mode . inferior-python-mode)
                           (mode . eshell-mode)
                           (mode . comint-mode)
                           (name . "\\*scheme\\*$")))
           ("Config" (name . "*.conf$"))
           ("Text" (or (mode . text-mode)
                       (name . "*.txt$")))
           ("w3m"   (or (mode . w3m-mode)
                        (name . "^\\*w3m*")))
           ("Org"   (mode . org-mode))
           ("LaTEX" (or (mode . latex-mode)
                        (name . "*.tex$")))
           ("Verilog" (mode . verilog-mode))
           ("Web Develop" (or (mode . html-mode)
                              (mode . css-mode)))
           ("Shell Script" (or (mode . shell-script-mode)
                               (mode . shell-mode)
                               (mode . sh-mode)
                               (mode . ruby-mode)))
           ("Perl"  (or (mode . cperl-mode)
                        (mode . perl-mode)))
           ("Python" (or (mode . python-mode)
                         (mode . ipython-mode)))
           ("Octave" (or (mode . octave-mode)
                         (mode . inferior-octave-mode)))
           ("Scala" (or (mode . scala-mode)
                        (name . "\\*inferior-scala\\*$")))
           ("Diff" (mode . diff-mode))
           ;;      ("Project" (mode . qmake-mode))
           ("JavaScript" (or (mode . js-mode)
                             (mode . js2-mode)))
           ("C++ . C#" (or (mode . c++-mode)
                           (mode . csharpmode)))
           ("C"          (mode . c-mode))
           ("Object-C"   (mode . objc-mode))
           ("Snippet" (or (mode . snippet-mode)
                          (name . "*.yas$")))
           ("newLisp"  (mode . newlisp-mode))
           ("Common Lisp"   (mode . slime-mode))
           ("Scheme"  (or (mode . scheme-mode)
                          (mode . gambit-mode)))
           ("Clojure" (or (mode . clojure-mode)
                          (name . "\\*slime-repl clojure\\*")))
           ("Emacs recipes" (name . "*.rcp$"))
           ("Emacs" (or (mode . emacs-lisp-mode)
                        (mode . lisp-interaction-mode)
                        ))
           )))
#+end_src
Following buffer will not show in iBuffer
#+begin_src emacs-lisp
  (setq ibuffer-never-show-predicates
        (list
         "^\\*Buffer List\\*$"
         "^\\*CEDET Global\\*$"
         "^\\*MiniBuf-*"
         "^\\*Egg:Select Action\\*$"
         "^\\*Ido Completions\\*$"
         "^\\*SPEEDBAR\\*$"
         "^\\*nav\\*$"
         "^\\*swank\\*$"
         "^\\*slime-events\\*$"
         "^\\*RE-Builder\\*$"
         "^\\*pomodoro\\*$"
         "^\\*Project Buffers\\*$"
         "^eproject$"
         "\\*fsm-debug\\*$"
         ;; "^"
         "^\\*.*\\(-preprocessed\\)\\>\\*"
         "^\\*ORG.*\\*"
         "^\\*ac-mode-*"
         ".loaddefs.el$"
         "^loaddefs.el$"
         "\\*GTAGS SELECT\\**"
         "\\*Symref*"
         "\\*cscope\\*"
         "\\*helm*"
         ))
#+end_src
*** Advice
#+begin_src emacs-lisp
  ;;;; Advice
  ;; Reverse group list
  (defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups () activate)
    (setq ad-return-value (nreverse ad-return-value)))

  ;; Switching to ibuffer puts the cursor on the most recent buffer
  (defadvice ibuffer (around ibuffer-point-to-most-recent activate)
    "Open ibuffer with cursor pointed to most recent buffer name"
    (let ((recent-buffer-name (buffer-name)))
      ad-do-it
      (ibuffer-jump-to-buffer recent-buffer-name)))

  ;; Kill ibuffer after quit
  (defadvice ibuffer-quit (after kill-ibuffer activate)
    "Kill the ibuffer buffer on exit."
    (kill-buffer "*Ibuffer*"))
#+end_src
*** Keybindings
#+begin_src emacs-lisp
  (define-key ibuffer-mode-map (kbd "C-x C-f") 'lusty-file-explorer)
#+end_src
*** Functions
#+begin_src emacs-lisp
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000) (format "%7.3fK" (/ (buffer-size) 1000.0)))
     ((> (buffer-size) 1000000) (format "%7.3fM" (/ (buffer-size) 1000000.0)))
     (t (format "%8dB" (buffer-size)))))
#+end_src
*** Hooks
**** enable highlight-line
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook 'hl-line-mode)
#+end_src
**** setting default group
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook '(lambda () (ibuffer-switch-to-saved-filter-groups "default")))
#+end_src
**** sort filename automatically
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook 'ibuffer-do-sort-by-filename/process)
#+end_src
** speedbar
#+begin_src emacs-lisp
  (require 'speedbar)
  (setq speedbar-use-images nil)
  (require 'sr-speedbar)
  (setq sr-speedbar-right-side nil)
  (setq sr-speedbar-refresh-turn-on t)
#+end_src
** comint
#+begin_src emacs-lisp
  (require 'comint)
  ;; Do not show password in comint-mode
  (setq comint-output-filter-functions  '(comint-watch-for-password-prompt))
  (setq comint-password-prompt-regexp
        "\\(\\([Oo]ld \\|]e]eew \\|^\\)[Pp]assword\\|Enter password\\):\\s *\\'")

  ;;;; Keybindings
  (define-key comint-mode-map (kbd "C-g") 'comint-interrupt-subjob)
#+end_src
** undo-tree
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'undo-tree)
#+end_src
*** Enable undo-tree globally
#+begin_src emacs-lisp
  (global-undo-tree-mode)
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (define-key undo-tree-visualizer-map (kbd "C-g") 'undo-tree-visualizer-quit)
#+end_src
** hungry-delete
#+begin_src emacs-lisp
  (require 'hungry-delete)
  (add-hook 'coldnew-editor-hook 'turn-on-hungry-delete-mode)
#+end_src
** cua                                                                 :cua:
#+begin_src emacs-lisp
  (require 'cua-base)
  (require 'cua-rect)
  ;; don't add C-x, C-c, C-v
  (setq cua-enable-cua-keys nil)
  (setq cua-rectangle-mark-key (kbd "C-c RET"))
  ;; Enable cua-mode
  (cua-mode t)

  (cua--init-rectangles)
  (cua--rect-M/H-key ?n   'cua-scroll-up)
  (cua--rect-M/H-key ?N   'cua-sequence-rectangle)
  (cua--rect-M/H-key ?p   'cua-scroll-down)
#+end_src
** paredit
#+begin_src emacs-lisp
  (require 'paredit)

  (defun paredit-blink-paren-match (another-line-p)
    "redefine this function, i don't like paredit to blikn math paren")

  (defadvice paredit-backward-delete (around paredit-backward-delete activate)
    "Intergrated paredit-backward-delete with hungry-delete."
    ad-do-it
    (when (featurep 'hungry-delete)
      (if (eq (char-before) ?\s)
          (hungry-delete-backward))))

  (defadvice paredit-forward-delete (around paredit-forward-delete activate)
    "Intergrated paredit-forward-delete with hungry-delete."
    ad-do-it
    (when (featurep 'hungry-delete)
      (if (eolp)
          (hungry-delete-forward))))
#+end_src
** slime
#+begin_src emacs-lisp
  (require 'slime)
  (require 'ac-slime)
  ;; Save REPL history to emacs-cache-dir
  (setq slime-repl-history-file (concat emacs-cache-dir "slime-hist.dat"))

  ;; REPL history size set to 300
  (setq slime-repl-history-size 300)

  ;; Use global programming mode
  (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
#+end_src
* 終端機                                                               :term:
** shell-pop
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'shell-pop)
#+end_src
*** Config
#+begin_src emacs-lisp
  (shell-pop-set-internal-mode "eshell")
  (shell-pop-set-internal-mode-shell emacs-default-shell)
  (shell-pop-set-window-height emacs-popup-shell-window-height)
  (shell-pop-set-window-position emacs-popup-shell-window-position)

  (defadvice shell-pop (before kill-dead-term activate)
    "If there is a stopped ansi-term, kill it and create a new one."
    (let ((running-p (term-check-proc (buffer-name)))
          (term-p (string= "term-mode" major-mode)))
      (if term-p
          (when (not running-p)
            (kill-buffer (buffer-name))
            (shell-pop-out)))))
#+end_src

** multi-term
#+begin_src emacs-lisp
  (require 'multi-term)
  (setq multi-term-program emacs-default-shell)
#+end_src
** term
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'term)
  (require 'ansi-color)
#+end_src

*** 設定 term-mode 的色彩

移除 term-mode 預設的前景與背景顏色。
#+begin_src emacs-lisp
  (setq term-default-bg-color nil)
  (setq term-default-fg-color nil)
#+end_src

重新設定 Ansi-Color，讓他和我的佈景主題配合。
#+begin_src emacs-lisp
  ;; reset ansi-color
  (setq-default ansi-color-names-vector
                (vector (frame-parameter nil 'background-color)
                        "#0B0B0E" "#CA3839" "#8ae234" "#edd400"
                        "#729fcf" "#ad7fa8" "cyan3"   "#DCDCDC"))
  (setq ansi-term-color-vector ansi-color-names-vector)
#+end_src

*** Keybindings
#+begin_src emacs-lisp
  ;;;; keybindings
  ;; (define-key term-raw-map (kbd "<f4>") 'shell-pop)
  (define-key term-raw-map (kbd "M-x") 'execute-extended-command)
  (define-key term-raw-map (kbd "C-g") 'term-interrupt-subjob)
  (define-key term-raw-map (kbd "C-n") 'term-send-down)
  (define-key term-raw-map (kbd "C-p") 'term-send-up)
  (define-key term-raw-map (kbd "<enter>") 'term-send-input)
  (define-key term-raw-map (kbd "C-o") 'coldnew/execute-in-command-mode)
#+end_src

* 文件加密                                                          :encrypt:
** 載入相依套件

#+begin_src emacs-lisp
  (require 'epa-file)
#+end_src

** 其他設置

#+begin_src emacs-lisp
  ;; use local gpg program instaed of system one
  ;; only work under linux
  (cond
   (linux-64bit-p (setq epg-gpg-program (concat emacs-bin-dir "gpg")))
   (linux-32bit-p (setq epg-gpg-program (concat emacs-bin-dir "gpg-x86")))
   )

  (setenv "GPG_AGENT_INFO" nil)

  (epa-file-enable)

  ;; Control whether or not to pop up the key selection dialog.
  (setq epa-file-select-keys 0)

  ;; Cache passphrase for symmetric encryption.
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)

#+end_src

* Minibuffer                                                     :minibuffer:

** 設定視窗高度最多為4行高

#+begin_src emacs-lisp
  (setq max-mini-window-height 4)
#+end_src

** 按鍵設定

| 按鍵 | 命令                     | 用途               |
|------+--------------------------+--------------------|
| M-l  | backward-kill-word       | 刪除前一個詞       |
| M-p  | previous-history-element | 前一個歷史紀錄     |
| M-n  | next-history-element     | 後一個歷史紀錄     |
| C-g  | minibuffer-keyboard-quit | 離開 minibuffer    |
| C-u  |                          | 清除游標前的文字   |
| C-t  |                          | 切換到 /tmp 資料夾 |
| C-h  |                          | 切換到家目錄       |

#+begin_src emacs-lisp
  (define-key minibuffer-local-map (kbd "M-l") 'backward-kill-word)
  (define-key minibuffer-local-map (kbd "M-p") 'previous-history-element)
  (define-key minibuffer-local-map (kbd "M-n") 'next-history-element)
  (define-key minibuffer-local-map (kbd "C-g") 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-map (kbd "C-r") 'resolve-sym-link)
  (define-key minibuffer-local-map (kbd "C-u") (lambda () (interactive) (kill-line 0)))
  (define-key minibuffer-local-map (kbd "C-t") (lambda () (interactive) (kill-line 0) (insert "/tmp/")))
  (define-key minibuffer-local-map (kbd "C-h") (lambda () (interactive) (kill-line 0) (insert "~/")))
#+end_src

** 其他
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers     t )
  (setq minibuffer-electric-default-mode t )

  ;; Abort the minibuffer when using the mouse
  (add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)

  (defun stop-using-minibuffer ()
    "kill the minibuffer"
    (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
      (abort-recursive-edit)))

  (defun resolve-sym-link ()
    "Replace the string at the point with the true path."
    (interactive)
    (beginning-of-line)
    (let* ((file (buffer-substring (point)
                                   (save-excursion (end-of-line) (point))))
           (file-dir (file-name-directory file))
           (file-true-dir (file-truename file-dir))
           (file-name (file-name-nondirectory file)))
      (delete-region (point) (save-excursion (end-of-line) (point)))
      (insert (concat file-true-dir file-name))))

#+end_src

** 游標改成 bar 的形狀                                             :cursor:

我討厭在 minibuffer 時還是使用方塊狀的游標，這裡將他改變成 Bar 的形狀。

#+begin_src emacs-lisp
  (add-hook 'minibuffer-setup-hook '(lambda () (setq cursor-type 'bar)))
#+end_src

** smex                                                               :smex:
*** Depends
#+begin_src emacs-lisp
  (require 'smex)
#+end_src
*** Init
啟動 smex
#+begin_src emacs-lisp
  (smex-initialize)
#+end_src
*** Config
#+begin_src emacs-lisp
  (setq smex-save-file (concat emacs-cache-dir "smex.dat"))
#+end_src

** ido
*** Depends
#+begin_src emacs-lisp
  (require 'ido)
#+end_src
*** Keybindings
#+begin_src emacs-lisp
  (add-hook 'ido-setup-hook
            '(lambda ()
               (define-key ido-completion-map (kbd "C-f") 'ido-next-match)
               (define-key ido-completion-map (kbd "C-b") 'ido-prev-match)
               ))
#+end_src
* EShell                                                              :eshell:
** 載入相關套件

#+begin_src emacs-lisp
  (require 'eshell)
  (require 'em-dirs)
  (require 'em-hist)
  (require 'em-prompt)
  (require 'em-term)
  (require 'em-cmpl)
#+end_src

*** Prompt
將 eshell 的 prompt 設定成和 bash 一樣，也就是　 username@system-name。
#+begin_src emacs-lisp
  (setq eshell-prompt-function
        '(lambda ()
           (concat
            user-login-name "@" system-name " "
            (if (search (directory-file-name (expand-file-name (getenv "HOME"))) (eshell/pwd))
                (replace-regexp-in-string (expand-file-name (getenv "HOME")) "~" (eshell/pwd))
              (eshell/pwd))
            (if (= (user-uid) 0) " # " " $ ")
            )))


#+end_src
#+begin_src emacs-lisp
  ;;; change history file path
  (setq eshell-last-dir-ring-file-name (concat emacs-cache-dir "eshell-lastdir"))
  (setq eshell-history-file-name (concat emacs-cache-dir "eshell-history"))

  ;; other setting
  (setq eshell-save-history-on-exit t)
  (setq eshell-ask-to-save-last-dir nil)
  (setq eshell-history-size 512)
  (setq eshell-hist-ignoredups t)
  (setq eshell-cmpl-cycle-completions nil)
  (setq eshell-scroll-to-bottom-on-output t)
  (setq eshell-show-maximum-output t)
  ;;;; ---------------------------------------------------------------------------
  ;;;; Hooks
  ;;;; ---------------------------------------------------------------------------

  ;;; Make eshell prompt more colorful
  (add-to-list 'eshell-output-filter-functions 'coldnew/colorfy-eshell-prompt)

  ;; my auto-complete for elisp
  (add-hook 'eshell-mode-hook 'auto-complete-mode)
  (add-hook 'eshell-mode-hook 'ac-eshell-mode-setup)

  ;; use helm to complete esehll
  (when (featurep 'helm)
    (add-hook 'eshell-mode-hook
              #'(lambda ()
                  (define-key eshell-mode-map
                    [remap pcomplete]
                    'helm-esh-pcomplete))))


  ;; define ac-source for eshell-pcomplete
  (ac-define-source eshell-pcomplete
    '((candidates . pcomplete-completions)
      (cache)
      (symbol . "f")))

  (defun ac-eshell-mode-setup ()
    "auto-complete settings for eshell-mode"
    (setq ac-sources
          '(
            ac-source-eshell-pcomplete
            )))
#+end_src
** Command
#+begin_src emacs-lisp
  ;; find-file
  ;; (defun eshell/ef (file) (find-file file))
  (defun eshell/ef (&rest args) (eshell/emacs args))

  ;; ediff
  (defun eshell/ed (file1 file2) (ediff file1 file2))

  ;; clear
  (defun eshell/clear ()
    "Clears the shell buffer ala Unix's clear or DOS' cls"
    (interactive)
    ;; the shell prompts are read-only, so clear that for the duration
    (let ((inhibit-read-only t))
      ;; simply delete the region
      (delete-region (point-min) (point-max))))


  (defun eshell/info (subject)
    "Read the Info manual on SUBJECT."
    (let ((buf (current-buffer)))
      (Info-directory)
      (let ((node-exists (ignore-errors (Info-menu subject))))
        (if node-exists
            0
          ;; We want to switch back to *eshell* if the requested
          ;; Info manual doesn't exist.
          (switch-to-buffer buf)
          (eshell-print (format "There is no Info manual on %s.\n"
                                subject))
          1))))

  (defun eshell/emacs (&rest args)
    "Open a file in emacs. Some habits die hard."
    (if (null args)
        ;; If I just ran "emacs", I probably expect to be launching
        ;; Emacs, which is rather silly since I'm already in Emacs.
        ;; So just pretend to do what I ask.
        (bury-buffer)
      ;; We have to expand the file names or else naming a directory in an
      ;; argument causes later arguments to be looked for in that directory,
      ;; not the starting directory
      (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))
#+end_src
** Function
#+begin_src emacs-lisp
  (defun coldnew/colorfy-eshell-prompt ()
    (interactive)
    (let* ((mpoint)
           (user-string-regexp (concat "^" user-login-name "@" system-name)))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward (concat user-string-regexp ".*[$#]") (point-max) t)
          (setq mpoint (point))
          (overlay-put (make-overlay (point-at-bol) mpoint) 'face '(:foreground "dodger blue")))
        (goto-char (point-min))
        (while (re-search-forward user-string-regexp (point-max) t)
          (setq mpoint (point))
          (overlay-put (make-overlay (point-at-bol) mpoint) 'face '(:foreground "green3"))
          ))))
#+end_src
* Helm                                                                 :helm:
** 載入相關套件

#+begin_src emacs-lisp
  (require 'helm)
  (require 'helm-etags+)
  (require 'helm-git)
  (require 'ctags-update)
#+end_src

** 使用預先定義好的 helm 設定

#+begin_src emacs-lisp
  (require 'helm-config)
  (setq helm-config t)
#+end_src

** 全域性啟用 helm-mode

#+begin_src emacs-lisp
  (helm-mode 1)
#+end_src

** TODO Config this
#+begin_src emacs-lisp
  ;; Enable dired binding
  (helm-dired-bindings 1)
  (ctags-update-minor-mode 1)
#+end_src
** Function
#+begin_src emacs-lisp
  (defun helm-c-occur-get-line (s e)
    "rewrite `helm-c-occur-get-line' to make it color on line-number."
    (concat (propertize (format "%7d" (line-number-at-pos (1- s))) 'face '((:foreground "red")))
            (format ": %s" (buffer-substring s e))))
#+end_src
** 在目前的專案找尋檔案                                            :command:

#+begin_src emacs-lisp
  (defun coldnew/project-find-file ()
    (interactive)
    (helm-other-buffer
     '(helm-c-source-git-files
       )
     "*coldnew/project-file-list"))
#+end_src

** TODO 其他
#+begin_src emacs-lisp
    (defun coldnew/helm-filelist ()
      "Preconfigured `anything' to open files/buffers/bookmarks instantly.
     This is a replacement for `anything-for-files'.
     See `anything-c-filelist-file-name' docstring for usage."
      (interactive)
      (helm-other-buffer
       '(helm-c-source-buffers-list
         helm-c-source-recentf
         helm-c-source-ffap-line
         helm-c-source-ffap-guesser
         helm-c-source-bookmarks
         helm-c-source-file-cache
         helm-c-source-files-in-current-dir
         helm-c-source-locate)
       "*coldnew/filelist*"))
#+end_src

** 尋找目前緩衝區所有符合查詢規則的文字、字串                      :command:

#+begin_src emacs-lisp
  (defun coldnew/helm-occur ()
    "I don't like highlight when goto lines."
    (interactive)
    ;; FIXME: is there more elegent way to make temp face?
    (set (make-local-variable 'face-remapping-alist) '((helm-selection-line nil)))
    (helm-occur))
#+end_src

** 按鍵設定

#+begin_src emacs-lisp
  (defun coldnew/helm-mini ()
    (interactive)
    (helm-other-buffer '(helm-c-source-buffers-list
                         helm-c-source-git-files
                         helm-c-source-recentf
                         helm-c-source-buffer-not-found)
                       "*coldnew helm mini*"))

  (vim:imap (kbd "M-o") 'coldnew/helm-mini)
#+end_src

* 文檔幫助

這邊放置 manpage、womanpage、info 等幫助文檔模式的設定。

** WoMan                                                              :woman:

woman 是 emacs 下顯示 manpage 最好的方式。

*** WoMan 快取儲存位置設定

#+begin_src emacs-lisp
  (setq woman-cache-filename (concat emacs-cache-dir "woman.cache"))
#+end_src

*** 對 woMan 緩衝區上色

#+begin_src emacs-lisp
  (setq woman-fontify t)
#+end_src

*** TODO 其他
#+begin_src emacs-lisp
  (setq woman-use-topic-at-point nil)
  ;; Colorful fonts
  (setq woman-fill-column 100)
#+end_src
* org-mode                                                              :org:
因為 org-mode 在這個設定檔裡佔有非常重要的比例，所以獨立出來。
** 載入相關套件
#+begin_src emacs-lisp
  (require 'org-install)
  (require 'org-table)
  (require 'ob-ditaa)
  (require 'org-latex)
#+end_src

google-weather 是提供　 emacs 連接 google-weathre 的 API，
在 org 檔案裏面加入如下的code，則可以在 agenda view 裏面看到天氣資訊。
#+begin_example
  * Weather
  %%(org-google-weather "New York")
#+end_example

#+begin_src emacs-lisp
  (require 'google-weather)
  (require 'org-google-weather)
#+end_src

** 設定 org-mode 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.org_archive$" . org-mode))
#+end_src

** 將 plantuml 加入 org-mode

plantuml 是一個用語言寫出 UML 架構圖的程式，使用他前必須將 Garphviz 裝上。

#+begin_src emacs-lisp
  (setq org-plantuml-jar-path (concat emacs-etc-dir "plantuml.jar"))
#+end_src

** 預設讓 org-mode 使用自動縮排模式

#+begin_src emacs-lisp
  (setq org-startup-indented t)
#+end_src

** 打開新的 org-mode 時，預設將所有項目都隱藏，只保留最上層的父目錄

#+begin_src emacs-lisp
  (setq org-startup-folded t)
#+end_src

** 將前面的 *星號* 隱藏，只顯示最後一個

#+begin_src emacs-lisp
  (setq org-hide-leading-stars t)
#+end_src

** 切換成程式碼欄位時使用目前的視窗

#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src

** 直接在程式碼欄位上為程式碼上色

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

** 讓 org-mode 與 cua-mode 相容

#+begin_src emacs-lisp
  (setq org-CUA-compatible t)
#+end_src

** 增加快速模版

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("E" "#+begin_src emacs-lisp\n?\n#+end_src"))
               (add-to-list 'org-structure-template-alist
               '("S" "#+begin_src sh\n?\n#+end_src"))
               (add-to-list 'org-structure-template-alist
               '("p" "#+begin_src plantuml :file uml.png \n?\n#+end_src"))
#+end_src

** TODO Config
#+begin_src emacs-lisp
  (setq org-directory "~/Dropbox/Org/")
  (setq org-agenda-files (list "~/Dropbox/Org/"))
  (setq org-log-done t)
  (setq org-pretty-entities t)
  (setq org-use-speed-commands t)

  (setq org-tag-alist '(
                        (:startgroup . nil) ("Business" . ?b) ("School" . ?s) ("Weintek" . ?w) ("Personal" . ?p) (:endgroup . nil)
                        ))
#+end_src
** TODO Image size
#+begin_example

You can now (from git master) use `org-image-actual-width'.

(setq org-image-actual-width 300)
  => always resize inline images to 300 pixels

(setq org-image-actual-width '(400))
  => if there is a #+ATTR.*: width="200", resize to 200,
     otherwise resize to 400

(setq org-image-actual-width nil)
  => if there is a #+ATTR.*: width="200", resize to 200,
     otherwise don't resize

(setq org-image-actual-width t)
  => Never resize and use original width (the default)

#+end_example
** Capture
#+begin_src emacs-lisp
  (setq org-default-notes-file (concat org-directory "TODO.org"))
  (setq org-capture-templates '(("t" "TODO" entry (file+headline "" "Tasks")
                                 "* TODO %?\n %i\n %a")
                                ("f" "FIXME" entry (file+headline "" "Tasks")
                                 "* FIXME %?\n %i\n %a")
                                ("w" "Weintek" entry (file+headline "" "Weintek")
                                 "* TODO %?\n %i\n %a")
                                ))

#+end_src

*** Keybinding
#+begin_src emacs-lisp :tangle no
  (add-hook 'org-capture-mode-hook
            '(lambda ()
               (define-key coldnew/command-mode-map "c" 'org-capture-finalize)
               ))

#+end_src
** 設定 Agenda 顯示在目前的 window 上。

#+begin_src emacs-lisp
  (setq org-agenda-window-setup 'current-window)
#+end_src

** 在 Agenda mode 時啟用 hl-line

#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+end_src

** 使用 C-g 離開 Agenda

#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook
            '(lambda ()
               (local-set-key (kbd "C-g") 'org-agenda-exit)))
#+end_src

** 讓 org-mode 裡面可以加密文章                                      :crypt:

用於加密 org-mode 裡面具有 :secret: 這個 TAG 的區塊。
注意到這需啟用 [[*Easy%20PG][Easy PG]] 才能夠使用。

*** 載入相關模組

#+begin_src emacs-lisp
  (require 'org-crypt)
#+end_src

*** 設定要加密的 tag 標籤為 *secret*

#+begin_src emacs-lisp
  (setq org-crypt-tag-matcher "secret")
#+end_src

*** Add a hook to automatically encrypt entries before a file is saved to disk.

#+begin_src emacs-lisp
  (org-crypt-use-before-save-magic)
#+end_src

*** 避免 encrypt 這個 tag 被子項目繼承

#+begin_src emacs-lisp
  (setq org-tags-exclude-from-inheritance (quote ("secret")))
#+end_src

*** 設定 org-crypt-disable-auto-save 成 encrypt 模式。

此模式並不會停用 auto-save-mode，反之，當自動儲存時，解密過的區域將會加密回去。

#+begin_src emacs-lisp
  (setq org-crypt-disable-auto-save 'encrypt)
#+end_src

** 在 org-mode 裡面顯示圖片

*** 增加 org-mode 圖片的正規表達式到 iimage-mode 裡面

#+begin_src emacs-lisp
  (require 'iimage)
  (add-to-list 'iimage-mode-image-regex-alist
               (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex "\\)\\]\\]")  1))
#+end_src

*** 打開 iimage-mode 並取消 org-link 的顏色

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (turn-on-iimage-mode)
               (set-face-underline-p 'org-link nil)))
#+end_src

*** 切換顯示圖片的命令

#+begin_src emacs-lisp
  (defun org-display-image ()
    "Toggle display images in org file."
    (interactive)
    (if (face-underline-p 'org-link)
        (set-face-underline-p 'org-link nil)
      (set-face-underline-p 'org-link t))
    (call-interactively 'iimage-mode))
#+end_src

*** 在 org-mode 裏面使用 C-c I 切換顯示圖片                        :keymap:

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-c I") 'org-display-image)))
#+end_src

** Keybinding
*** org-mode
設定自定義的按鍵。
#+begin_src emacs-lisp
    (add-hook 'org-mode-hook
              '(lambda ()
                 (define-key org-mode-map (kbd "C-c C-p") 'org-backward-same-level)
                 (define-key org-mode-map (kbd "C-c C-n") 'org-forward-same-level)
                 (define-key org-mode-map (kbd "C-c C-b") 'coldnew/org-up-parent)
                 (define-key org-mode-map (kbd "C-c C-f") 'coldnew/org-down-children)
                 (define-key org-mode-map (kbd "C-c i") 'org-insert-link)
                 ;;(define-key coldnew/command-mode-map "c" 'org-edit-special)
                 ))

  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-\'") nil)
               (define-key org-mode-map (kbd "C-,") nil)
               (define-key org-mode-map (kbd "C-c C-e") nil)
               ))
#+end_src


#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-c b") 'org-metaleft)
               (define-key org-mode-map (kbd "C-c f") 'org-metaright)
               (define-key org-mode-map (kbd "C-c p") 'org-metaup)
               (define-key org-mode-map (kbd "C-c n") 'org-metadown)))
#+end_src
*** org-src-mode
#+begin_src emacs-lisp
  (add-hook 'org-src-mode-hook
            '(lambda ()
               ;;(local-set-key (kbd "C-c C-c") 'org-edit-src-exit)
               ;;(define-key coldnew/command-mode-map "c" 'org-edit-src-exit)
               ))
#+end_src
** Conflict Fix
some packages conflict with org-mode
*** yasnippet
#+begin_src emacs-lisp
  (when (featurep 'yasnippet)
    (defun yas/org-very-safe-expand ()
      (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

    (add-hook 'org-mode-hook
              (lambda ()
                (make-variable-buffer-local 'yas/trigger-key)
                (setq yas/trigger-key (kbd "TAB"))
                (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                (define-key yas/keymap [tab] 'yas/next-field))))
#+end_src

*** windmove
#+begin_src emacs-lisp
  ;; Make windmove work in org-mode:
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src
** Commands
*** org-archive-done-tasks
將標記為 *DONE* 的結點收錄到 archive 裡。
#+begin_src emacs-lisp
  (defun org-archive-done-tasks ()
    "Make all DONE subtree to archive."
    (interactive)
    (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+end_src
*** coldnew/org-up-parent
跑到目前節點的父節點，並收起目前的結點。
#+begin_src emacs-lisp
  (defun coldnew/org-up-parent ()
    "Move to the parent of current point. If current is the parent heading,
            move to the previous parent heading."
    (interactive)
    (if (not (org-on-heading-p))
        (outline-back-to-heading)
      (let* ((level (funcall outline-level))
             (point-to-move-to
              (save-excursion
                (outline-previous-visible-heading 1)
                (while (>= (funcall outline-level) level)
                  (outline-previous-visible-heading 1))
                (point))))
        (if point-to-move-to
            (goto-char point-to-move-to))))
    (org-cycle))
#+end_src
*** coldnew/org-down-children
跑到目前節點的子節點，並展開子節點。
#+begin_src emacs-lisp
  (defun coldnew/org-down-children ()
    "Move to children of current heading. If current heading only has subtree,
          expand the subtree."
    (interactive)
    (outline-back-to-heading)
    (show-children)
    (let* ((level (funcall outline-level))
           (point-to-move-to
            (save-excursion
              (outline-next-visible-heading 1)
              (if (<= (funcall outline-level) level)
                  nil
                        (point)))))
              (if point-to-move-to
                  (goto-char point-to-move-to)
                (show-subtree))))
#+end_src
** presentation
#+begin_src emacs-lisp
  ;; #+LaTeX_CLASS: beamer in org files
  (unless (boundp 'org-export-latex-classes)
      (setq org-export-latex-classes nil))
    (add-to-list 'org-export-latex-classes
                 ;; beamer class, for presentations
                 '("beamer"
                   "\\documentclass[11pt]{beamer}\n
          \\mode<{{{beamermode}}}>\n
          \\usetheme{{{{beamertheme}}}}\n
          \\usecolortheme{{{{beamercolortheme}}}}\n
          \\beamertemplateballitem\n
          \\setbeameroption{show notes}
          \\usepackage[utf8]{inputenc}\n
          \\usepackage[T1]{fontenc}\n
          \\usepackage{hyperref}\n
          \\usepackage{color}\n
          \\usepackage{listings}\n
          \\usepackage{xeCJK}\n
          \\setCJKmainfont{LiHei Pro}\n
          \\XeTeXlinebreaklocale \"zh\"\n
          \\XeTeXlinebreakskip = 0pt plus 1pt
          \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
      frame=single,
      basicstyle=\\small,
      showspaces=false,showstringspaces=false,
      showtabs=false,
      keywordstyle=\\color{blue}\\bfseries,
      commentstyle=\\color{red},
      }\n
          \\usepackage{verbatim}\n
          \\institute{{{{beamerinstitute}}}}\n
           \\subject{{{{beamersubject}}}}\n"

                   ("\\section{%s}" . "\\section*{%s}")

                   ("\\begin{frame}[fragile]\\frametitle{%s}"
                    "\\end{frame}"
                    "\\begin{frame}[fragile]\\frametitle{%s}"
                    "\\end{frame}")))

    ;; letter class, for formal letters

    (add-to-list 'org-export-latex-classes

                 '("letter"
                   "\\documentclass[11pt]{letter}\n
          \\usepackage[utf8]{inputenc}\n
          \\usepackage[T1]{fontenc}\n
          \\usepackage{color}"

                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src
** Babel 支援的語言
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (ditaa . t)
     (dot . t)
     (js . t)
     (latex . t)
     (perl . t)
     (python . t)
     (ruby . t)
     (sh . t)
     (plantuml . t)
     (clojure .t)
     ))
#+end_src
** 對程式碼區塊進行 eval 時不再詢問

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

** 輸出成 PDF 檔案設定
*** 使用 minted 將程式碼加上色彩
#+begin_src emacs-lisp
  (require 'org-latex)
  (add-to-list 'org-export-latex-packages-alist '("" "minted"))
  (setq org-export-latex-listings 'minted)
  (setq org-export-latex-minted-options
        '(("frame" "lines")
          ("fontsize" "\\scriptsize")))
#+end_src

*** 使用 xelatex 產生 PDF 檔案
當系統有安裝 latexmk 時，使用 latexmk 呼叫 xelatex 進行編譯，
反之則直接呼叫 xelatex 進行二次編譯。
#+begin_src emacs-lisp
  (setq org-latex-to-pdf-process
        (if (executable-find "latexmk")
            '("latexmk -pdflatex=xelatex -pdf -silent --shell-escape -f %f")
          '("xelatex -interaction nonstopmode --shell-escape %f"
            "xelatex -interaction nonstopmode --shell-escape %f")))
#+end_src

*** 一般文章所使用的 latex 配置
#+begin_src emacs-lisp
  (add-to-list 'org-export-latex-classes
               '("coldnew-article"
                 "\\documentclass[12pt,a4paper]{article}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{fontspec}
                  \\usepackage{xeCJK}
                  \\setCJKmainfont{Hiragino Sans GB W3}
                  \\XeTeXlinebreaklocale \"zh\"
                  \\XeTeXlinebreakskip = 0pt plus 1pt
                  \\usepackage{graphicx}
                  \\usepackage{tikz}
                  \\usepackage[bookmarks=true,colorlinks,urlcolor=blue]{hyperref}
                  \\defaultfontfeatures{Mapping=tex-text}
                  \\setmonofont[Scale=0.8]{DejaVu Sans Mono}
                  \\usepackage{geometry}
                  \\usepackage{minted}
                  \\usemintedstyle{emacs}
                  \\geometry{a4paper, textwidth=6.5in, textheight=8in,
                              marginparsep=10pt, marginparwidth=.6in}
                  \\pagestyle{plain}
                  \\linespread{1.5}
                  \\title{}
                        [NO-DEFAULT-PACKAGES]
                        [NO-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))
#+end_src

*** 投影片所使用的 latex 配置
#+begin_src emacs-lisp
  (add-to-list 'org-export-latex-classes
               ;; beamer class, for presentations
               '("beamer"
                 "\\documentclass[11pt]{beamer}
                  \\mode<{{{beamermode}}}>
                  \\usetheme{{{{beamertheme}}}}
                  \\usecolortheme{{{{beamercolortheme}}}}
                  \\beamertemplateballitem
                  \\setbeameroption{show notes}
                  \\usepackage[utf8]{inputenc}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{xeCJK}
                  \\setCJKmainfont{Hiragino Sans GB W3}
                  \\XeTeXlinebreaklocale \"zh\"
                  \\XeTeXlinebreakskip = 0pt plus 1pt
                  \\usepackage{minted}
                  \\usemintedstyle{emacs}
                  \\setmainfont{Monaco}
                  \\usepackage{hyperref}
                  \\usepackage{color}
                  \\usepackage{verbatim}
                  \\usepackage{upquote}
                  \\institute{{{{beamerinstitute}}}}
                  \\subject{{{{beamersubject}}}}"

                 ("\\section{%s}" . "\\section*{%s}")

                 ("\\begin{frame}[fragile]\\frametitle{%s}"
                  "\\end{frame}"
                  "\\begin{frame}[fragile]\\frametitle{%s}"
                  "\\end{frame}")))
#+end_src

* 編輯器                                                             :editor:
** 通用型 C 語言編輯設定

這邊設定的是通用的

** 不使用 TAB 進行縮排

#+begin_src emacs-lisp
  (setq indent-tabs-mode nil)
#+end_src

** 設定 TAB 的寬度為 8

#+begin_src emacs-lisp
  (setq tab-width 8)
#+end_src

** 設定每行之間的間格為 4

#+begin_src emacs-lisp
  (setq line-spacing 4)
#+end_src

** 在檔案的最後一行加入一空白行

#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src

** 在存檔前清除多餘的空白

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** 自動建立資料夾

當使用 C-x C-f 建立新的檔案的時候，如果該資料夾未被建立，則自動建立他。

一般網路上流傳的方式，是在存檔案時才建立資料夾。但是我認為應該一開始就該先建立好資料夾，
畢竟很少人會建好資料夾內的檔案而放棄。

如果需要存檔後才進行建立資料夾的動作，則將下面的 find-file-hook 改為 before-save-hook。

#+begin_src emacs-lisp
  (add-hook 'find-file-hook
            '(lambda ()
                 (or (file-exists-p  (file-name-directory buffer-file-name))
                     (make-directory (file-name-directory buffer-file-name) t))))
#+end_src

** 行號設定

預設顯示行號
#+begin_src emacs-lisp
  (global-linum-mode 1)
#+end_src

設定某些 Mode 不顯示行號，這邊先設定不顯示行號的 mode-list
#+begin_src emacs-lisp
  (setq inhibit-linum-mode-alist
        '(
          eshell-mode
          shell-mode
          term-mode
          erc-mode
          compilation-mode
          woman-mode
          w3m-mode
          calendar-mode
          org-mode
          ))
#+end_src

#+begin_src emacs-lisp
  (defadvice linum-on (around inhibit-for-modes activate)
    "Stop turing linum-mode if it is in the inhibit-linum-mode-alist."
    (unless (member major-mode inhibit-linum-mode-alist)
      ad-do-it))
#+end_src

** TODO remember
*** electric-pair-mode
#+begin_src emacs-lisp
  (electric-pair-mode 1)
  ;; setting for auto-close brackets for electric-pair-mode regardless of current major mode syntax table
  (setq electric-pair-pairs '(
                              (?\" . ?\")
                              (?\{ . ?\})
                              ) )
#+end_src
#+begin_src emacs-lisp
  (setq fill-column      100 ) ; column beyond which automatic line-wrapping shold happen
  (setq kill-ring-max    3000 ) ; Maximum lenght of kill-ring
  (setq next-line-add-newlines t ) ;
  (setq shift-select-mode      t ) ; Enable shift-select mode

  ;; Enable global font-lock
  (global-font-lock-mode t)
  ;; Revert buffers automatically when underlying files are changed externally
  (global-auto-revert-mode t)
  ;; Show matching parentheses all the time
  (show-paren-mode t)
  ;; Enable auto-complete-mode
  (global-auto-complete-mode t)
  ;; Enable delete-selection-mode
  (delete-selection-mode t)
#+end_src
** Functions
#+begin_src emacs-lisp
  (defun indent-file-after-save ()
    "Indent whole file after saved."
    (make-local-variable 'after-save-hook)
    (add-hook 'after-save-hook
              '(lambda ()
                 (indent-region (point-min) (point-max) nil)
                 (save-buffer))))

  (defun highlight-additional-keywords ()
    "Highlight additional keywords."
    (font-lock-add-keywords nil '(("\\<\\(FIXME\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)))
    (font-lock-add-keywords nil '(("\\<\\(NOTE\\):" 1 'org-level-2 t)))
    (font-lock-add-keywords nil '(("\\<\\(TODO\\):" 1 'org-todo t)))
    (font-lock-add-keywords nil '(("\\<\\(DONE\\):" 1 'org-done t)))
    )

  (defun highlight-fontify-numbers ()
    "Use this function as a hook to fontify numbers as constant"
    (font-lock-add-keywords nil
                            '(
                              ;; hexadecimal
                              ("\\b\\(0[00-9a-fA-F]+\\)" 1 font-lock-constant-face)
                              ;; float
                              ("\\b\\([+-]?[0-9]+\\.[0-9]+\\)" 1 font-lock-constant-face)
                              ;; int
                              ("[\`^(\{\[,\+\-\*/\%=\s-]\\(-?[0-9]+U?L?L?\\)" 1 font-lock-constant-face)
                              )))

  (defun highlight-escape-char ()
    "Use this function as a hook to fontify escape char."
    (font-lock-add-keywords nil
                            '(
                              ("\\\\\\(?:[abfnrtv'\"?\\0]\\|x[a-fA-F]\\{2\\}\\|[0-7]\\{3\\}\\)"
                               0 'font-lock-escape-char-face prepend)
                              )))

  (defun insert-space-between-english-chinese ()
    "Insert a space between English words and Chinese charactors"
    (save-excursion
      (goto-char (point-min))
      (while (or (re-search-forward "\\(\\cc\\)\\([a-zA-Z0-9]\\)" nil t)
                 (re-search-forward "\\([a-zA-Z0-9]\\)\\(\\cc\\)" nil t))
        (replace-match "\\1 \\2" nil nil))
      (goto-char (point-min))
      (while (or (re-search-forward "\\([。，！？；：「」（）、]\\) \\([a-zA-Z0-9]\\)" nil t)
                 (re-search-forward "\\([a-zA-Z0-9]\\) \\([。，！？；：「」（）、]\\)" nil t))
        (replace-match "\\1\\2" nil nil))))
#+end_src

* Cedet                                                                :cede:
#+begin_src emacs-lisp
  (require 'semantic)

  ;; Enable Semantic features
  (semantic-mode 1)

  ;; Maintain tag database
  (global-semanticdb-minor-mode 1)
  ;; Reparse buffer when idle
  (global-semantic-idle-scheduler-mode 1)
  ;; Show completions when idle
  (global-semantic-idle-completions-mode 1)
  ;; Provide `switch-to-buffer'-like keybinding for tag names.
  (global-semantic-mru-bookmark-mode 1)
  ;; Show summary of tag at point
  (global-semantic-idle-summary-mode 1)
  ;;;; Disable
  ;; Highlight the current tag.
  (global-semantic-highlight-func-mode -1)
  ;; Show current fun in header line
  (global-semantic-stickyfunc-mode -1)
  ;; Additional tag decorations
  (global-semantic-decoration-mode -1)

  ;;;; Enable support for GNU Global
;;  (semanticdb-enable-gnu-global-databases 'c-mode)
;;  (semanticdb-enable-gnu-global-databases 'c++-mode)

  (setq semanticdb-default-save-directory (concat emacs-cache-dir "semanticdb"))
  (set-default 'semantic-case-fold t)

#+end_src

* ECB                                                                   :ecb:
** 載入相關套件

#+begin_src emacs-lisp
  (require 'ecb)
#+end_src

** 不要顯示 tips-of-the-day，感覺很煩人

#+begin_src emacs-lisp
  (setq ecb-tip-of-the-day nil)
#+end_src

** 不要自動檢查版本是否相容，很煩人...

#+begin_src emacs-lisp
  (setq ecb-auto-compatibility-check nil)
#+end_src

** Commands
#+begin_src emacs-lisp
  (defun ccc-toggle-ecb-mode ()
    "Toggle ecb-minor-mode and resize window accordingly"
    (interactive)
    (if ecb-minor-mode
        (progn
          (let ((w (frame-width ecb-frame)))
            (message "%i" w)
            )
          (ecb-minor-mode)
          )
      (progn
        (message "%s" "turning on, make frame wider")
        (ecb-minor-mode)
        )
      ))
#+end_src
* 書籤
** Bookmark 說明
:PROPERTIES:
:tangle:   no
:END:

*** 預設按鍵
| 快捷鍵  | 命令                | 用途                                        |
|---------+---------------------+---------------------------------------------|
| C-x r m | bookmark-set        | 設置新的書籤                                |
| C-x r l | bookmark-bmenu-list | 列出所有已設置的書籤                        |
| C-x r b | bookmarj-jump       | 跳轉到書籤                                  |
|         | bookmark-delete     | 刪除書籤                                    |
|         | bookmark-load       | 讀取已儲存的書籤檔案                        |
|         | bookmark-save       | 儲存書籤至 bookmark-default-file 指定的地方 |

** Config
#+begin_src emacs-lisp
  (setq bookmark-default-file emacs-bookmark-file)
#+end_src

#+begin_src emacs-lisp
  (require 'bm)
#+end_src
* Cscope                                                             :cscope:
** 載入和 cscope 相關的 package
#+begin_src emacs-lisp
  (require 'xcscope)
  (require 'xcscope+)
  (setq cscope-do-not-update-database t)
#+end_src
* 程式開發                                                         :language:

各種不同程式語言開發用的設定。

** Android                                                          :android:
#+begin_src emacs-lisp
  (require 'android-mode)
  ;; Set my android-emulator-path
  (setq android-mode-sdk-dir "/opt/android-sdk-update-manager/")
#+end_src
** Bash
*** 設定 Bash 語言 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.sh" . sh-mode))
  (add-to-list 'auto-mode-alist '("\\.bash" . sh-mode))
#+end_src
*** Auto complete
#+begin_src emacs-lisp
  ;; auto-complete
  (add-hook 'shell-mode-hook 'ac-shell-script-mode-setup)
  ;; define ac-source for pcomplete
  (ac-define-source pcomplete
    '((candidates . pcomplete-completions)
      (cache)
      (symbol . "f")))

  (defun ac-shell-script-mode-setup ()
    "auto-complete settings for shell-script-mode"
    (setq ac-sources
          '(ac-source-pcomplete
            ac-source-dictionary
            ac-source-filename
            ac-source-files-in-current-dir
            ac-source-words-in-same-mode-buffers
            )))
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (add-hook 'sh-mode-hook
            '(lambda ()
               (local-set-key (kbd "}") 'self-insert-command)
               (local-set-key (kbd "]") 'self-insert-command)
               (local-set-key (kbd ")") 'self-insert-command)
               ))
#+end_src
** C
*** 設定 C 語言 檔案的副檔名與對應的模式

#+begin_src emacs-lisp

  (add-to-list 'auto-mode-alist '("\\.c$" . c-mode))
  (add-to-list 'auto-mode-alist '("\\.h$" . c-mode))
#+end_src

*** 預設使用 Linux Coding Style

#+begin_src emacs-lisp
  (add-hook 'c-mode-hook
            '(lambda ()
               (c-set-style "linux")))
#+end_src

*** c-eldoc
adeff
#+begin_src emacs-lisp
    (add-hook 'c-mode-hook
            '(lambda ()
               (require 'c-eldoc)
               (setq c-eldoc-includes "`pkg-config gtk+-3.0 opencv --cflags --libs` -I./ -I../")
               (c-turn-on-eldoc-mode)))
#+end_src
#+begin_src emacs-lisp
    ;; use my cc-mode-common-setting
  ;;  (add-hook 'c-mode-hook 'coldnew-cc-mode-common-setting)

    ;; use ctypes
    (require 'ctypes)
    (setq-default ctypes-file-name (concat emacs-cache-dir "ctypes_std_c.dat"))
    (add-hook 'ctypes-load-hook 'my-ctypes-load-hook)

    ;; use hide-if-def-mode
    ;;(add-hook 'c-mode-hook 'hide-ifdef-mode)

    ;;(require 'gccsense)

    ;;;; ---------------------------------------------------------------------------
    ;;;; Functions
    ;;;; ---------------------------------------------------------------------------
    (defun my-ctypes-load-hook ()
      (ctypes-read-file ctypes-file-name nil t t))


    ;;;; ---------------------------------------------------------------------------
    ;;;; Commands
    ;;;; ---------------------------------------------------------------------------

    (defun c-mode:insert-inc-or-if ()
      "If at the start of line. add `inc' and expand it,
    else add `if' and expand it."
      (interactive)
      (let* ((current (point))
             (begin (line-beginning-position)))
        (if (eq current begin)
            (progn
              (c-mode:insert-include)
              (newline-and-indent))
          (progn
            (insert "if")
            (yas/expand)))))
#+end_src
*** TODO 自動偵測 c-basic-offset
#+begin_src emacs-lisp
  (require 'guess-offset)
#+end_src
*** 快速插入樣板

#+begin_src emacs-lisp
  (setq c-mode-expand-alist
        '(("i" . c-mode:insert-inc-or-if)
          ("m" . "main")
          ))
#+end_src

*** 按鍵配置                                                       :keymap:
#+begin_src emacs-lisp
  (define-key c-mode-map (kbd "C-x C-o") 'ff-find-other-file)
#+end_src

*** 將 #if 0 #endif 區域上色為灰色

#+begin_src emacs-lisp
  (defun cc-mode:highlight-if-0 ()
    "highlight c/c++ #if 0 #endif macros"
    (interactive)
    (setq cpp-known-face 'default)
    (setq cpp-unknown-face 'default)
    (setq cpp-known-writable 't)
    (setq cpp-unknown-writable 't)
    (setq cpp-edit-list '(("0" '(foreground-color . "gray")  default both)
                          ("1" default font-lock-comment-face both)))
    (cpp-highlight-buffer t))

  (add-hook 'c-mode-hook 'cc-mode:highlight-if-0)
#+end_src

** C++
*** 設定 C++ 語言 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.hpp$" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.cpp$" . c++-mode))
  ;; (add-to-list 'magic-mode-alist
  ;;              `(,(lambda ()
  ;;                   (and (string= (file-name-extension buffer-file-name) "h")
  ;;                        (re-search-forward "\\W\\(class\\|template\\namespace\\)\\W"
  ;;                                           magic-mode-regexp-match-limit t)))
  ;;                . c++-mode))
#+end_src
*** Config
**** Codinf Style
#+begin_src emacs-lisp
    ;;;; CodingStyle
  (add-hook 'c++-mode-hook
            '(lambda ()

               ;; TODO: add comment here
               (setq c-macro-shrink-window-flag t)
               (setq c-macro-preprocessor "cpp")
               (setq c-macro-cppflags " ")
               (setq c-macro-prompt-flag t)

               ;; Use linux-kernel style
               (c-set-style "linux")

               ;; Setting indentation lvel
               (setq c-basic-offset 4)

               ;; Make TAB equivilent to 4 spaces
               (setq tab-width 4)

               ;; Use spaces to indent instead of tabs.
               (setq indent-tabs-mode nil)

               ;; Indent the continuation by 2
               (setq c-continued-statement-offset 2)

               ;; Brackets should be at same indentation level as the statements they open
               ;; for example:
               ;;                 if (0)        becomes        if (0)
               ;;                     {                        {
               ;;                        ;                         ;
               ;;                     }                        }
               (c-set-offset 'substatement-open '0)
               ;; make open-braces after a case
               (c-set-offset 'case-label '+)

               ))

#+end_src
#+begin_src emacs-lisp
  ;; use my cc-mode-common-setting
  ;;(add-hook 'c++-mode-hook 'coldnew-cc-mode-common-setting)

  ;;;; Auto Complete
  ;;;; ---------------------------------------------------------------------------

    ;; Default clang completion flags
    ;;    (setq clang-completion-flags
    (setq ac-clang-flags
          (split-string
           (concat
            "-pthread -I./ -I../ "
            (shell-command-to-string "pkg-config --cflags-only-I opencv gtk+-3.0"))))
#+end_src

*** Hooks
**** c-eldoc
#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook
            '(lambda ()
               ;; Enable c-eldoc
               (require 'c-eldoc)
               (setq c-eldoc-includes "`pkg-config gtk+-3.0 opencv --cflags --libs` -I./ -I../")
               (c-turn-on-eldoc-mode)))
#+end_src
**** 自動猜測縮排風格
#+begin_src emacs-lisp
  (when (require 'dtrt-indent nil 'noerror)
    (add-hook 'c++-mode-hook
              (lambda () (dtrt-indent-mode t))))
#+end_src
*** 自動補全設定
**** 載入其餘需要使用的套件。
#+begin_src emacs-lisp
  (require 'auto-complete-clang)
#+end_src
**** 設定用來補全的資訊。
#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook 'ac-cpp-mode-setup)
  (defun ac-cpp-mode-setup ()
    "auto-complete settings for c-mode."
    (setq ac-sources '(
                       ac-source-clang
                       ac-source-dictionary
                       ac-source-abbrev
                       ac-source-semantic
                       ac-source-filename
                       ac-source-files-in-current-dir
                       ac-source-words-in-same-mode-buffers
                       )))
#+end_src
*** 將 #if 0 #endif 區域上色為灰色

#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook 'cc-mode:highlight-if-0)
#+end_src

*** Keybinding
#+begin_src emacs-lisp
  (define-key c++-mode-map (kbd "C-x C-o") 'ff-find-other-file)
#+end_src
C-c  s             序找符号
C-c  g             寻找全局的定义
C-c  c             看看指定函数被哪些函数所调用
C-c  C             看看指定函数调用了哪些函数
C-c  e             寻找正则表达式
C-c  f             寻找文件
C-c  i             看看指定的文件被哪些文件 include
C-c  a             设定初始化的目录，一般是你代码的根目录
C-c  I             对目录中的相关文件建立列表并进行索引
#+begin_src emacs-lisp
  (define-key c++-mode-map (kbd "C-c s") 'cscope-find-this-symbol)
  (define-key c++-mode-map (kbd "C-c g") 'cscope-find-global-definition)
  (define-key c++-mode-map (kbd "C-c I") 'cscope-create-list-of-files-to-index)
 ;; remember to remove
  (define-key c++-mode-map (kbd "C-c f") 'cscope-find-this-file)
#+end_src
** CMake
*** 設定 CMake 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (require 'cmake-mode)
  (add-to-list 'auto-mode-alist '("\\.cmake\\'" . cmake-mode))
  (add-to-list 'auto-mode-alist '("CMakeLists\\.txt\\'" . cmake-mode))
#+end_src

** Common Lisp
*** 設定 Common Lisp 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.cl$" . lisp-mode))
#+end_src
** Clojure
*** 載入相關套件

#+begin_src emacs-lisp
  (require 'clojure-mode)
#+end_src

*** 設定 Clojure 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))
#+end_src

*** 啟用 rainbow-delimiters

#+begin_src emacs-lisp
  (add-hook 'clojure-mode-hook
            '(lambda ()
               (when (require 'rainbow-delimiters)
                 (rainbow-delimiters-mode-enable))))
#+end_src

*** 使用 nRepl

#+begin_src emacs-lisp
(require 'nrepl)
(require 'ac-nrepl)
#+end_src

*** 自動補全設定

#+begin_src emacs-lisp
  (add-hook 'clojure-mode-hook 'ac-clojure-mode-setup)
  (add-hook 'nrepl-mode-hook   'ac-clojure-mode-setup)
  (defun ac-clojure-mode-setup ()
    "auto-complete settings for clojure-mode."
    (setq ac-sources '(
                       ac-source-nrepl-ns
                       ac-source-nrepl-vars
                       ac-source-nrepl-ns-classes
                       ac-source-nrepl-all-classes
                       ac-source-nrepl-java-methods
                       ac-source-nrepl-static-methods
                       ac-source-dictionary
                       ac-source-abbrev
                       ac-source-semantic
                       ac-source-filename
                       ac-source-files-in-current-dir
                       ac-source-words-in-same-mode-buffers
                       )))
#+end_src

** Clojure Script
** Emacs Lisp
*** 設定 emacs-lisp 的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.el$" . emacs-lisp-mode))
#+end_src
*** Hooks
**** eldoc
eldoc 能夠將目前所使用的 elisp function 所需要的 argument 顯示在 minibuffer 上。
#+begin_src emacs-lisp
  (require 'eldoc)
  (require 'eldoc-extension)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
#+end_src

讓 pairedit 相容於 eldoc。
#+begin_src emacs-lisp
  (when (featurep 'paredit)
    (eldoc-add-command 'paredit-backward-delete 'paredit-close-round))
#+end_src

**** highlight-cl
高亮屬於 cl.el 套件的 function 或是 macro。
#+begin_src emacs-lisp
  (require 'highlight-cl)
  (add-hook 'emacs-lisp-mode-hook 'highlight-cl-add-font-lock-keywords)
#+end_src

*** 自動補全

#+begin_src emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'ac-emacs-lisp-mode-setup)
    (defun ac-emacs-lisp-mode-setup ()
        "auto-complete settings for emacs-lisp-mode"
        (setq ac-sources
              '(ac-source-symbols
                ac-source-variables
                ac-source-functions
                ac-source-features
                ac-source-filename
                ac-source-files-in-current-dir
                ac-source-words-in-same-mode-buffers
                )))
#+end_src
*** 快速插入樣板
#+begin_src emacs-lisp
  (setq emacs-lisp-mode-expand-alist
        '(("r" . "require")
          ("d" . "defun")
          ("l" . "lambda")
          ))
#+end_src

*** Functions
#+begin_src emacs-lisp
    (defun remove-elc-when-visit ()
      "After visit elisp file, remove .elc extension file."
      (make-local-variable 'find-file-hook)
      (add-hook 'find-file-hook
                (lambda ()
                  (if (and (file-exists-p (concat buffer-file-name "c"))
                           (file-writable-p (concat buffer-file-name "c")))
                      (delete-file (concat buffer-file-name "c"))))))
#+end_src

*** Keybinding

#+begin_src emacs-lisp

  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'backward-sexp)
               ))
#+end_src

** Go

*** 載入相關套件

#+begin_src emacs-lisp
(require 'go-mode)
#+end_src

*** 設定 go 的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.go$" . go-mode))
#+end_src

** QML
*** 設定 QML 的副檔名與對應的模式
#+begin_src emacs-lisp
  (require 'qml-mode)
  (add-to-list 'auto-mode-alist '("\\.qml$" . qml-mode))
#+end_src
*** 快速插入樣板
#+begin_src emacs-lisp
  (setq qml-mode-expand-alist
        '(("R" . "Rectangle")
          ("I" . "Item")
          ("M" . "MouseArea")
          ("L" . "ListModel")
          ("C" . "Component")
          ("T" . "Text")
          ("i" . "import")
          ))
#+end_src
*** 自動補全
#+begin_src emacs-lisp
  (add-hook 'qml-mode-hook 'ac-qml-mode-setup)
  (defun ac-qml-mode-setup ()
    "auto-complete settings for qml-mode"
    (setq ac-sources
          '(
            ac-source-dictionary
            ac-source-abbrev
            ac-source-filename
            ac-source-files-in-current-dir
            ac-source-words-in-same-mode-buffers
            )))
#+end_src
** qmake
*** 設定 qmake 的副檔名與對應的模式
#+begin_src emacs-lisp
  (require 'qmake-mode)
  (add-to-list 'auto-mode-alist '("\\.pro$" . qmake-mode))
#+end_src
** Scheme
*** 設定 Scheme 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.scm$" . scheme-mode))
#+end_src
** Perl
*** 設定 Perl 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pl" . perl-mode))
#+end_src
** Python
*** 設定 Python 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.py" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))
#+end_src
*** pymacs
**** 設定檔起始
#+begin_src emacs-lisp
  (eval-after-load "python-mode"
    '(progn
#+end_src
**** require
#+begin_src emacs-lisp
  (require 'pymacs)
#+end_src
**** TODO 讓 pymacs 找的到 rope 以及 ropemacs
我將 pymacs 必須使用的 rope、ropemacs、ropemode 安裝在 lisp 資料夾裏面，
必須設定 PATH 讓 pymacs 知道他們在哪。
#+begin_src emacs-lisp
;; no use?
;;  (setq pymacs-load-path '("~/.emacs.d/lisp/rope"
;;                          "~/.emacs.d/lisp/ropemacs"))
#+end_src
**** 設定 pymacs 使用的 python 版本
使用 python2.7
#+begin_src emacs-lisp
  (setenv "PYMACS_PYTHON" "python2.7")
#+end_src
**** 修改 ropemacs 預設的 keymap-prefix
#+begin_src emacs-lisp
  (setq ropemacs-enable-shortcuts nil)
  (setq ropemacs-local-prefix "C-c C-p")
  (setq ropemacs-global-prefix "C-c p")
#+end_src
**** 啟用 ropemacs
#+begin_src emacs-lisp
  (pymacs-load "ropemacs" "rope-")
#+end_src
**** 設定檔結速
#+begin_src emacs-lisp
  ))
#+end_src
*** 自動補全
#+begin_src emacs-lisp
(require 'ac-python)
#+end_src
** Verilog
*** 設定 verilog 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.v$" . verilog-mode))
#+end_src
*** 自動添加 *end //blockname* 註解
#+begin_src emacs-lisp
  (setq verilog-auto-endcomments t)
#+end_src
*** 按鍵設定
#+begin_src emacs-lisp
    (add-hook 'verilog-mode-hook
              '(lambda ()
                 (define-key verilog-mode-map (kbd "C-;") 'iedit-mode)
                 (auto-complete-mode)
                 ))
#+end_src
* 網頁開發                                                               :web:
** 網頁開發基本設定
*** 讓 emacs 能與 firefox 溝通
在讓 emacs 和 firefox 能互相溝通之前，兩邊都必須先裝上 moz-repl 這個外掛。
可以在 firefox 上的 moz-repl 選單，選擇 Active on startup 來確保當 firefox
啟動時會同時啟動 moz-repl
#+begin_src emacs-lisp
  (require 'moz)
#+end_src
*** 令 firefox 更新目前的頁面
#+begin_src emacs-lisp
  (defun firefox-refresh ()
    "Refresh the firefox browser"
    (interactive)
    (comint-send-string (inferior-moz-process)
                        "BrowserReload();"))
#+end_src
*** 整合 Javascript/HTML/CSS 色彩

#+begin_src emacs-lisp
  (require 'multi-web-mode)
  (setq mweb-default-major-mode 'html-mode)
  (setq mweb-tags
        '((php-mode "<\\?php\\|<\\? \\|<\\?=" "\\?>")
          (js-mode  "<script +\\(type=\"text/javascript\"\\|language=\"javascript\"\\)[^>]*>" "</script>")
          (css-mode "<style +type=\"text/css\"[^>]*>" "</style>")))
  (setq mweb-filename-extensions '("php" "htm" "html" "ctp" "phtml" "php4" "php5"))
  (multi-web-global-mode 1)
#+end_src

** CSS
*** 設定 CSS 的副檔名與對應的模式
#+begin_src emacs-lisp
  (require 'css-mode)
  (add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
#+end_src
** Less-CSS
*** 設定 LESS-CSS 的副檔名與對應的模式
#+begin_src emacs-lisp
  (require 'less-css-mode)
  (add-to-list 'auto-mode-alist '("\\.less$" . less-css-mode))
#+end_src
** JavaScript
*** 設定 javascript 的副檔名與對應的模式
使用 js2-mode 替代原本系統內建的 js-mode。
#+begin_src emacs-lisp
  (require 'js2-mode)
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src
*** 自動補全
#+begin_src emacs-lisp
  (add-hook 'js-mode-hook 'ac-javascript-mode-setup)
  (defun ac-javascript-mode-setup ()
    "auto-complete settings for javascript-mode"
    (setq ac-sources
          '(ac-source-dictionary
            ac-source-filename
            ac-source-files-in-current-dir
            ac-source-words-in-same-mode-buffers
            )))
#+end_src
*** REPL 設定
使用 js-comint 來設定 REPL 模式。
**** 設定起始位置
#+begin_src emacs-lisp
  (when (require 'js-comint nil 'noerror)
#+end_src
**** 設定 REPL 程式為 node.js
#+begin_src emacs-lisp
    (setq inferior-js-program-command "node")
#+end_src
**** 在 REPL 啟用 ANSI 色彩
#+begin_src emacs-lisp
;;  (add-hook 'js-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src
**** 設定終止位置
#+begin_src emacs-lisp
    )
#+end_src
** HTML
*** 使用 nxhtml 作為 HTML 編輯模式

#+begin_src emacs-lisp
;;  (require 'nxhtml)
;;  (defalias 'html-mode 'nxhtml-mode)
#+end_src

*** 使用 zencoding-mode 讓寫 HTML 更方便

#+begin_src emacs-lisp
  (require 'zencoding-mode)
  (add-hook 'html-mode-hook 'zencoding-mode)
#+end_src

*** 使用 impatient-mode 即時顯示網頁

#+begin_src emacs-lisp
  (require 'impatient-mode)
  (require 'simple-httpd)
  (require 'htmlize)

  (add-hook 'css-mode-hook 'impatient-mode)
  (add-hook 'html-mode-hook 'impatient-mode)
  (add-hook 'js-mode-hook 'impatient-mode)
#+end_src

* 狀態欄                                                           :modeline:
** TODO 分類
#+begin_src emacs-lisp :tangle no
  (line-number-mode t)
  (column-number-mode t)
  (size-indication-mode t)
#+end_src
** 顯示主模式

這個 function 用來定義如何顯示 major-mode，要放入 mode-line-format 才會真的顯示。

#+begin_src emacs-lisp
  (defun mode-line-major-mode ()
    "Get major-mode name with << >>."
    (concat "<< " (propertize mode-name 'face 'mode-line-mode-name-face) " >>"))
#+end_src

** 顯示 Evil 狀態

這個 function 用來定義如何顯示目前 evil-mode 的狀態，要放入 mode-line-format 才會真的顯示。

#+begin_src emacs-lisp
  (defun evil-mode-string ()
    (let ((evil-state-string (substring evil-mode-line-tag 2 3)))
      (setq evil-state-string-face
            (cond
             ((string= "N" evil-state-string) 'mode-line-evil-state-string-N)
             ((string= "I" evil-state-string) 'mode-line-evil-state-string-I)
             ((string= "V" evil-state-string) 'mode-line-evil-state-string-V)
             ((string= "E" evil-state-string) 'mode-line-evil-state-string-E)
             ))
      (concat "<" (propertize evil-state-string 'face evil-state-string-face) ">")
      ))
#+end_src

** 設定 Evil 狀態的色彩

為了能夠讓 Evil 不同狀態有不同的顏色，這邊定義了各種 evil-state 對應的顏色。

#+begin_src emacs-lisp
  (defface mode-line-read-only-face
    '((t (:foreground "#C82829" :bold t)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface mode-line-modified-face
    '((t (:inherit 'font-lock-function-name-face :bolt t)))
    "face for mode-name-string in modeline."
    :group'mode-lin)

  (defface mode-line-mode-name-face
    '((t (:inherit font-lock-keyword-face)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface mode-line-evil-state-string-N
    '((t (:inherit font-lock-function-name-face)))
    "face for vim-string in normal-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-I
    '((t (:inherit font-lock-constant-face)))
    "face for vim-string in insert-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-V
    '((t (:inherit font-lock-variable-name-face)))
    "face for vim-string in visual-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-E
    '((t (:inherit font-lock-string-face)))
    "face for vim-string in emacs-map on mode-line."
    :group 'mode-line)

  (defface font-lock-escape-char-face
    '((((class color)) (:foreground "seagreen2")))
    "highlight c escapes char like vim"
    :group 'font-lock-faces)
#+end_src

** 樣式設定

自己定義  mode-line 的樣式。

#+begin_src emacs-lisp
  (setq-default mode-line-format
                  '((" "
                     mode-line-mule-info
                     ;; read-only or modified status
                     (:eval
                      (cond (buffer-read-only
                             (propertize "RO" 'face 'mode-line-read-only-face))
                            ((buffer-modified-p)
                             (propertize "**" 'face 'mode-line-modified-face))
                            (t "--")))
                     "   "
                   ;;  (:eval (coldnew-editor-mode-string))
                     (when (featurep 'evil)
                       (:eval (evil-mode-string)))
                     "   "
                     ;;              (:eval (mode-line-state))
                     mode-line-buffer-identification
                     "   "
                     ;; major-mode name
                     (:eval (mode-line-major-mode))
                     "   "
                     ;; line and column
                     "("
                     (:eval (propertize "%02l" 'face 'font-lock-type-face))
                     ","
                     (:eval (propertize "%02c" 'face 'font-lock-type-face))
                     ")"

                     "   "
                     (vc-mode vc-mode)
                     "   "
                     ;; relative position, size of file
                     "["
                     (:eval (propertize "%p" 'face 'font-lock-constant-face)) ;; % above top
                     "/"
                     (:eval (propertize "%I" 'face 'font-lock-constant-face)) ;; size
                     "] "
                     )))
#+end_src
* 互動式命令                                                        :command:
** Buffer
*** 跳轉到 **scratch**

跳轉目前 buffer 與 **scratch**，假如 **scratch** 不存在，
則建立一個 major-mode 為 lisp-interaction-mode 的 **scratch**
#+begin_src emacs-lisp
  (defun scratch-toggle ()
    "Toggle between *scratch* buffer and the current buffer.
     If the *scratch* buffer does not exist, create it."
    (interactive)
    (let ((scratch-buffer-name (get-buffer-create "*scratch*")))
      (if (equal (current-buffer) scratch-buffer-name)
          (switch-to-buffer (other-buffer))
        ;;        (previous-user-buffer)
        (progn
          (switch-to-buffer scratch-buffer-name)
          (unless (equal major-mode 'lisp-interaction-mode)
            (lisp-interaction-mode))))))
#+end_src

*** save-buffer-always

預設的 save-buffer 在 buffer 沒有變動時，不會進行儲存，
使用此命令可以使得在呼叫 save-buffer-always 時，將 buffer 變更為修改過，
並進行儲存。
#+begin_src emacs-lisp
  (defun save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))
#+end_src

*** revert-all-buffer

#+begin_src emacs-lisp
(defun revert-all-buffers ()
  "Revert all non-modified buffers associated with a file.
This is to update existing buffers after a Git pull of their underlying files."
  (interactive)
  (save-current-buffer
    (mapc (lambda (b)
            (set-buffer b)
            (unless (or (null (buffer-file-name)) (buffer-modified-p))
              (revert-buffer t t)
              (message "Reverted %s\n" (buffer-file-name))))
          (buffer-list))))
#+end_src

*** nuke-all-buffers

關閉除了 **scratch** 以外的所有 buffer。
#+begin_src emacs-lisp
  (defun nuke-all-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapcar (lambda (x) (kill-buffer x)) (buffer-list))
    (delete-other-windows))
#+end_src

*** 清除除了目前的緩衝區以外的緩衝區

#+begin_src emacs-lisp
    (defun kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+end_src
** 其他、未歸類
*** 縮排整個 buffer
#+begin_src emacs-lisp
  (defun indent-whole-buffer ()
    "Indent whole buffer and delete trailing whitespace.
  This command will also do untabify."
    (interactive)
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max))
    (untabify (point-min) (point-max)))
#+end_src

*** 縮牌區域或是整個 buffer

#+begin_src emacs-lisp
  (defun indent-region-or-buffer ()
    "Indents a region if selected, otherwise the whole buffer."
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (delete-trailing-whitespace (region-beginning) (region-end))
            (indent-region (region-beginning) (region-end))
            (untabify (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-region-or-buffer)
          (message "Indented buffer.")))))
#+end_src

*** TODO rewrite

#+begin_src emacs-lisp
  (defun align-code (beg end &optional arg)
    (interactive "rP")
    (if (null arg)
        (align beg end)
      (let ((end-mark (copy-marker end)))
        (indent-region beg end-mark nil)
        (align beg end-mark))))
#+end_src
#+begin_src emacs-lisp
  (defun mark-line (&optional arg)
    (interactive "p")
    (beginning-of-line)
    (let ((here (point)))
      (dotimes (i arg)
        (end-of-line))
      (set-mark (point))
      (goto-char here)))
  (defun mark-sentence (&optional arg)
    (interactive "P")
    (backward-sentence)
    (mark-end-of-sentence arg))
(defun delete-indentation-forward ()
  (interactive)
  (delete-indentation t))
(defun delete-current-line (&optional arg)
  (interactive "p")
  (let ((here (point)))
    (beginning-of-line)
    (kill-line arg)
    (goto-char here)))
#+end_src
#+begin_src emacs-lisp
  (defun window-horizontal-to-vertical ()
    "Switches from a horizontal split to a vertical split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-horizontally)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))

  (defun window-vertical-to-horizontal ()
    "Switches from a vertical split to a horizontal split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-vertically)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))

  (defun my-column-ruler (width)
    "Display temp ruler at point."
    (interactive `(,(+ (window-hscroll)(window-width))))
    (momentary-string-display
     (let* ((iterations (/ (1- width) 10))
            (result1 "|...|....|")
            (result2 "1   5   10")
            (inc1 "....|....|")
            (inc2 "        %d0")
            (i 1))
       (while  (<= i iterations)
         (setq i (1+ i))
         (setq result1 (concat result1 inc1))
         (setq result2 (concat result2 (substring (format inc2 i) -10))))
       (concat (substring result2 0 width) "\n"
               (substring result1 0 width) "\n"))
     (line-beginning-position)
     nil "[space]Clears ruler"))

#+end_src

#+begin_src emacs-lisp
  (defun swap-with (dir)
    (interactive)
    (let ((other-window (windmove-find-other-window dir)))
      (when other-window
        (let* ((this-window (selected-window))
               (this-buffer (window-buffer this-window))
               (other-buffer (window-buffer other-window))
               (this-start (window-start this-window))
               (other-start (window-start other-window)))
          (set-window-buffer this-window other-buffer)
          (set-window-buffer other-window this-buffer)
          (set-window-start this-window other-start)
          (set-window-start other-window this-start)))))

  ;; (global-set-key (kbd "C-M-J") (lambda () (interactive) (swap-with 'down)))
  ;; (global-set-key (kbd "C-M-K") (lambda () (interactive) (swap-with 'up)))
  ;; (global-set-key (kbd "C-M-H") (lambda () (interactive) (swap-with 'left)))
  ;; (global-set-key (kbd "C-M-L") (lambda () (interactive) (swap-with 'right)))

  ;; (global-set-key (kbd "M-J") (lambda () (interactive) (enlarge-window 1)))
  ;; (global-set-key (kbd "M-K") (lambda () (interactive) (enlarge-window -1)))
  ;; (global-set-key (kbd "M-H") (lambda () (interactive) (enlarge-window -1 t)))
  ;; (global-set-key (kbd "M-L") (lambda () (interactive) (enlarge-window 1 t)))


  (defun select-forwards-to-before-match (match)
    "Selects forwards to just before next match, uses
  select-region-to-before-match"
    (interactive "MSelect forwards to just before: ")
    (select-region-to-before-match match 'forwards))

  (defun select-backwards-to-before-match (match)
    "Selects backwards to just before next match, uses
  select-region-to-before-match"
    (interactive "MSelect backwards to just before: ")
    (select-region-to-before-match match 'backwards))

  (defun kill-forwards-to-before-match (match)
    "Selects forwards to just before next match, uses
  select-region-to-before-match, then kills that region."
    (interactive "MKill forwards to just before: ")
    (let* ((positions (select-region-to-before-match match 'forwards))
           (start (car positions))
           (end (cadr positions)))
      (kill-region start end)))

  (defun kill-backwards-to-before-match (match)
    "Selects backwards to just before next match, uses
  select-region-to-before-match, then kills that region."
    (interactive "MKill backwards to just before: ")
    (let* ((positions (select-region-to-before-match match 'backwards))
           (start (car positions))
           (end (cadr positions)))
      (kill-region start end)))

  (defun match-paren (arg)
    "Go to the matching paren if on a paren; otherwise insert %."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
          (t (self-insert-command (or arg 1)))))



  (defun cua-set-mark-or-rectangle-mark (&optional arg)
    "toggle between cua-set-mark or cua-rectangle-mark"
    (interactive "P")
    (if (or (not mark-active) arg)
        (cua-set-mark arg)
      (cua-toggle-rectangle-mark)))



  (defadvice kill-ring-save (before slickcopy activate compile)
    "When called interactively with no active region, copy a single line
  instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slickcut activate compile)
    "When called interactively with no active region, kill a single line
  instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defun zap-up-to-char-backward (arg char)
    (interactive "p\ncZap up to char backward: ")
    (zap-up-to-char (- arg) char))

  (defun go-to-char (arg char)
    (interactive "p\ncGo to char: ")
    (forward-char 1)
    (if (if arg
            (search-forward (char-to-string char) nil nil arg)
          (search-forward (char-to-string char)))
        (backward-char 1)))

  (defun go-back-to-char (arg char)
    (interactive "p\ncGo back to char: ")
    (forward-char -1)
    (if arg
        (search-backward (char-to-string char) nil nil arg)
      (search-backward (char-to-string char))))

  (defun vjo-forward-current-word-keep-offset ()
    " (Vagn Johansen 1999)"
    (interactive)
    (let ((re-curword) (curword) (offset (point))
          (old-case-fold-search case-fold-search) )
      (setq curword (thing-at-point 'symbol))
      (setq re-curword (concat "\\<" (thing-at-point 'symbol) "\\>") )
      (beginning-of-thing 'symbol)
      (setq offset (- offset (point)))    ; offset from start of symbol/word
      (setq offset (- (length curword) offset)) ; offset from end
      (forward-char)
      (setq case-fold-search nil)
      (if (re-search-forward re-curword nil t)
          (backward-char offset)
        ;; else
        (progn (goto-char (point-min))
               (if (re-search-forward re-curword nil t)
                   (progn (message "Searching from top. %s" (what-line))
                          (backward-char offset))
                 ;; else
                 (message "Searching from top: Not found"))
               ))
      (setq case-fold-search old-case-fold-search)
      ))

  (defun vjo-backward-current-word-keep-offset ()
    " (Vagn Johansen 2002)"
    (interactive)
    (let ((re-curword) (curword) (offset (point))
          (old-case-fold-search case-fold-search) )
      (setq curword (thing-at-point 'symbol))
      (setq re-curword (concat "\\<" curword "\\>") )
      (beginning-of-thing 'symbol)
      (setq offset (- offset (point)))    ; offset from start of symbol/word
      (forward-char)
      (setq case-fold-search nil)
      (if (re-search-backward re-curword nil t)
          (forward-char offset)
        ;; else
        (progn (goto-char (point-max))
               (if (re-search-backward re-curword nil t)
                   (progn (message "Searching from bottom. %s" (what-line))
                          (forward-char offset))
                 ;; else
                 (message "Searching from bottom: Not found"))
               ))
      (setq case-fold-search old-case-fold-search)
      ))

  ;; ;; FIXME: need to test
  ;; (defun set-frame-size-according-to-resolution ()
  ;;   (interactive)
  ;;   (if window-system
  ;;       (progn
  ;;      (if (> (x-display-pixel-width) 1500) ;; 1500 is the delimiter marging in px to consider the screen big
  ;;          (set-frame-width (selected-frame) 237) ;; on the big screen make the fram 237 columns big
  ;;        (set-frame-width (selected-frame) 177)) ;; on the small screen we use 177 columns
  ;;      (setq my-height (/ (- (x-display-pixel-height) 150) ;; cut 150 px of the screen height and use the rest as height for the frame
  ;;                         (frame-char-height)))
  ;;      (set-frame-height (selected-frame) my-height)
  ;;      (set-frame-position (selected-frame) 3 90) ;; position the frame 3 pixels left and 90 px down
  ;;      )))

  ;; (set-frame-size-according-to-resolution)
  ;;  (global-set-key (kbd "C-x 9") 'set-frame-size-according-to-resolution)

  (defun open-in-largest-window()
    "Open current buffer in largest window"
    (interactive)
    (let ((oldbuf (current-buffer)))
      (select-window (get-largest-window))
      (switch-to-buffer oldbuf))
    )
  ;;(global-set-key (kbd "C-x 5") 'open-in-largest-window)

#+end_src

** 檔案處理
*** find-files
#+begin_src emacs-lisp
  (defun find-files (files)
    "Open the given files"
    (interactive)
    (foreach (f files) (find-file f)))
#+end_src
*** my-clone-and-open-file
#+begin_src emacs-lisp
  (defun my-clone-and-open-file (filename)
    "Clone the current buffer writing it into FILENAME and open it"
    (interactive "FClone to file: ")
    (save-restriction
      (widen)
      (write-region (point-min) (point-max) filename nil nil nil 'confirm))
    (find-file filename))
#+end_src
** 視窗
*** 將整個 emacs 全螢幕
#+begin_src emacs-lisp
  (defun fullscreen-window ()
    "Make the window full-screen."
    (interactive)
    (let ((current-value (frame-parameter nil 'fullscreen))
          (old-value nil))
      (set-frame-parameter nil 'fullscreen
                           (if (equal 'fullboth current-value)
                               'old-value
                             (progn
                               (setq old-value current-value)
                               'fullboth)))))
#+end_src
#+begin_src emacs-lisp
  (defun collapse-or-expand ()
    (interactive)
    (if (> (length (window-list)) 1)
        (delete-other-windows)
      (bury-buffer)))
#+end_src
#+begin_src emacs-lisp
  (defun gitg ()
    "Launch gitg in the current directory."
    (interactive)
    (start-process "gitg" nil "gitg"))


  (defun windmove-down-fullscreen ()
    "Select window below current one and make it fullscreen."
    (interactive)
    (if (windmove-down)
        (delete-other-windows)))

  (defun windmove-up-fullscreen ()
    "Select window above the current one and make it fullscreen."
    (interactive)
    (if (windmove-up)
        (delete-other-windows)))

  (defun windmove-left-fullscreen ()
    "Select window left to current one and make it fullscreen."
    (interactive)
    (if (windmove-left)
        (delete-other-windows)))

  (defun windmove-right-fullscreen ()
    "Select window right to current one and make it fullscreen."
    (interactive)
    (if (windmove-right)
        (delete-other-windows)))

  (defun sudo-edit (&optional arg)
    "Edit file with sudo in emacs"
    (interactive "p")
    (if (or arg (not buffer-file-name))
        ;; (find-file (concat "/sudo:root@localhost:" (anything-read-file-name "File: ")))
        (find-file (concat "/sudo:root@localhost:" (read-file-name "File: ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

(setq tramp-debug-buffer t)
(setq tramp-chunksize 500)


  (defun toggle-selective-display (column)
    (interactive "P")
    (set-selective-display
     (if selective-display nil (or column 1))))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Insert
  ;;; ---------------------------------------------------------------------------
  (require 'mm-url)

  (defun insert-tinyurl (url)
    "Insert a shortend URL at point by passed in URL"
    (interactive "sEnter url: " )
    (let* ((url (replace-regexp-in-string "^http://" "" url))
           (tinyurl
            (save-excursion
              (with-temp-buffer
                (mm-url-insert
                 (concat "http://tinyurl.com/api-create.php?url=http://" url))
                (kill-ring-save (point-min) (point-max))
                (buffer-string)))))
      (insert tinyurl)))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Search
  ;;;; ---------------------------------------------------------------------------
  (defun multi-occur-in-this-mode ()
    "Show all lines matching REGEXP in buffers with this major mode."
    (interactive)
    (multi-occur
     (get-buffers-matching-mode major-mode)
     (car (occur-read-primary-args)))
    (select-window (get-buffer-window "*Occur*")))

  ;;;; ---------------------------------------------------------------------------
  ;;;; key-macro
  ;;;; ---------------------------------------------------------------------------
  (defun toggle-kbd-macro-recording-on ()
    "One-key keyboard macros: turn recording on."
    (interactive)
    (define-key
      global-map
      (this-command-keys)
      'toggle-kbd-macro-recording-off)
    (start-kbd-macro nil))

  (defun toggle-kbd-macro-recording-off ()
    "One-key keyboard macros: turn recording off."
    (interactive)
    (define-key
      global-map
      (this-command-keys)
      'toggle-kbd-macro-recording-on)
    (end-kbd-macro))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Commands that define for key-chord
  ;;;; ---------------------------------------------------------------------------
  (defun upcase-word-backward ()
    "upcase word backward."
    (interactive)
    (upcase-word -1))

  (defun downcase-word-backward ()
    "downcase word backward."
    (interactive)
    (downcase-word -1))

  (defun capitalize-word-backward ()
    "captialize word backward."
    (interactive)
    (capitalize-word -1))

  (defun backward-kill-line (arg)
    "Kill chars backward until encountering the end of a line."
    (interactive "p")
    (kill-line 0))
#+end_src
** 插入
*** 插入時間
#+begin_src emacs-lisp
  (defun insert-date-time ()
    "Insert current-date."
    (interactive)
    (insert (current-date-time)))
#+end_src
*** 插入空白行
#+begin_src emacs-lisp
  (defun insert-empty-line ()
    "Insert an empty line after current line and position cursor on newline."
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line 1))
#+end_src
*** 多次貼上
emacs 本身的 yank 命令是無法使用 universla-argument 的，
也就是說無法使用 C-u 80 C-y 來貼上複製的東西 80 次，
而是貼上前幾次紀錄在 kill-ring 的資訊。

yank-n-times 則可以重複的進行貼上。

當沒有使用 universal-argument 指定要貼上多少次時，
會使用 prompt 詢問貼上的次數。
#+begin_src emacs-lisp
  (defun yank-n-times (&optional arg)
    "yank multiple times."
    (interactive "P")
    (let ((times (if (equal current-prefix-arg nil)
                     (read-number "yank repet times: ")
                   arg)))
      (if (< times 1)
          (setq times 1)
        (dotimes 'times (yank)))))
#+end_src
** 刪除
*** 刪除相對應的括號
#+begin_src emacs-lisp
  (defun delete-between-pair (char)
    "Delete in between the given pair"
    (interactive "cDelete between pair: ")
    (let ((pair-char))
      (search-backward-to-char char)
      (forward-char 1)
      (cond
       ((char-equal char ?\() (setq pair-char ?\)))
       ((char-equal char ?\") (setq pair-char ?\"))
       ((char-equal char ?\') (setq pair-char ?\'))
       ((char-equal char ?\[) (setq pair-char ?\]))
       ((char-equal char ?\{) (setq pair-char ?\}))
       ((char-equal char ?\<) (setq pair-char ?\>)))
      (zap-up-to-char 1 pair-char)))
#+end_src

*** 刪除一個 '字'
#+begin_src emacs-lisp
  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-region (point) (progn (forward-word arg) (point))))

#+end_src

*** 向左刪除一個 '字'
#+begin_src emacs-lisp
  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))
#+end_src
*** 刪除目前的檔案與 buffer
#+begin_src emacs-lisp
  (defun delete-file-and-buffer ()
    "Kills the current buffer and deletes the file it is visiting"
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
        (delete-file filename)
        (message "Deleted file %s" filename)))
    (kill-buffer))
#+end_src
** 轉換
*** 將 unix 格式的文件轉換成 dos 格式
#+begin_src emacs-lisp
  (defun unix2dos ()
    "Convert buffer file from unix file to dos file."
    (interactive)
    (unix->dos (current-buffer)))
#+end_src
*** 將 dos 格式的文件轉換成 unix 格式
#+begin_src emacs-lisp
  (defun dos2unix ()
    "Convert buffer file from dos file to unix file."
    (interactive)
    (dos->unix (current-buffer)))
#+end_src
*** 將 buffer 的編碼改成 utf8
#+begin_src emacs-lisp
  (defun encode-to-utf8 ()
    "Sets the buffer-file-coding-system to UTF8."
    (interactive)
    (set-buffer-file-coding-system 'utf-8 nil))
#+end_src
*** eval-and-replace
將前面的 sexp 刪除並進行 eval 的動作，如果 eval 失敗則還原前面的 sexp。
#+begin_src emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
#+end_src
*** expand-last-sexp
#+begin_src emacs-lisp
  (defun expand-last-sexp ()
    "Expand macro from sexp before point;print value in pp eval buffer"
    (interactive)
    (pp-eval-expression '(macroexpand (read (thing-at-point 'sexp)))))
#+end_src
* 窗口管理
** popwin

popwin is a popup window manager for Emacs which makes you free from the hell of annoying buffers such like *Help*, *Completions*, *compilation*, and etc.
Take an example. When you complete file names during find-file, the (annoying) *Completions* buffer will appear in a newly splitted window.
You might understand the necessity of the window, but you may wonder why the window still remains after completion...
popwin resolves there problems. Windows of such temporary buffers will be shown as a popup window, and you can close them smoothly by typing C-g in anytime.

#+begin_src emacs-lisp
  (require 'popwin)
  (setq display-buffer-function 'popwin:display-buffer)
#+end_src

** 使用 winner-mode 快速切換窗口佈局

winner-mode 是 emacs 自帶的窗口佈局管理器，可以對窗口的改變進行 undo/redo 的動作。

*** 載入相關套件

#+begin_src emacs-lisp
  (require 'winner)
#+end_src

*** 不使用 winner 預設的按鍵

#+begin_src emacs-lisp
  (setq winner-dont-bind-my-keys t)
#+end_src

*** 全域啟用 winner-mode

#+begin_src emacs-lisp
  (winner-mode t)
#+end_src

*** winner-mode 按鍵設定                                         :global@key:

| 按鍵 | 命令        | 用途                               |
|------+-------------+------------------------------------|
| M-[  | winner-undo | 回復上一個窗口佈局                 |
| M-]  | winner-redo | 切回上一組進行窗口復原時的窗口佈局 |

#+begin_src emacs-lisp
  (global-set-key (kbd "M-[") 'winner-undo)
  (global-set-key (kbd "M-]") 'winner-redo)
#+end_src

* Google 翻譯

google-translate 套件提供 emacs 透過 google 的 API 進行翻譯的動作。

** 載入相關套件

#+begin_src emacs-lisp
  (require 'google-translate)
#+end_src

** 預設設定為 正體中文 -> 英文

#+begin_src emacs-lisp
  (setq google-translate-default-source-language "zh-TW")
  (setq google-translate-default-target-language "en")
#+end_src

** 將英文翻譯為中文

#+begin_src emacs-lisp
  (defun google-translate-en-zh ()
    "Translate English to Tranditional Chinese by google-translate."
    (interactive)
    (let ((google-translate-default-source-language "en")
          (google-translate-default-target-language "zh-TW"))
      (google-translate-query-translate)))
#+end_src

** 將中文翻譯為英文

#+begin_src emacs-lisp
  (defun google-translate-zh-en ()
    "Translate Tranditional Chinese to English by google-translate."
    (interactive)
    (let ((google-translate-default-source-language "zh-TW")
          (google-translate-default-target-language "en"))
      (google-translate-query-translate)))
#+end_src

* 聊天軟體                                                             :chat:
** IRC

emacs 底下最常用的 IRC 軟體為 ERC 和 RCIRC，這邊我選用 ERC 作為 IRC 客戶端。

*** 載入相依套件

#+begin_src emacs-lisp
  (require 'erc)
  (require 'erc-notify)
  (require 'erc-spelling)
  (require 'erc-autoaway)
#+end_src

*** 設定 prompt 為 >>

#+begin_src emacs-lisp
  (setq erc-prompt ">>")
#+end_src

*** 編碼設定為 utf-8

#+begin_src emacs-lisp
  (setq erc-server-coding-system '(utf-8 . utf-8))
#+end_src

*** 當 ERC 啟動時，自動連入 IRC 伺服器

#+begin_src emacs-lisp
  (erc-autojoin-mode t)
#+end_src

*** 自動連線的伺服器與聊天室

#+begin_src emacs-lisp
  (setq erc-autojoin-channels-alist
        '(;; english channel
          (".*\\.freenode.net" "#emacs" "#clojure" "##linux" "#gentoo")
          ;; Chinese channel
          (".*\\.freenode.net" "#emacs.tw" "#tossug")
          (".*\\.oftc.net" "#dot")
          ))
#+end_src

*** 關閉部份訊息顯示

#+begin_src emacs-lisp
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src

*** 加入時間戳

#+begin_src emacs-lisp
  (erc-timestamp-mode 1)
#+end_src

*** 紀錄聊天訊息
**** 載入相依套件

#+begin_src emacs-lisp
  (require 'erc-log)
#+end_src

**** 啟動 erc-log-mode

#+begin_src emacs-lisp
  (erc-log-mode 1)
#+end_src

**** 設定紀錄檔儲存位置

#+begin_src emacs-lisp
  (setq erc-log-channels-directory emacs-log-dir)
#+end_src

**** 如果儲存紀錄檔的資料夾不存在，建立他

#+begin_src emacs-lisp
  (unless (file-exists-p erc-log-channels-directory)
    (mkdir erc-log-channels-directory t))
#+end_src

**** 紀錄檔編碼為 utf-8

#+begin_src emacs-lisp
  (setq erc-log-file-coding-system 'utf-8)
#+end_src

**** 送出訊息後寫入到 log

#+begin_src emacs-lisp
  (setq erc-log-write-after-send t)
#+end_src

**** 當有新訊息時，寫入到log

#+begin_src emacs-lisp
  (setq erc-log-write-after-insert t)
#+end_src

*** 設定聊天時的行寬為 100

#+begin_src emacs-lisp
  (setq erc-fill-column 100)
#+end_src

*** 為聊天室裡的使用者暱稱上色

#+begin_src emacs-lisp
  (and
   (require 'erc-highlight-nicknames)
   (add-to-list 'erc-modules 'highlight-nicknames)
   (erc-update-modules))
#+end_src

*** Misc

#+begin_src emacs-lisp
  ;; check channels
  ;; exclude boring stuff from tracking
  (erc-track-mode t)
  (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"

                                  "324" "329" "332" "333" "353" "477"))
  ;; Interpret mIRC-style color commands in IRC chats
  (setq erc-interpret-mirc-color t)
  ;; The following are commented out by default, but users of other
  ;; non-Emacs IRC clients might find them useful.
  ;; Kill buffers for channels after /part
  (setq erc-kill-buffer-on-part t)
  ;; Kill buffers for private queries after quitting the server
  (setq erc-kill-queries-on-quit t)
  ;; Kill buffers for server messages after quitting the server
  (setq erc-kill-server-buffer-on-quit t)
  ;; open query buffers in the current window
  (setq erc-query-display 'buffer)
  (setq erc-save-buffer-on-part t)
  (defadvice save-buffers-kill-emacs (before save-logs (arg) activate)
    (save-some-buffers t (lambda () (when (eq major-mode 'erc-mode) t))))
  ;; truncate long irc buffers
  (erc-truncate-mode +1)
  ;; enable spell checking
  (erc-spelling-mode 1)
  ;; autoaway setup
  (setq erc-auto-discard-away t)
  (setq erc-autoaway-idle-seconds 600)
  (setq erc-autoaway-use-emacs-idle t)
#+end_src

*** Commands

#+begin_src emacs-lisp
  (defun i-wanna-be-social ()
    "Connect to IM networks using bitlbee."
    (interactive)
    (erc :server "localhost" :port 6667 :nick "user"))
#+end_src
#+begin_src emacs-lisp
  (defun erc-cmd-WII (nick &rest ignore)
    "`/WHOIS' command with extra user information."
    (erc-send-command (mapconcat #'identity
                                 (list "WHOIS" nick nick) " ")))
  (defun erc-cmd-IDENTIFY (password &rest ignore)
    "Short-hand alias for `/msg NickServ identify PASS'."
    (erc-send-command (mapconcat #'identity
                                 (list "identify" password) " ")))
  (defun erc-cmd-CS (&rest args)
    "Short alias for `/chanserv ARGS'."
    (let ((command-args (append (list "CHANSERV") args)))
      (let ((chanserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command chanserv-command))))

  (defun erc-cmd-MS (&rest args)
    "Short alias for `/memoserv ARGS'."
    (let ((command-args (append (list "MEMOSERV") args)))
      (let ((memoserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command memoserv-command))))

  (defun erc-cmd-NS (&rest args)
    "Short alias for `/nickserv ARGS'."
    (let ((command-args (append (list "NICKSERV") args)))
      (let ((nickserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command nickserv-command))))
#+end_src

*** Function

#+begin_src emacs-lisp
(defun avoid-erc-oops (txt)
  (when (member txt '("ls" "xb" "cd"))
      (setq erc-send-this nil)))

(add-to-list 'erc-send-pre-hook 'avoid-erc-oops)
#+end_src

*** Command

#+begin_src emacs-lisp
  (defun irc ()
    (interactive)
    (erc :server "irc.freenode.net" :port 6667 :nick erc-nick)
    (erc :server "irc.debian.org" :port 6667 :nick erc-nick))
#+end_src

* 電子郵件
** offlineimap
*** 載入套件
#+begin_src emacs-lisp
  (require 'offlineimap)
#+end_src
*** 取得 offlineimap 的密碼

offlineimap 可以在設定中加入

: pythonfile = ~/.offlineimap.py

來載入額外的 function ，我在這個檔案裏面加入了

#+begin_src python :tangle no
  #!/usr/bin/env python

  import subprocess

  def get_output(cmd):
      # Bunch of boilerplate to catch the output of a command:
      pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
      (output, errout) = pipe.communicate()
      assert pipe.returncode == 0 and not errout
      return output

  def get_password_emacs(host):
      cmd = "emacsclient --eval '(offlineimap-get-password \"%s\")'" % (host)
      return get_output(cmd).strip().lstrip('"').rstrip('"')
#+end_src

讓 offlineimap 可以透過 get_password_emacs() 來從 emacs 裏面取得密碼。

#+begin_src emacs-lisp
  (defun offlineimap-get-password (account)
    (require 'netrc)
    ;;(if (file-exists-p emacs-authinfo-file) (load-file emacs-authinfo-file))
    (or (netrc-get offlineimap-account-list account) ""))
#+end_src

在我的 ~/.authinfo.gpg 檔案內容是像這樣的


#+begin_src emacs-lisp :tangle no
  ;; -*- mode: emacs-lisp -*-

  ;;;; offlineimap
  (setq offlineimap-account-list
        '(("account@mail.com" . "password")
          ))
#+end_src

因此，在 .offlineimaprc 裏面加入這樣一行

: remotepasseval = get_password_emacs("account@mail.com")

即可透過 emacs 取得 password 這個密碼。

** smtp
*** 取得 smtp 的密碼

在我的 ~/.authinfo.gpg 檔案內容是像這樣的


#+begin_src emacs-lisp :tangle no
  ;; -*- mode: emacs-lisp -*-

  ;;;; smtp
  (setq smtp-account-list
        '(("account@gmail.com"
           ("smtp.gmail.com" 587 "account@gmail.com" "password"))
          ))
#+end_src

#+begin_src emacs-lisp
  (defvar smtp-account-list nil)
    (defun smtp-get-password (account)
      (require 'netrc)
      ;;(if (file-exists-p emacs-authinfo-file) (load-file emacs-authinfo-file))
      (or (netrc-get smtp-account-list account) ""))
#+end_src

** mu4e
*** 載入套件
#+begin_src emacs-lisp
  (require 'mu4e)
#+end_src
*** 使用 offlineimap 取得郵件

#+begin_src emacs-lisp
  (setq mu4e-get-mail-command "offlineimap")
#+end_src

*** 設定 mu4e 為預設的 email 系統

#+begin_src emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

*** 設定最頂層的郵件資料夾

#+begin_src emacs-lisp
  (setq mu4e-maildir "~/Maildir")
#+end_src

*** 設定我的 email 帳戶列表

#+begin_src emacs-lisp
  (setq coldnew/mu4e-account-alist
        '(("Gmail"
           (mu4e-sent-folder "/Gmail/Sent")
           (mu4e-drafts-folder "/Gmail/Drafts")
           (mu4e-trash-folder "/Gmail/Trash")
           (user-mail-address "coldnew.tw@gmail.com")
           ;; Sent mail
           (message-send-mail-function 'smtpmail-send-it)
           (smtpmail-stream-type 'starttls)
           (smtpmail-smtp-server "smtp.gmail.com")
           (smtpmail-smtp-service 587)
           (smtpmail-smtp-user user-mail-address)
           (smtpmail-auth-credentials (smtp-get-password smtpmail-smtp-user))
           )
          ("Weintek"
           (mu4e-sent-folder "/Weintek/Sent")
           (mu4e-drafts-folder "/Weintek/Drafts")
           (mu4e-trash-folder "/Weintek/Trash")
           (user-mail-address "yenchin@weintek.com"))))
#+end_src

*** 設定預設的帳戶為 Gmail

#+begin_src emacs-lisp
  (defun coldnew/mu4e-set-default-account (account)
    "Setup the default account based on coldnew/mu4e-account-alist."
    (let* ((account (cdr (assoc account coldnew/mu4e-account-alist))))
      (when account (mapc #'(lambda (a)
                              (set (car a) (if (stringp (cadr a)) (cadr a) (eval (cadr a))))) account))))
                              ;;(set (car a) (cadr a))) account))))

  (coldnew/mu4e-set-default-account "Gmail")

#+end_src
*** 每隔 60秒 重新抓取郵件

#+begin_src emacs-lisp
  (setq mu4e-update-interval 60)
#+end_src

*** 在郵件中顯示圖片

#+begin_src emacs-lisp
  (setq mu4e-view-show-images t)
#+end_src

*** 使用 w3m 將 HTML 轉換為 text 檔

#+begin_src emacs-lisp
  (setq mu4e-html2text-command "w3m -dump -T text/html")

#+end_src

*** TODO 未整理
#+begin_src emacs-lisp
  (setq starttls-use-gnutls t)

  (defun mu4e~view-fontify-diff ()
    "Colorize diff message."
    (interactive)
    (let ((inhibit-read-only t))
      (save-excursion
        (goto-char (point-min))
        ;; consider only lines that heuristically look like a citation line...
        (while (re-search-forward "^\\(\\(\\+\\)[^+]\\|\\(-\\)[^-]\\)" nil t)
          (let ((cur-point (or (match-beginning 2) (match-beginning 3)))
                (color (if (match-beginning 2)
                           "green"
                         "deep pink")))
            (end-of-line)
            (add-text-properties cur-point (point)
                                 `(face ((foreground-color . ,color))))))
        (goto-char (point-min))
        (while (re-search-forward "^\\(\\+\\+\\+\\|---\\)" nil t)
          (let ((cur-point (match-beginning 1)))
            (end-of-line)
            (add-text-properties cur-point (point)
                                 '(face ((weight . bold)))))))))

  (add-hook 'mu4e-view-mode-hook 'mu4e~view-fontify-diff)
#+end_src

#+begin_src emacs-lisp
  (defun coldnew/mu4e-set-account ()
    "Set the account for composing a message."
    (interactive)
    (let* ((account
            (if mu4e-compose-parent-message
                (let ((maildir (mu4e-msg-field mu4e-compose-parent-message :maildir)))
                  (string-match "/\\(.*?\\)/" maildir)
                  (match-string 1 maildir))
              (completing-read (format "Compose with account: (%s) "
                                       (mapconcat #'(lambda (var) (car var)) coldnew/mu4e-account-alist "/"))
                               (mapcar #'(lambda (var) (car var)) coldnew/mu4e-account-alist)
                               nil t nil nil (caar coldnew/mu4e-account-alist))))
           (account-vars (cdr (assoc account coldnew/mu4e-account-alist))))
      (if account-vars
          (mapc #'(lambda (var)
                    (set (car var) (cadr var)))
                account-vars))))

  (add-hook 'mu4e-compose-pre-hook 'coldnew/mu4e-set-account)
#+end_src
* Alias                                                               :alias:
** Misc
#+begin_src emacs-lisp
  (defalias 'coldnew/set-mark-command 'cua-set-mark-or-rectangle-mark)
  (defalias 'coldnew/folding-toggle   'toggle-selective-display)
#+end_src
* Git 版本管理

git 是我最喜歡用的版本管理器，當然能夠在 emacs 下使用是最好的， emacs
有許多好用的 git 套件，諸如 egg, magit, git-emacs 之類，在這邊的設定
我整合了這幾種工具，選用我最喜歡的功能。

** 載入套件

#+begin_src emacs-lisp
  (require 'egg)
  (require 'magit)
  (require 'git-emacs)
#+end_src

** 命令綁定、縮寫                                                    :alias:

由於我用了很多 git 的程式，這邊綁定命令到我想用的程式去

#+begin_src emacs-lisp
  (defalias 'git-log    'egg-log)
  (defalias 'git-status 'egg-status)
  (defalias 'git-commit 'egg-commit-log-edit)
  (defalias 'git-rebase 'magit-rebase-step)
  (defalias 'git-push   'magit-push)
  (defalias 'git-add-remote 'magit-add-remote)
#+end_src

** 當檔案儲存時不自動將其加入 commit 中

egg 有一個很不錯的功能，就是當檔案儲存的時候，自動將其加入到 commit
當中，不過我用起來實在是很不習慣，所以把他 disable 掉。

#+begin_src emacs-lisp
  (setq egg-auto-update nil)
#+end_src

** 讓 egg 自動猜測下一個動作

我很喜歡 vc-mode 的一個功能，就是當我按下 C-x vv 的時候，會自動幫我將
目前的 buffer 加入 commit, egg 同樣也提供這個功能，這邊關掉 egg
的確認系統，讓他根據狀況自動猜測下一步要做什麼。

#+begin_src emacs-lisp
  ;; make egg auto guess next action
  (setq egg-confirm-next-action nil)

  ;; remodify next-action priority
  (defsubst egg-guess-next-action (desc)
    (cond
     ((memq :file-has-merged-conflict desc) :merge-file)
     ((memq :file-is-modified desc)         :stage-file)
     ((memq :has-staged-changes desc)       :commit)
     ((memq :file-is-unmerged desc)         :stage-file)
     ((memq :wdir-has-merged-conflict desc) :status)
     ((memq :wdir-has-unmerged-files  desc) :stage-all)
     ((memq :wdir-is-modified desc)         :stage-all)
     ((memq :rebase-in-progress desc)       :rebase-continue)
     (t                                     :quit)))
#+end_src

** 當進入 egg-status 或是 egg-commit-log-edit 時，關掉其他 window。 :advice:

egg-status 和 egg-commit-log-edit 這兩個 buffer 都很酷，我覺得讓
他們啟動時成為一個全螢幕的視窗比較好，所以這邊增加 advice 來改變
預設的動作。

#+begin_src emacs-lisp
  (defadvice egg-status (around goto-egg-status-buffer activate)
    "Delete other windows after visiting egg-status."
    ad-do-it
    (delete-other-windows))

  (defadvice egg-commit-log-edit (around goto-egg-commit-buffer activate)
    "Delete other windows after visiting egg-commit-buffer."
    ad-do-it
    (delete-other-windows))
#+end_src

** 當使用 magit 時，不使用 emacs 原生的 vc 來處理和 git 相關的事情

emacs 本身具有一個 vc-mode 可以幫忙處理和版本管理相關的事情，但
是我覺的 magit 比較好用，所以當有載入 magit 時，就將 vc-mode 裏面
負責處理 git 的部份拿掉。

#+begin_src emacs-lisp
  (when (featurep 'magit)
    (setq vc-handled-backends (remq 'git vc-handled-backends)))
#+end_src

** 使用 C-g 離開 git 程式的視窗

我習慣在 emacs 使用 C-g 來跳離視窗，所以這邊也是這樣設定，用來
逃離 magit, git-emacs 的視窗。

#+begin_src emacs-lisp
  (define-key egg-status-buffer-mode-map (kbd "C-g") 'egg-quit-buffer)
  (define-key egg-log-msg-mode-map (kbd "C-g") 'egg-quit-buffer)
  (define-key magit-mode-map (kbd "C-g") 'magit-quit-window)
  (define-key git--branch-mode-map (kbd "C-g") 'git--quit-buffer)
#+end_src

** 全域性按鍵設定                                               :global@key:

| 按鍵    | 命令            | 用途                            |
|---------+-----------------+---------------------------------|
| C-x v l | magit-log       | 使用 magit 察看 log             |
| C-x v s | magit-status    | 使用 magit 查看目前的git status |
| C-x v v | egg-next-action | 讓 egg 自動猜測下一步要做什麼   |
| C-x v p | git-push        | push 到遠端 repo                |

#+begin_src emacs-lisp
  (vim:imap (kbd "C-x vl") 'magit-log)
  (vim:imap (kbd "C-x vs") 'magit-status)
  (vim:map (kbd "C-x vv") 'egg-next-action)
  (vim:map (kbd "C-x vp") 'git-push)
#+end_src

* Hooks                                                               :hook:
** find-file-hook
#+begin_src emacs-lisp
  ;; Auto add HEADER in new file
  (add-hook 'find-file-hook
            '(lambda ()
               (when (and (buffer-file-name)
                          (not (file-exists-p (buffer-file-name)))
                          (= (point-max) 1))
                 (let ((header-snippet "HEADER")
                       (yas/fallback-behavior 'return-nil))
                   (insert header-snippet)
                   ;; if can't expand snippet, clear whole buffer
                   (if (not (yas/expand))
                       (delete-region (point-min) (point-max)))))))
#+end_src

* 檔案備份

雖然現在大家都有在使用 git、svn 等檔案管理系統，但我們最好還是有其他的
備份，這裡設定的是 emacs 內建的備份方式。

*注意*:
　　由於內建的備份方式是採用明碼來備份，所以若是加密的檔案也會直接被
   備份。

** 設定備份檔案的資料夾

這個資料夾將存放所有的備份檔案

#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,emacs-backup-dir)))
#+end_src

** 如果備份檔案用的資料夾不存在，重新建立他

#+begin_src emacs-lisp
  (if (not (file-exists-p emacs-backup-dir))
      (make-directory emacs-backup-dir t))
#+end_src

** 每當敲擊按鍵 50 下時，進行備份

#+begin_src emacs-lisp
  (setq auto-save-interval 50)
#+end_src

** 每 60 秒進行自動儲存

#+begin_src emacs-lisp
  (setq auto-save-timeout 60)
#+end_src

** 真的刪除檔案，而不是放入垃圾桶

#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash nil)
#+end_src

** 當讀取檔案時，不自動進行檔案儲存

#+begin_src emacs-lisp
  (setq auto-save-visited-file-name nil)
#+end_src

** 當緩衝區儲存後，刪除掉自動儲存的檔案

#+begin_src emacs-lisp
  (setq delete-auto-save-files t)
#+end_src

** 讓備份檔案具有版本控管的功能

當備份檔案的時候，可以透過設定 kept-old-versions 以及 kept-new-versions 來決定
要保留多少備份。

#+begin_src emacs-lisp
  (setq version-control t)
#+end_src

** 保留舊有的 10 個備份

當新的備份建立起來後，保留舊有的 10 個備份

#+begin_src emacs-lisp
  (setq kept-old-versions 10)
#+end_src

** 建立新的 20 個備份

建立新的 20 個備份，當備份數量超過 20 以後，第一個備份會變成舊有的備份。

#+begin_src emacs-lisp
  (setq kept-new-versions 20)
#+end_src

** 刪除舊有的備份

刪除非以上所述的 30 個備份

#+begin_src emacs-lisp
  (setq delete-old-versions t)
#+end_src

** 使用複製的方式來產生備份檔案

#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

** TODO 位龜類
#+begin_src emacs-lisp
  (setq auto-save-default    t)           ; auto-save of every file-visiting buffer
  ;; change auto-save-list setting
  (setq auto-save-list-file-prefix (concat emacs-backup-dir "auto-saves-"))
  (setq auto-save-file-name-transforms `((".*"  ,emacs-backup-dir)))
#+end_src
* Session
** filecache

filecache 會根據使用者輸入的文件名，找到該文件的實際位置。
使用 C-x C-f 找尋文件時，在 minibuffer 上輸入該文件的名字，並使用 C-TAB 進行補全，
此時路徑會被 filecache 更改成欲找尋文件的路徑。
#+begin_src emacs-lisp
  (require 'filecache)
  ;; setup file-cache-filter-regexps
  (setq file-cache-filter-regexps
        '("~$" "\\.o$" "\\.exe$" "\\.a$" "\\.out$"  "\\.elc$" "\\.so$"
          "\\.output$" "\\.$" "#$" "\\.class$" "\\.pyc$"
          "\\.svn$" "\\.svn-base$" "\\.git$" "\\.hg$"
          ))

  (file-cache-add-directory-list '("~/.emacs.d/" "~/Workspace/"))
#+end_src

** savehist
#+begin_src emacs-lisp
  (require 'savehist)
  ;; keep minibuffer history between session
  (setq savehist-file (concat emacs-cache-dir "savehist.dat"))
  (savehist-mode 1)
#+end_src
** saveplace
#+begin_src emacs-lisp
  (require 'saveplace)
  (setq save-place-file (concat emacs-cache-dir "saveplace.dat"))
  (setq-default save-place t)
#+end_src
** recentf
#+begin_src emacs-lisp
  (require 'recentf)
  (require 'recentf-ext)
  ;; Setting cache file for recentf
  (setq recentf-save-file (concat emacs-cache-dir "recentf"))
  ;; Following file won;t contain in recentf
  (setq recentf-exclude '("\\.elc$" "\\.pyc$" "\\.recentd$" "^/tmp/"))
#+end_src
** desktop
#+begin_src emacs-lisp
  (require 'desktop)
  (setq desktop-path (list emacs-cache-dir))
  (setq desktop-dirname emacs-cache-dir)
  (setq desktop-base-file-name "desktop.dat")
  (setq desktop-missing-file-warning nil)

  ;; Enable desktop
  (desktop-save-mode t)

  (defadvice desktop-owner (after pry-from-cold-dead-hands activate)
    "Don't allow dead emacsen to own the desktop file."
    (when (not (emacs-process-p ad-return-value))
      (setq ad-return-value nil)))

  (defun desktop-in-use? ()
    (and (file-exists-p desktop-base-file-name) (file-exists-p desktop-base-lock-name)))

  (defun autosave-desktop ()
    (if (desktop-in-use?) (desktop-save-in-desktop-dir)))

  ;; auto save desktop
  (add-hook 'after-init-hook
            (lambda ()
              (setq *desktop-saver-timer*
                    (run-with-timer 5 300 'autosave-desktop))))

  ;; Following modes are ignore and won't save to desktop
  (setq desktop-buffers-not-to-save
        (concat "\\("
                "^\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
                "\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
                "\\)$"))

  (add-to-list 'desktop-modes-not-to-save 'fundamental-mode)
  (add-to-list 'desktop-modes-not-to-save 'dired-mode)
  (add-to-list 'desktop-modes-not-to-save 'Info-mode)
  (add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
  (add-to-list 'desktop-modes-not-to-save 'w3m-mode)
  (add-to-list 'desktop-modes-not-to-save 'view-mode)
#+end_src
* 全域性按鍵設置
** 關閉預設的按鍵設定

關閉部份按鍵設定，在後面重新設定他。
#+begin_src emacs-lisp
  (global-unset-key (kbd "C-r"))
  (global-unset-key (kbd "C-x e"))
  (global-unset-key (kbd "C-x d"))
#+end_src

** Function key prefix
Function key 設置常用的命令。

| Key | Command             |
|-----+---------------------|
| F1  | woman               |
| F2  | shell-pop           |
| F3  | call-last-kcd-macro |
| F4  | sr-speedbar-toggle  |

#+begin_src emacs-lisp
  (global-set-key (kbd "<f1>")     'woman)
  (global-set-key (kbd "<f2>")     'shell-pop)
  (global-set-key (kbd "<f3>")     'call-last-kbd-macro)
  (global-set-key (kbd "<f4>")     'sr-speedbar-toggle)
#+end_src
** 在目前行加上彩色條
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x l") 'hl-line-mode)
#+end_src
** 顯示行號
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x L") 'linum-mode)
#+end_src
** 專案相關的按鍵

| 按鍵    | 命令                        | 用途                     |
|---------+-----------------------------+--------------------------|
| C-x p f | coldnew/project-find-file   | 在目前的專案裏面找尋檔案 |
| C-x p b | coldnew/project-find-buffer | 找尋目前專案的緩衝區     |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x p f") 'coldnew/project-find-file)
  (global-set-key (kbd "C-x p b") 'coldnew/project-find-buffer)
#+end_src
** 分頁切換

| 按鍵        | 命令                     | 用途          |
|-------------+--------------------------+---------------|
| C-x t n     | elscreen-next            | 下一個分頁    |
| C-x t p     | elscreen-previous        | 前一個分頁    |
| C-x t r     | elscreen-screen-nickname | 更改分頁名稱  |
| C-x t <NUM> | elscreen-goto <NUM>      | 跳到 <NUM> 頁 |
| C-x t c     | elscreen-create          | 建立新的分頁  |
| C-x t k     | elscreen-kill            | 關閉當前分頁  |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x t n") 'elscreen-next)
  (global-set-key (kbd "C-x t p") 'elscreen-previous)
  (global-set-key (kbd "C-x t r") 'elscreen-screen-nickname)
  (global-set-key (kbd "C-x t c") 'elscreen-create)
  (global-set-key (kbd "C-x t k") 'elscreen-kill)
  (global-set-key (kbd "C-x t 0") '(lambda () (interactive) (elscreen-goto 0)))
  (global-set-key (kbd "C-x t 1") '(lambda () (interactive) (elscreen-goto 1)))
  (global-set-key (kbd "C-x t 2") '(lambda () (interactive) (elscreen-goto 2)))
  (global-set-key (kbd "C-x t 3") '(lambda () (interactive) (elscreen-goto 3)))
  (global-set-key (kbd "C-x t 4") '(lambda () (interactive) (elscreen-goto 4)))
  (global-set-key (kbd "C-x t 5") '(lambda () (interactive) (elscreen-goto 5)))
  (global-set-key (kbd "C-x t 6") '(lambda () (interactive) (elscreen-goto 6)))
  (global-set-key (kbd "C-x t 7") '(lambda () (interactive) (elscreen-goto 7)))
  (global-set-key (kbd "C-x t 8") '(lambda () (interactive) (elscreen-goto 8)))
  (global-set-key (kbd "C-x t 9") '(lambda () (interactive) (elscreen-goto 9)))
#+end_src
** 縮排整個緩衝區

| 按鍵    | 命令                | 用途           |
|---------+---------------------+----------------|
| C-x C-i | indent-whole-buffer | 縮排整個緩衝區 |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-i") 'indent-whole-buffer)
#+end_src

** Ctrl Prefix
*** Default Emacs keybinding
#+begin_src emacs-lisp
  (global-set-key (kbd "C-n") 'next-line)
  (global-set-key (kbd "C-p") 'previous-line)
  (global-set-key (kbd "C-b") 'backward-char)
  (global-set-key (kbd "C-f") 'forward-char)
  (global-set-key (kbd "C-e") 'move-end-of-line)
  (global-set-key (kbd "C-a") 'move-beginning-of-line)
#+end_src

*** 向右貪婪刪除
#+begin_src emacs-lisp
  (global-set-key (kbd "C-d") 'hungry-delete-forward)
#+end_src

*** 向左貪婪刪除
#+begin_src emacs-lisp
  (global-set-key (kbd "C-l") 'hungry-delete-backward)
#+end_src

*** Misc
#+begin_src emacs-lisp
  (global-set-key (kbd "C-v") 'coldnew/set-mark-command)
#+end_src

*** iedit
#+begin_src emacs-lisp
  (global-set-key (kbd "C-;") 'iedit-mode)
#+end_src

*** Undo
#+begin_src emacs-lisp
  (global-set-key (kbd "C-/") 'undo-tree-undo)
#+end_src

*** 放大字體
#+begin_src emacs-lisp
  (global-set-key (kbd "C-=") 'text-scale-increase)
#+end_src

*** 縮小字體
#+begin_src emacs-lisp
  (global-set-key (kbd "C--") 'text-scale-decrease)
#+end_src
** 語言翻譯

| 按鍵    | 命令                   | 用途           |
|---------+------------------------+----------------|
| C-x t e | google-translate-zh-en | 中文翻譯成英文 |
| C-x t z | google-translate-en-zh | 英文翻譯成中文 |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x t e") 'google-translate-zh-en)
  (global-set-key (kbd "C-x t z") 'google-translate-en-zh)
#+end_src

** Ctrl-x Prefix
*** Misc
| 按鍵    | 命令                | 用途                   |
|---------+---------------------+------------------------|
| C-x C-f | lusty-file-explorer | 查詢並打開檔案         |
| C-x C-y | yank-n-times        | 多次貼上               |
| C-x C-r | lusty-sudo-explorer | 使用 sudo 打開檔案     |
| C-x C-b | ibuffer             | 顯示 ibuffer           |
| C-x C-l | recenter            | 將游標至於 buffer 中間 |
|         |                     |                        |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-f")  'lusty-file-explorer)
  (global-set-key (kbd "C-x C-r")  'lusty-sudo-explorer)
  (global-set-key (kbd "C-x C-y")  'yank-n-times)
  (global-set-key (kbd "C-x C-l")  'recenter)
  (global-set-key (kbd "C-x C-b")  'ibuffer)
#+end_src

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-d")  'dired)
  (global-set-key (kbd "C-x M-x") 'helm-M-x)
  (global-set-key (kbd "C-x C-n") 'auto-complete)
  (global-set-key (kbd "C-x C-s") 'save-buffer-always)
  (global-set-key (kbd "C-x F") 'fullscreen-window)
  (global-set-key (kbd "C-x s") 'shell-command)
#+end_src

*** 轉換
| 按鍵    | 命令                     | 用途                             |
|---------+--------------------------+----------------------------------|
| C-x c c | capitalize-word-backward | 將前面的 word 第一個字母大寫     |
| C-x c l | downcase-word-backward   | 將前面的 word 變成小寫           |
| C-x c u | upcase-word-backward     | 將前面的 word 變成大寫           |
| C-x c x | dos2unix                 | 將目前的檔案轉換成 unix 檔案型式 |
| C-x c d | unix2dos                 | 將目前的檔案轉換成 dos 檔案型式  |
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x c c") 'capitalize-word-backward)
  (global-set-key (kbd "C-x c l") 'downcase-word-backward)
  (global-set-key (kbd "C-x c u") 'upcase-word-backward)
  (global-set-key (kbd "C-x c x") 'dos2unix)
  (global-set-key (kbd "C-x c d") 'unix2dos)
#+end_src

*** emms
| 按鍵        | 命令              | 用途       |
|-------------+-------------------+------------|
| C-x e s     | emms-start        | 啟動 emms  |
| C-x e n     | emms-next         | 下一首曲目 |
| C-x e p     | emms-previous     | 前一首曲目 |
| C-x e <SPC> | emms-pause        | 暫停曲目   |
| C-x e =     | emms-volume-raise | 放大音量   |
| C-x e -     | emms-volume-lower | 縮小音量   |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x e n") 'emms-next)
  (global-set-key (kbd "C-x e p") 'emms-previous)
  (global-set-key (kbd "C-x e <SPC>") 'emms-pause)
  (global-set-key (kbd "C-x e s") 'emms-start)
  ;;(require 'emms-volume)
  (global-set-key (kbd "C-x e =") 'emms-volume-raise)
  (global-set-key (kbd "C-x e -") 'emms-volume-lower)
#+end_src
** Ctrl-r 暫存器、書籤、快速跳轉、矩型處理
預設的 C-r 其實是 isearch-backward, 這裡將他改掉。

| 按鍵           | 命令                       | 用途                                     |
|----------------+----------------------------+------------------------------------------|
| C-r s <char>   | copy-to-register           | 將區域(選擇)存入暫存器                   |
| C-r r <char>   | copy-rectangle-to-register | 將矩型區域存入暫存器                     |
| C-r i <char>   | insert-register            | 將暫存器內的東西插入                     |
| C-r SPC <char> | point-to-register          | 將檔案或是緩衝區位置存入暫存器           |
| C-r j <char>   | jump-to-register           | 跳轉到暫存的檔案或是緩衝區位置           |
| C-r n          | cua-sequence-rectangel     | 對選取的矩型區域每行加入相對應的續列數字 |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-r j") 'jump-to-register)
  (global-set-key (kbd "C-r r") 'copy-rectangle-to-register)
  (global-set-key (kbd "C-r i") 'insert-register)
  (global-set-key (kbd "C-r <SPC>") 'point-to-register)
  (global-set-key (kbd "C-r j") 'jump-to-register)
  (global-set-key (kbd "C-r n") 'cua-sequence-rectangle)
#+end_src
** Ctrl-c prefix
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-h") 'coldnew/folding-toggle)
  (global-set-key (kbd "C-c C-e") 'eval-and-replace)
#+end_src

*** org-mode                                                          :org:
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c C-l") 'org-insert-link)
  (global-set-key (kbd "C-c o") 'org-iswitchb)
#+end_src

** Ctrl-w prefix
*** 窗口移動
| 按鍵  | 命令           | 用途             |
|-------+----------------+------------------|
| C-x n | windmove-down  | 移動到下面的窗口 |
| C-x p | windmove-up    | 移動到上面的窗口 |
| C-x b | windmove-left  | 移動到左邊的窗口 |
| C-x f | windmove-right | 移動到右邊的窗口 |

#+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x n") 'windmove-down)
;;  (global-set-key (kbd "C-x f") 'windmove-right)
;;  (global-set-key (kbd "C-x b") 'windmove-left)
;;  (global-set-key (kbd "C-x p") 'windmove-up)
  (global-set-key (kbd "s-n") 'windmove-down)
  (global-set-key (kbd "s-p") 'windmove-up)
  (global-set-key (kbd "s-b") 'windmove-left)
  (global-set-key (kbd "s-f") 'windmove-right)
#+end_src
*** TODO 刪除區域或是一行
#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'kill-region)
  (global-set-key (kbd "M-w") 'kill-ring-save)
#+end_src
** Ctrl-Meta Prefix
#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-,") 'beginning-of-buffer)
  (global-set-key (kbd "C-M-.") 'end-of-buffer)
  (global-set-key (kbd "C-M-n") 'scroll-other-window)
  (global-set-key (kbd "C-M-p") 'scroll-other-window-down)
#+end_src

** Meta Prefix
*** Default Emacs keybinding
#+begin_src emacs-lisp
(global-set-key (kbd "M-f") 'forward-word)
(global-set-key (kbd "M-b") 'backward-word)
(global-set-key (kbd "M-e") 'forward-sentence)
(global-set-key (kbd "M-a") 'backward-sentence)
#+end_src

#+begin_src emacs-lisp
(global-set-key (kbd "M-r") 'query-replace-regexp)
#+end_src

*** Misc
#+begin_src emacs-lisp
  (global-set-key (kbd "M-s") 'coldnew/helm-occur)
  (global-set-key (kbd "M-l") 'backward-delete-word)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "M-n") 'scroll-up)
  (global-set-key (kbd "M-p") 'scroll-down)
  (global-set-key (kbd "M-g") 'linum-ace-jump)
  (global-set-key (kbd "M-v") 'er/expand-region)
  (global-set-key (kbd "M-q") 'coldnew/switch-to-command-mode)
  (global-set-key (kbd "M-/") 'undo-tree-redo)
  (global-set-key (kbd "M-.") 'helm-etags+-select-one-key)
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+end_src

** Shift prefix
#+begin_src emacs-lisp
  (global-set-key[(shift return)] 'insert-empty-line)
#+end_src

** Super prefix
#+begin_src emacs-lisp
  (global-set-key (kbd "s-l") 'linum-mode)
  (global-set-key (kbd "s-s") 'shell-command)
#+end_src
** Other

#+begin_src emacs-lisp
  (global-set-key (kbd "<delete>") 'hungry-delete-forward)
  (global-set-key (kbd "C-.") 'repeat)
#+end_src

* Register                                                         :register:
** 放置快速跳轉的捷徑命令。
使用 Ctrl-x r j <char> 就可以進行快速跳轉至檔案，其中 <char> 為以下所設定。
#+begin_src emacs-lisp
  (dolist
      (r `(
           ;; emacs-config
           (?e (file . ,(expand-file-name emacs-config-file)))
           ;; TODO.org
           (?t (file . "~/Dropbox/Org/TODO.org"))
           (?w (file . "~/Dropbox/Org/Weintek.org"))
           (?b (file . "~/Workspace/Blog/src/blog.org"))
           ))
    (set-register (car r) (cadr r)))
#+end_src

* 部若格                                                      :blog:
** 使用 o-blog 作為 blogging 系統
*** 載入相關套件
#+begin_src emacs-lisp
(require 'o-blog)
#+end_src

*** 設定網頁連結名稱

#+begin_src emacs-lisp
  (defun coldnew/o-blog:sanitizer (s)
    "Sanitize string S"
    (if (not (equal (ob-sanitize-string s) "blog"))
        (md5 s)
      (ob-sanitize-string s)))
#+end_src
*** 設定 blog 檔案的位置
#+begin_src emacs-lisp
  (defvar coldnew-blog-org-file "~/Workspace/Blog/src/blog.org"
    "coldnew's blog file")
#+end_src
*** 更新 blog 的命令
#+begin_src emacs-lisp
  (defun coldnew/update-blog ()
    (interactive)
    (org-publish-blog coldnew-blog-org-file)
    (firefox-refresh))
#+end_src
* Local File Variable
# Local Variables:
# mode: org
# End:
