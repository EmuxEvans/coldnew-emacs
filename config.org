#+TITLE: coldnew 的 emacs 配置
#+AUTHOR: Yen-Chin, Lee <coldnew>
#+email: coldnew.tw at gmail.com
#+STARTUP: overview indent align
#+PROPERTY: noweb tangle
#+OPTIONS: ^:nil

* 筆記
** 書籤管理
*** 按鍵
| 按鍵    | 命令                | 用途                     |
|---------+---------------------+--------------------------|
| C-x r m | bookmark-set        | 設置書籤                 |
| C-x r b | bookmark-jump       | 跳轉到書籤               |
| C-x r l | bookmark-bmenu-list | 開啟一個 buffer 列出書籤 |
|         | bookmark-delete     | 刪除書籤                 |
|         | bookmark-load       | 讀取已儲存的書籤檔案     |
*** 配置
| 變數名稱              | 預設值               | 用途           |
|-----------------------+----------------------+----------------|
| bookmark-default-file | ~/.emacs.d/bookmarks | 預設的書籤檔案 |
| bookmark-save-flag    | t                    |                |
** 正規表達式
*** 使用 rx 來製作正規表達式
rx 為 emacs macro，可以幫助產生 emacs 的正規表達式
**** TODO 理解並翻譯回中文
rx is a Lisp macro in `rx.el'.

(rx &rest REGEXPS)

Translate regular expressions REGEXPS in sexp form to a regexp string.
REGEXPS is a non-empty sequence of forms of the sort listed below.

Note that `rx' is a Lisp macro; when used in a Lisp program being
compiled, the translation is performed by the compiler.
See `rx-to-string' for how to do such a translation at run-time.

The following are valid subforms of regular expressions in sexp
notation.

STRING
matches string STRING literally.

CHAR
matches character CHAR literally.

`not-newline', `nonl'
matches any character except a newline.

`anything'
matches any character

`(any SET ...)'
`(in SET ...)'
`(char SET ...)'
matches any character in SET ....  SET may be a character or string.
Ranges of characters can be specified as `A-Z' in strings.
Ranges may also be specified as conses like `(?A . ?Z)'.

SET may also be the name of a character class: `digit',
`control', `hex-digit', `blank', `graph', `print', `alnum',
`alpha', `ascii', `nonascii', `lower', `punct', `space', `upper',
`word', or one of their synonyms.

`(not (any SET ...))'
matches any character not in SET ...

`line-start', `bol'
matches the empty string, but only at the beginning of a line
in the text being matched

`line-end', `eol'
is similar to `line-start' but matches only at the end of a line

`string-start', `bos', `bot'
matches the empty string, but only at the beginning of the
string being matched against.

`string-end', `eos', `eot'
matches the empty string, but only at the end of the
string being matched against.

`buffer-start'
matches the empty string, but only at the beginning of the
buffer being matched against.  Actually equivalent to `string-start'.

`buffer-end'
matches the empty string, but only at the end of the
buffer being matched against.  Actually equivalent to `string-end'.

`point'
matches the empty string, but only at point.

`word-start', `bow'
matches the empty string, but only at the beginning of a word.

`word-end', `eow'
matches the empty string, but only at the end of a word.

`word-boundary'
matches the empty string, but only at the beginning or end of a
word.

`(not word-boundary)'
`not-word-boundary'
matches the empty string, but not at the beginning or end of a
word.

`symbol-start'
matches the empty string, but only at the beginning of a symbol.

`symbol-end'
matches the empty string, but only at the end of a symbol.

`digit', `numeric', `num'
matches 0 through 9.

`control', `cntrl'
matches ASCII control characters.

`hex-digit', `hex', `xdigit'
matches 0 through 9, a through f and A through F.

`blank'
matches space and tab only.

`graphic', `graph'
matches graphic characters--everything except ASCII control chars,
space, and DEL.

`printing', `print'
matches printing characters--everything except ASCII control chars
and DEL.

`alphanumeric', `alnum'
matches letters and digits.  (But at present, for multibyte characters,
it matches anything that has word syntax.)

`letter', `alphabetic', `alpha'
matches letters.  (But at present, for multibyte characters,
it matches anything that has word syntax.)

`ascii'
matches ASCII (unibyte) characters.

`nonascii'
matches non-ASCII (multibyte) characters.

`lower', `lower-case'
matches anything lower-case.

`upper', `upper-case'
matches anything upper-case.

`punctuation', `punct'
matches punctuation.  (But at present, for multibyte characters,
it matches anything that has non-word syntax.)

`space', `whitespace', `white'
matches anything that has whitespace syntax.

`word', `wordchar'
matches anything that has word syntax.

`not-wordchar'
matches anything that has non-word syntax.

`(syntax SYNTAX)'
matches a character with syntax SYNTAX.  SYNTAX must be one
of the following symbols, or a symbol corresponding to the syntax
character, e.g. `\.' for `\s.'.

`whitespace'            (\s- in string notation)
`punctuation'           (\s.)
`word'                  (\sw)
`symbol'                        (\s_)
`open-parenthesis'              (\s()
`close-parenthesis'     (\s))
`expression-prefix'     (\s')
`string-quote'          (\s")
`paired-delimiter'              (\s$)
`escape'                        (\s\)
`character-quote'               (\s/)
`comment-start'         (\s<)
`comment-end'           (\s>)
`string-delimiter'              (\s|)
`comment-delimiter'     (\s!)

`(not (syntax SYNTAX))'
matches a character that doesn't have syntax SYNTAX.

`(category CATEGORY)'
matches a character with category CATEGORY.  CATEGORY must be
either a character to use for C, or one of the following symbols.

| consonant                        | (\c0 in string notation) |
| base-vowel                       | (\c1)                    |
| upper-diacritical-mark           | (\c2)                    |
| lower-diacritical-mark           | (\c3)                    |
| tone-mark                        | (\c4)                    |
| symbol                           | (\c5)                    |
| digit                            | (\c6)                    |
| vowel-modifying-diacritical-mark | (\c7)                    |
| vowel-sign                       | (\c8)                    |
| semivowel-lower                  | (\c9)                    |
| not-at-end-of-line               | (\c<)                    |
| not-at-beginning-of-line         | (\c>)                    |
| alpha-numeric-two-byte           | (\cA)                    |
| chinse-two-byte                  | (\cC)                    |
| greek-two-byte                   | (\cG)                    |
| japanese-hiragana-two-byte       | (\cH)                    |
| indian-tow-byte                  | (\cI)                    |
| japanese-katakana-two-byte       | (\cK)                    |
| korean-hangul-two-byte           | (\cN)                    |
| cyrillic-two-byte                | (\cY)                    |
| combining-diacritic              | (\c^)                    |
| ascii                            | (\ca)                    |
| arabic                           | (\cb)                    |
| chinese                          | (\cc)                    |
| ethiopic                         | (\ce)                    |
| greek                            | (\cg)                    |
| korean                           | (\ch)                    |
| indian                           | (\ci)                    |
| japanese                         | (\cj)                    |
| japanese-katakana                | (\ck)                    |
| latin                            | (\cl)                    |
| lao                              | (\co)                    |
| tibetan                          | (\cq)                    |
| japanese-roman                   | (\cr)                    |
| thai                             | (\ct)                    |
| vietnamese                       | (\cv)                    |
| hebrew                           | (\cw)                    |
| cyrillic                         | (\cy)                    |

| `can-break' | (\c | ) | ) |

`(not (category CATEGORY))'
matches a character that doesn't have categor CATEGORY.

`(and SEXP1 SEXP2 ...)'
`(: SEXP1 SEXP2 ...)'
`(seq SEXP1 SEXP2 ...)'
`(sequence SEXP1 SEXP2 ...)'
matches what SEXP1 matches, followed by what EXP2 matches, etc.

`(submatch SEXP1 SEXP2 ...)'
`(group SEXP1 SEXP2 ...)'
like `and', but makes the match accessible with `match-end',
`match-beginning', and `match-string'.

`(submatch-n N SEXP1 SEXP2 ...)'
`(group-n N SEXP1 SEXP2 ...)'
like `group', but make it an explicitly-numbered group with
group number N.

`(or SEXP1 SEXP2 ...)'
`(| SEXP1 SEXP2 ...)'
matches anything that matches SEXP1 or SEXP2, etc.  If all
args are strings, use `regexp-opt' to optimize the resulting
regular expression.

`(minimal-match SEXP)'
produce a non-greedy regexp for SEXP.  Normally, regexps matching
zero or more occurrences of something are "greedy" in that they
match as much as they can, as long as the overall regexp can
still match.  A non-greedy regexp matches as little as possible.

`(maximal-match SEXP)'
produce a greedy regexp for SEXP.  This is the default.

Below, `SEXP ...' represents a sequence of regexp forms, treated as if
enclosed in `(and ...)'.

`(zero-or-more SEXP ...)'
`(0+ SEXP ...)'
matches zero or more occurrences of what SEXP ... matches.

`(* SEXP ...)'
like `zero-or-more', but always produces a greedy regexp, independent
of `rx-greedy-flag'.

`(*? SEXP ...)'
like `zero-or-more', but always produces a non-greedy regexp,
independent of `rx-greedy-flag'.

`(one-or-more SEXP ...)'
`(1+ SEXP ...)'
matches one or more occurrences of SEXP ...

`(+ SEXP ...)'
like `one-or-more', but always produces a greedy regexp.

`(+? SEXP ...)'
like `one-or-more', but always produces a non-greedy regexp.

`(zero-or-one SEXP ...)'
`(optional SEXP ...)'
`(opt SEXP ...)'
matches zero or one occurrences of A.

`(? SEXP ...)'
like `zero-or-one', but always produces a greedy regexp.

`(?? SEXP ...)'
like `zero-or-one', but always produces a non-greedy regexp.

`(repeat N SEXP)'
`(= N SEXP ...)'
matches N occurrences.

`(>= N SEXP ...)'
matches N or more occurrences.

`(repeat N M SEXP)'
`(** N M SEXP ...)'
matches N to M occurrences.

`(backref N)'
matches what was matched previously by submatch N.

`(eval FORM)'
evaluate FORM and insert result.  If result is a string,
`regexp-quote' it.

`(regexp REGEXP)'
include REGEXP in string notation in the result.

** TODO 未歸類的 emacs 筆記。
*** C-x r N 添加數字序號
(rectangle-number-lines START END START-AT &optional FORMAT)
*** C-M-W append-next-kill
Quite useful, actually.  Normally, if you kill a couple of lines,
move the cursor, and then kills some more lines, only the second
batch of lines will be yanked with C-y.
However, if you use append-next-kill before the second batch of
kills, they will be appended to the first batch.﻿

*** ede
http://epsilonvectorplusplus.wordpress.com/2012/04/27/a-functional-introduction-to-cedet-ede/

*** 矩型操作
emacs 以 C-x r 開頭的命令來進行矩形操作。先用 C-space 或者 C-@設一個 mark，移動光標到另一點，用以下命令進行列操作：

C-x r k 剪切一個矩形塊
C-x r y 粘貼一個矩形塊
C-x r o 插入一個矩形塊
C-x r c 清除一個矩形塊(使其變成空白)
C-x r t 在選定區域的所有列前插入樣的字符
*** cua
cua-mode 下可以用以下命令進行列操作：

直接輸入字符: 在每行前(或後)都插入這個字符
[M-a]: 將 rect 中的文字左對齊
[M-b]: 用空格(tabs 或者 spaces)替換所有 rect 中的字符
[M-c]: 去掉所有行左側的空格
[M-f]: 用單個字符替換所有 rect 中的字符(提示輸入一個字符)
[M-i]: 對每行中第一個找到的數字進行加 1 操作(自動把 0x 開頭的當作十六進制數字)
[M-k]: 剪切 rect
[M-l]: 把 rect 中的內容全部轉換為小寫
[M-m]: 拷貝 rect
[M-n]: 用一串自增的數字替換 rect 中的每一行(這個功能可以用來給每行編號)
[M-o]: rect 的內容右移，選中的 rect 用空格填充
[M-r]: 用字符串替換符滿足正則表達式的字符串
[M-R]: 上下反轉
[M-s]: 把 rect 中的每一行替換為一個字符串(提示輸入)
[M-t]: 把 rect 整個替換為一個字符串(提示輸入)
[M-u]: 把 rect 中的內容全部轉換為大寫
[M-|]: 對 rect 執行一個 shell 命令
*** 看 package 的註解
M-x finder-commentary
*** Search
**** 基本按鍵
| 按鍵   | 命令             | 用途     |
|--------+------------------+----------|
| Ctrl-s | isearch-forward  | 向前查找 |
| Ctrl-r | isearch-backward | 向後查找 |

*** id-manager
負責管理密碼的plugin
* 基礎設置                                                             :base:
這邊放置的是 *初始化* 的設定，為了避免設定衝突，部份 Macro 和 Function 會放置於此。
** 預先載入 cl 套件。
#+begin_src emacs-lisp
  (eval-when-compile (require 'cl))
#+end_src

#+RESULTS:
: cl

** 使用者介面設定
關閉一些 emacs 預設的 UI 設定。
*** 不啟用 startup message
啟動 emacs 時會出現的 GNU/Emacs 畫面，這裡將他關閉
#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

#+RESULTS:
: t

*** 清空 **scratch** buffer 的文字。
預設 **scratch** 裡面會有幾行文字，直接將他清空。
#+begin_src emacs-lisp
  (setq initial-scratch-message "")
#+end_src

#+RESULTS:

*** 關閉蜂鳴器
使用 visible bell 代替電腦的蜂鳴器叫聲。
#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

#+RESULTS:
: t

*** 關閉工具列
#+begin_src emacs-lisp
  (if (featurep 'tool-bar) (tool-bar-mode -1))
#+end_src

#+RESULTS:

*** 關閉滾動條
關閉左側或右側的滾動條 (scrool-bar)
#+begin_src emacs-lisp
  (if (featurep 'scroll-bar) (scroll-bar-mode -1))
#+end_src

#+RESULTS:

*** 關閉游標閃爍
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

#+RESULTS:

*** 關閉選單列
#+begin_src emacs-lisp
  (if (featurep 'menu-bar) (menu-bar-mode -1))
#+end_src

#+RESULTS:

*** Time Stamp
#+begin_src emacs-lisp
  (setq time-stamp-active      t ) ; do enable time-stamps
  (setq time-stamp-line-limit 10 ) ; check first 10 buffer lines for Time-stamp:
  (setq time-stamp-format "%04y-%02m-%02d %02H:%02M:%02S (%u)") ; date format
#+end_src

#+RESULTS:
: %04y-%02m-%02d %02H:%02M:%02S (%u)

*** 回答問題時，使用 *y* 和 *n* 代替 *yes/no* 。
預設要使用 *yse* 或是 *no* 來回答問題，這裡將他改成用 *y* 或 *n* 。
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

#+RESULTS:
: y-or-n-p

*** TODO Misc

#+begin_src emacs-lisp
  ;; TODO: add comment
  (setq stack-trace-on-error t)
  (setq imenu-auto-scan t)
  ;;(setq redisplay-dont-pause t)

  ;; xrelated srtting
  (setq x-select-enable-clipboard t)
  (setq select-active-regions t)
  (setq x-gtk-use-system-tooltips nil)    ; disable gtk-tooltip

  (setq max-lisp-eval-depth '40000)
  (setq max-specpdl-size 1000)  ; default is 1000, reduce the backtrace level
  (setq debug-on-error t)    ; now you should get a backtrace
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp
  ;; nice scrolling
  (setq scroll-margin                   0 )
  (setq scroll-conservatively      100000 )
  (setq scroll-preserve-screen-position 1 )
  (setq scroll-up-aggressively       0.01 )
  (setq scroll-down-aggressively     0.01 )
#+end_src

#+RESULTS:
: 0.01

** 變數設定                                                        :variable:
這邊加入了我自定義的變數以及其初始值。
*** 資料夾相關設定
這邊設定了各種類型資料夾的路徑。
**** emacs-dir
emacs 設定檔預設所在的資料夾
#+begin_src emacs-lisp
  (defconst emacs-dir "~/.emacs.d/"
    "The top-level emacs-configure directory.")
#+end_src

#+RESULTS:
: emacs-dir

**** emacs-themes-dir
佈景主題的資料夾設定。
#+begin_src emacs-lisp
  (defconst emacs-themes-dir (concat emacs-dir "themes/")
    "directory to place emacs theme.")
#+end_src

#+RESULTS:
: emacs-themes-dir

**** emacs-lisp-dir
el-get 安裝套件的路徑。
#+begin_src emacs-lisp
  (defconst emacs-lisp-dir   (concat emacs-dir "lisp/")
    "directory to place lisp packages from internet.")
#+end_src

#+RESULTS:
: emacs-lisp-dir

**** emacs-recipes-dir
el-get 的 recipes 路徑。
#+begin_src emacs-lisp
  (defconst emacs-recipes-dir (concat emacs-dir "recipes/")
    "directory to place local el-get recepies.")
#+end_src

#+RESULTS:
: emacs-recipes-dir

**** emacs-elpa-dir
elpa 安裝套件的路徑。
#+begin_src emacs-lisp
  (defconst emacs-elpa-dir   (concat emacs-lisp-dir "elpa/")
    "directory to place ELPA lisp packages from internet.")
#+end_src

#+RESULTS:
: emacs-elpa-dir

**** emacs-snippets-dir
yasnippet 使用的 snippet路徑
#+begin_src emacs-lisp
  (defconst emacs-snippets-dir (concat emacs-dir "snippets/")
    "directory to place yasnippet files.")
#+end_src

#+RESULTS:
: emacs-snippets-dir

**** emacs-bin-dir
放置 binary 檔案的資料夾。
#+begin_src emacs-lisp
  (defconst emacs-bin-dir    (concat emacs-dir "bin/")
    "directory to place binary staff.")
#+end_src

#+RESULTS:
: emacs-bin-dir

**** emacs-cache-dir
放置 cache 等暫存檔案的資料夾。
#+begin_src emacs-lisp
  (defconst emacs-cache-dir  (concat emacs-dir "cache/")
    "cache file directory.")
#+end_src

#+RESULTS:
: emacs-cache-dir

**** emacs-backup-dir
備份文件的資料夾。
#+begin_src emacs-lisp
  (defconst emacs-backup-dir (concat emacs-dir "backup/")
    "directory to backup files.")
#+end_src

#+RESULTS:
: emacs-backup-dir

**** emacs-log-dir
放置紀錄的資料夾。
#+begin_src emacs-lisp
  (defconst emacs-log-dir (concat emacs-dir "log/")
    "log file directory.")
#+end_src

#+RESULTS:
: emacs-log-dir

*** 檔案相關設定
這邊設定了各種檔案的路徑。
**** emacs-config-file
emacs 個人配置的檔案，也就是這個檔案。
#+begin_src emacs-lisp
  (defconst emacs-config-file (concat emacs-dir "config.org")
    "File to place emacs configs.")
#+end_src

#+RESULTS:
: emacs-config-file

**** emacs-custom-file
#+begin_src emacs-lisp
  (defconst emacs-custom-file (concat emacs-dir "custom.el")
    "store customize UI config.")
#+end_src

#+RESULTS:
: emacs-custom-file

**** emacs-authinfo-file
#+begin_src emacs-lisp
  (defconst emacs-authinfo-file (concat emacs-dir ".authinfo.gpg")
    "file that save secret")
#+end_src

#+RESULTS:
: emacs-authinfo-file

**** emacs-bookmark-file
#+begin_src emacs-lisp
  (defconst emacs-bookmark-file (concat emacs-cache-dir "bookmarks")
    "File to save bookmarks")
#+end_src

#+RESULTS:
: emacs-bookmark-file

*** 作業系統測試
放置用於測試目前 emacs 執行在何種作業系統上的變數。
**** MacOsx
#+begin_src emacs-lisp
  (defvar mac-p     (eq system-type 'darwin)
    "Return nil if OS is not Mac.")
#+end_src

#+RESULTS:
: mac-p

**** Linux
***** all
#+begin_src emacs-lisp
  (defvar linux-p   (and (eq system-type 'gnu/linux) (not (eq system-type 'drawin)))
    "Return nil if OS is not Linux.")
#+end_src

#+RESULTS:
: linux-p

***** 32-bit
#+begin_src emacs-lisp
  (defvar linux-32bit-p (and (string-match (rx bos "x86-") system-configuration) linux-p)
  "Return nil if OS is not 32-bit linux.")
#+end_src

#+RESULTS:
: linux-32bit-p

***** 64-bit
#+begin_src emacs-lisp
  (defvar linux-64bit-p (and (string-match (rx bos "x86_64") system-configuration) linux-p)
    "Return nil if OS is not 64-bit linux.")
#+end_src

#+RESULTS:
: linux-64bit-p

**** Cygwin
#+begin_src emacs-lisp
  (defvar cygwin-p  (eq system-type 'cygwin)
    "Return nil if OS is not CygWin.")
#+end_src

#+RESULTS:
: cygwin-p

**** Window$
#+begin_src emacs-lisp
  (defvar windows-p (eq system-type 'windows-nt)
    "Return nil if OS is not Windows.")
#+end_src

#+RESULTS:
: windows-p

*** 螢幕解析度測試                                               :resolution:
放置測試螢幕解析度用的變數
**** 1280x800
#+begin_src emacs-lisp
  (defvar display-1280x800-p   (and (= (display-pixel-width) 1280)
                                    (= (display-pixel-height) 800))
    "Return nil if current display's resolution is not 1280x800")
#+end_src

#+RESULTS:
: display-1280x800-p

**** 1280x1024
#+begin_src emacs-lisp
  (defvar display-1280x1024-p  (and (= (display-pixel-width) 1280)
                                    (= (display-pixel-height) 1024))
    "Return nil if current display's resolution is not 1280x1024")
#+end_src

#+RESULTS:
: display-1280x1024-p

**** 1920x1080
#+begin_src emacs-lisp
  (defvar display-1920x1080-p  (and (= (display-pixel-width) 1920)
                                    (= (display-pixel-height) 1080))
    "Return nil if current display's resolution is not 1920x1080")
#+end_src

#+RESULTS:
: display-1920x1080-p

*** TODO Shell
#+begin_src emacs-lisp
  (defvar emacs-default-shell "/bin/bash"
    "Default shell for cemacs.")
  (defvar emacs-popup-shell-window-height 30
    "Window hight of popup shell.")
  (defvar emacs-popup-shell-window-position "bottom"
    "Make popup shell window at buttom by default.")
#+end_src

#+RESULTS:
: emacs-popup-shell-window-position

*** TODO Path
#+begin_src emacs-lisp
  ;; TODO: make it work on every platform, now only has Linux support
  (setenv "PATH"
          (concat
           emacs-bin-dir ":"
           "~/.lein/bin" ":"
           (getenv "PATH")
           ))

  (setq exec-path (cons emacs-bin-dir exec-path))
#+end_src

#+RESULTS:
| ~/.emacs.d/bin/ | ~/.emacs.d/bin/ | ~/.emacs.d/bin | /opt/android-sdk-update-manager/tools/ | /usr/lib/colorgcc/bin | ~/bin | ~/bin/shell_scripts | /usr/local/bin | /usr/bin | /bin | /opt/bin | /usr/x86_64-pc-linux-gnu/arm-none-linux-gnueabi/gcc-bin/4.4.5 | /usr/x86_64-pc-linux-gnu/arm-unknown-linux-gnueabi/gcc-bin/4.6.2 | /usr/armv7a-hardfloat-linux-gnueabi/gcc-bin/4.6.2 | /usr/x86_64-pc-linux-gnu/gcc-bin/4.6.2 | /opt/android-ndk | /opt/android-ndk/toolchains/arm-eabi-4.4.0/prebuilt/linux-x86/bin/ | /opt/android-ndk/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/ | /opt/android-sdk-update-manager/tools | /opt/android-sdk-update-manager/platform-tools | /usr/games/bin | /opt/cuda/bin | /opt/cuda/libnvvp | /opt/altera/11.0/quartus/bin/ | /opt/vmware/bin/ | /opt/matlab/bin/ | /opt/hitech/picc/9.82/bin | /opt/hitech/picc-18/pro/9.66/bin | /opt/microchip/mplabx/mplab_ide/bin/ | /usr/libexec/emacs/24.2/x86_64-pc-linux-gnu |

*** TODO Remember to remove
#+begin_src emacs-lisp
  (defun change-mouse-to-left ()
    (interactive)
    (shell-command "xmodmap -e \"pointer = 3 2 1\""))

  (defun change-mouse-to-right ()
    (interactive)
    (shell-command "xmodmap -e \"pointer = 1 2 3\""))

  (defun swap-ctrl-caps ()
    "swap control and capslock"
    (shell-command "setxkbmap -option ctrl:swapcaps"))

  (defun make-caps-as-ctrl ()
    "make capslock as control-key"
    (shell-command "setxkbmap -option ctrl:nocaps"))

  ;; only disable capslock and make it as control
  (cond ((eq window-system 'x)
         ;; make caps lock a control key
         (make-caps-as-ctrl)
         (change-mouse-to-left)))
#+end_src

*** TODO User Testing
#+begin_src emacs-lisp
(defvar root-p (zerop (user-real-uid))
  "Return nil if user is not root user.")
#+end_src
*** TODO Face
#+begin_src emacs-lisp
  (defface mode-line-read-only-face
    '((t (:foreground "#C82829" :bold t)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface mode-line-modified-face
    '((t (:inherit 'font-lock-function-name-face :bolt t)))
    "face for mode-name-string in modeline."
    :group'mode-line)

  (defface mode-line-mode-name-face
    '((t (:inherit font-lock-keyword-face)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface mode-line-normal-state-face
    '((t (:inherit font-lock-function-name-face)))
    "face for emacs normal state"
    :group 'mode-line)

  (defface font-lock-escape-char-face
    '((((class color)) (:foreground "seagreen2")))
    "highlight c escapes char like vim"
    :group 'font-lock-faces)

  (defface mode-line-evil-state-string-N
    '((t (:inherit font-lock-function-name-face)))
    "face for vim-string in normal-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-I
    '((t (:inherit font-lock-constant-face)))
    "face for vim-string in insert-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-V
    '((t (:inherit font-lock-variable-name-face)))
    "face for vim-string in visual-map on mode-line."
    :group 'mode-line)

  (defface mode-line-evil-state-string-E
    '((t (:inherit font-lock-string-face)))
    "face for vim-string in emacs-map on mode-line."
    :group 'mode-line)
#+end_src

** Macros                                                            :macro:
*** reauire*
這個巨集用途和 require 類似，但是會忽略掉所有的錯誤。此外，如果 emacs 並沒有讀入這個 package
則會呼叫 el-get 來安裝這個 package。
**** TODO add require-result buffer
**** TODO add function to handle if el-get return error
#+begin_src emacs-lisp
  (defmacro require* (feature &optional file)
      "Try to require FEATURE, but don't signal an error if `reauire' fails.
    If this package does not exist, use el-get reinstall it."
      `(let* ((require-result (require ,feature ,file 'noerror)))
         ;; if package does not exist, reinstall it
         (if-not require-result (el-get-reinstall ,feature)
                 ;; TODO: add require-result buffer
                 )))
#+end_src
** Font-lock
這邊的 font-lock 設定主要是為了讓自己設定的 macro（require*) 具有和 require
一樣的顏色，僅添加於 emacs-lisp-mode 和 lisp-interaction-mode
#+begin_src emacs-lisp
  (font-lock-add-keywords 'emacs-lisp-mode
                          '(("(\\(require\*\\*\\)[ \t']*\\(\\sw+\\)?"
                             (1 font-lock-keyword-face)
                             (2 font-lock-constant-face nil t))))
  
  (font-lock-add-keywords 'lisp-interaction-mode
                          '(("(\\(require\*\\*\\)[ \t']*\\(\\sw+\\)?"
                             (1 font-lock-keyword-face)
                             (2 font-lock-constant-face nil t))))
#+end_src
** 設定 custom-file 到其他檔案
避免使用 *customize-UI* 時，會將設定寫入我的 init.el
#+begin_src emacs-lisp
  (setq custom-file emacs-custom-file)
#+end_src
** Daemon
當啟用 emacs 時，啟動 emacs-server，如果使用者是 root 或已啟用 server，則忽略。
#+begin_src emacs-lisp
  ;; Only start server mode if I'm not root
  (unless (string-equal "root" (getenv "USER"))
    (require 'server)
    (unless (server-running-p) (server-start)))
#+end_src
** 根據目前螢幕的解析度調整 emacs 視窗的大小。                  :resolution:
整個設定是使用 cond 來進行條件式的判斷，因此加入了 *設定起始位置* 和 *設定終止位置*
作為保護。
*** 設定起始位置
#+begin_src emacs-lisp
  (cond
#+end_src
*** 1920x1080
#+begin_src emacs-lisp
  (display-1920x1080-p
   (setq default-frame-alist
         (append (list
                  '(width  . 134)
                  '(height . 45)
                  '(top    . 90)
                  '(left   . 500))
                 default-frame-alist)))
#+end_src
*** 1280x1024
#+begin_src emacs-lisp
  (display-1280x1024-p
   (setq default-frame-alist
         (append (list
                  '(width  . 114)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 300))
                 default-frame-alist)))
#+end_src
*** 1280x800
#+begin_src emacs-lisp
  (display-1280x800-p
   (setq default-frame-alist
         (append (list
                  '(width  . 114)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 300))
                 default-frame-alist)))
#+end_src
*** 預設情況
#+begin_src emacs-lisp
  (t
   (setq default-frame-alist
         (append (list
                  '(width  . 100)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 100))
                 default-frame-alist)))
#+end_src
*** 設定終止位置
#+begin_src emacs-lisp
  )
#+end_src
* 語言與編碼                                                         :locale:
emacs 編碼設定，大部份都設定成 utf-8。
** 系統編碼。
#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8 )
#+end_src
** 語言環境。
#+begin_src emacs-lisp
  (set-language-environment 'utf-8 )
#+end_src
** 文件保存時的編碼設置
#+begin_src emacs-lisp
  (set-buffer-file-coding-system 'utf-8 )
#+end_src
** 鍵盤編碼設定
#+begin_src emacs-lisp
  (set-keyboard-coding-system    'utf-8 )
#+end_src
** 設定終端機的編碼
#+begin_src emacs-lisp
  (set-terminal-coding-system    'utf-8 )
#+end_src
** 選擇區域內編碼
#+begin_src emacs-lisp
  (set-selection-coding-system   'utf-8 )
#+end_src
** 剪貼簿編碼設定
#+begin_src emacs-lisp
  (set-clipboard-coding-system   'utf-8 )
#+end_src
** 使用 utf-8 編碼顯示文件名
#+begin_src emacs-lisp
  (set-file-name-coding-system   'utf-8 )
#+end_src
** 設定時間顯示使用英文
#+begin_src emacs-lisp
  (setq system-time-locale "en_US" )
#+end_src
* 套件管理                                                          :package:
emacs 套件管理的設定。
** el-get
*** 設定 el-get-dir
我不喜歡 el-get 預設使用 el-get 目錄，這裡根據我的 emacs-lisp-dir 重新設定。
#+begin_src emacs-lisp
  (setq-default el-get-dir emacs-lisp-dir)
#+end_src
*** 如果 el-get 不存在的話，重新安裝 el-get
#+begin_src emacs-lisp
    (unless (require 'el-get nil t)
      (setq el-get-install-branch "master")
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
        (end-of-buffer)
        (eval-print-last-sexp)))
  
;;  (el-get 'sync)
#+end_src
*** 如果 elpa 的 recepies 不存在的話，自動建立他。
#+begin_src emacs-lisp
  (unless (file-exists-p el-get-recipe-path-elpa)
    (el-get-elpa-build-local-recipes))
#+end_src
*** 將我的 recipes 加入 el-get-recipe-path
#+begin_src emacs-lisp
  (add-to-list 'el-get-recipe-path emacs-recipes-dir)
#+end_src
*** Auto Mode Alist
\\.rcp$ 為 el-get 的 recipes 副檔名。
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rcp$" . emacs-lisp-mode))
#+end_src
*** TODO Recipes 轉移所有的 recipe 至此
***** Header
#+begin_src emacs-lisp
  (setq el-get-sources '(
#+end_src
***** TODO powerline remember to remove
#+begin_src emacs-lisp
  (:name powerline
         :type github
         :pkgname "jonathanchu/emacs-powerline")
#+end_src
***** lusty-emacs
使用最新版本的 lusty-explorer
#+begin_src emacs-lisp
  (:name lusty-explorer
         :type github
         :pkgname sjbach/lusty-emacs
         :description "LustyExplorer is a fast and responsive way to manage files and buffers")
#+end_src
***** mixen
#+begin_src emacs-lisp
  (:name mixen
          :type github
          :pkgname coldnew/mixen
          :features mixen)
#+end_src
***** End of config
#+begin_src emacs-lisp
  ))
#+end_src
** ELPA                                                               :elpa:
*** 設定 elpa 安裝目錄到 emacs-elpa-dir
#+begin_src emacs-lisp
  (setq-default package-user-dir emacs-elpa-dir)
#+end_src
*** Depends
#+begin_src emacs-lisp
  (require 'package)
#+end_src
*** 設定 elpa 所使用的套件庫
#+begin_src emacs-lisp
  (setq package-archives
        '(("ELPA" . "http://tromey.com/elpa/")
          ("gnu" . "http://elpa.gnu.org/packages/")
          ("marmalade" . "http://marmalade-repo.org/packages/")
          ("melpa" . "http://melpa.milkbox.net/packages/")))
#+end_src
** 套件檢查
為了避免有套件因為 *意外* 而不見，對套件進行檢查，若不存在則進行重新安裝的動作。
*注意* ：進行套件檢查時，必須確認 el-get 已經安裝至 emacs 裡面，否則會產生錯誤。
*** 存放套件資訊的變數
此變數用於存放系統裏面必須安裝的 emacs 套件。
#+begin_src emacs-lisp
   (defvar emacs-packages-list nil
     "A list of packages to ensure are installed at launch.")
#+end_src
*** 存放套件資訊的檔案
此檔案用於將 emacs-packags-list 暫存。
#+begin_src emacs-lisp
  (defvar emacs-packages-file
    (concat emacs-dir ".packages.el")
    "Define where to store and read the installed packages list.")
#+end_src
*** 將套件資訊寫入到檔案
#+begin_src emacs-lisp
  (defun emacs-packages-write-to-file ()
    "Write emasc-packages-list to files."
    (with-temp-file emacs-packages-file
      (insert (el-get-print-to-string emacs-packages-list 'pretty))))
#+end_src
*** 設定自動更新安裝套件資訊的時間
**** 當安裝新的套件時，更新套件資訊
#+begin_src emacs-lisp
  (defun emacs-packages-install (pkg)
    (unless (stringp pkg)
      (setq pkg (symbol-name pkg)))
    (add-to-list 'emacs-packages-list pkg)
    (emacs-packages-write-to-file))
  
  ;; add to hooks
  (add-hook 'el-get-post-install-hooks 'emacs-packages-install)
#+end_src
**** 當移除套件時，更新套件資訊
***** TODO el-get-post-remove-hooks 不知道為什麼不能用，所以只好先 advice el-get-remove
#+begin_src emacs-lisp
  (defun emacs-packages-remove (pkg)
    (setq emacs-packages-list (remove pkg emacs-packages-list))
    (emacs-packages-write-to-file))
  
  ;; add to hooks
  ;;(add-hook 'el-get-post-remove-hooks 'emacs-packages-remove)
  
  (defadvice el-get-remove (after remove-package activate)
    (emacs-packages-remove package))
#+end_src
*** 從硬碟中讀取檔案
#+begin_src emacs-lisp
  (defun emacs-packages-read-from-file ()
    "Read from emacs-packages-file and set the contents to emacs-packages-list."
    (when (file-exists-p emacs-packages-file)
      (setq emacs-packages-list
            (car
             (with-temp-buffer emacs-packages-file
                               (insert-file-contents-literally emacs-packages-file)
                               ;; if emacs-packages-file is an empty file
                               ;; return nil, else return buffer-string
                               (if (= 0 (buffer-size (current-buffer)))
                                   nil
                                 (read-from-string (buffer-string))
                                 ))))))
  
  ;; read installed packages info from file
  (emacs-packages-read-from-file)
#+end_src
*** 檢查套件是否有在 emacs-packages-list 裡
#+begin_src emacs-lisp
  (defun emacs-packages-installed-p ()
    (loop for p in emacs-packages-list
          when (not (el-get-package-is-installed p)) do (return nil)
          finally (return t)))
#+end_src
*** 當發現有套件存在 emacs-package-list 裡面，但是卻被 emacs-packages-installed-p 回報為
此套件不存在時，重新安裝此套件。
#+begin_src emacs-lisp
  (defun emacs-packages-install-packages ()
    (unless (emacs-packages-installed-p)
      ;; install missing packages
      (dolist (p emacs-packages-list)
        (unless (el-get-package-is-installed p)
          (el-get-reinstall p)))))
  
  ;; install missing packages
  (emacs-packages-install-packages)
#+end_src
* 巨集                                                                :macro:
** Clojure
*** comment
comment 只是用來註釋用，並不會解析裏面的東西。
#+begin_example
  (comment "I am comment.")
#+end_example

#+begin_src emacs-lisp
  (defmacro comment (&rest body)
    "Comment out one or more s-expressions."
    nil)
#+end_src
*** ->
#+begin_src emacs-lisp
  (defmacro -> (x &optional form &rest more)
    (cond ((not (null more))
           `(-> (-> ,x ,form) ,@more))
          ((not (null form))
           (if (sequencep form)
               `(,(first form) ,x ,@(rest form))
             (list form x)))
          (t x)))
#+end_src
*** ->>
#+begin_src emacs-lisp
  (defmacro ->> (x form &rest more)
    (cond ((not (null more)) `(->> (->> ,x ,form) ,@more))
          (t (if (sequencep form)
                 `(,(first form) ,@(rest form) ,x)
               (list form x)))))
#+end_src
*** -?>
#+begin_src emacs-lisp
  (defmacro -?> (x form &rest more)
    (cond ((not (null more)) `(-?> (-?> ,x ,form) ,@more))
          (t (if (sequencep form)
                 `(if (null ,x) nil
                    (,(first form) ,x ,@(rest form)))
               `(if (null ,x) nil
                  ,(list form x))))))
#+end_src
*** -?>>
#+begin_src emacs-lisp
  (defmacro -?>> (x form &rest more)
    (cond ((not (null more)) `(-?>> (-?>> ,x ,form) ,@more))
          (t (if (sequencep form)
                 `(if (null ,x) nil
                    (,(first form) ,@(rest form) ,x))
               `(if (null ,x) nil
                  ,(list form x))))))
#+end_src
*** if-not
#+begin_src emacs-lisp
  (defmacro if-not (test then &optional else)
    "Evaluates test. If logical false, evaluates and returns then expr,
    otherwise else expr, if supplied, else nil."
    `(if (not ,test) ,then ,else))
#+end_src

** Scheme
*** define
#+begin_src emacs-lisp
  (defmacro define (what &rest rest)
    "Scheme-like alias to defvar/defun"
    (if (consp what)
        `(defun  ,(car what) ,(cdr what) ,@rest)
      `(defvar ,what ,@rest)))
  ;; Syntaxes:
  ;;  (define varname opt-defaultvalue "opt-docscring"
  ;;  (define (fname arg1 arg2...) "opt-docstring" (interactive) (stmt1) ...)
#+end_src
** Other
*** defclosure
#+begin_example
  (defclosure counter (&optional increment)
    "Iseless and bizar counter"
    ((one 0)
     (two 1))
    (incf two (incf one (or increment two))))

(counter) => 2
(counter) => 5
#+end_example

#+begin_src emacs-lisp
  (defmacro defclosure (name arglist docstring bindings &rest body)
    "Define NAME as a closure.

          DOCSTRING is *not* optional.
          BINDINGS is an alist of lexical bindings.
          The definition is (lambda ARGLIST DOCSTRING BODY...)."
    (declare (indent defun))
    `(lexical-let (,@bindings)
       (defun ,name (,@arglist)
         ,docstring
         ,@body)))
#+end_src
*** safe
ref: http://curiousprogrammer.wordpress.com/2009/06/08/error-handling-in-emacs-lisp/
#+begin_src emacs-lisp
  (defmacro safe-wrap (fn &rest clean-up)
    `(unwind-protect
         (let (retval)
           (condition-case ex
               (setq retval (progn ,fn))
             ('error
              (message (format "Caught exception: [%s]" ex))
              (setq retval (cons 'exception (list ex)))))
           retval)
       ,@clean-up))
#+end_src
* Depends
#+begin_src emacs-lisp
;;  (require* 'tabbar)
  (require* 'sauron)
  (require* 'traverselisp)
  (require* 'space-chord)
  (require* 'switch-window)
  (require 'projectile)
  (projectile-mode)
#+end_src

ok

#+begin_src emacs-lisp
  (require* 'rainbow-mode)
  (require* 'ascii)
  (require* 'ace-jump-mode)
  (require* 'smarter-compile)
  (require* 'smallurl)
  (require* 'unicad)
  (require* 'iedit)

  (require* 'expand-region)
  (require* 'sr-speedbar)
  (require* 'helm)
  (require* 'htmlize)
  (require* 'pretty-lambdada)
#+end_src
parenface 可以將所有的圓括號上色。
#+begin_src emacs-lisp
  (require 'parenface)
  (set-face-foreground 'paren-face "green")
#+end_src

#+begin_src emacs-lisp
;;(require* 'smart-tab)
#+end_src
** Build-in
#+begin_src emacs-lisp
  (require 'misc)
  (require 'cc-mode)
#+end_src
iimage 是讓 emacs 可以直接顯示圖片的模式。
#+begin_src emacs-lisp
  (require 'iimage)
#+end_src

* Advice                                                             :advice:
advice file
#+begin_src emacs-lisp
  (defadvice kill-emacs (around recompile-emacs-config activate)
    "Before exit emacs, kill config.el which is generate by config.org."
    (let ((file-name (expand-file-name (concat emacs-dir "config.el"))))
      (if (file-exists-p file-name)
          (delete-file file-name nil))
      ad-do-it))
#+end_src
* Function                                                         :function:
我所自定義或是我的 emacs 設定檔需要用到的 function。
** List Processing
處理 List 所用的 function。
*** flatten a list
flatten a list 是一種方法，可以用來將巢狀的 list 變成單一個 list。
舉例來說，假如目前有這樣一個 list:

#+begin_example
(1 (2 3) (4 (5 6 (7))) 8 9)
#+end_example

則使用 flatten 這個 function 可以將上面的巢狀 list 變成:

#+begin_example
(1 2 3 4 5 6 7 8 9)
#+end_example

#+begin_src emacs-lisp
  (defun flatten (structure)
    "Flatten the nesting in an arbitrary list of values."
    (cond ((null structure) nil)
          ((atom structure) `(,structure))
          (t (mapcan #'flatten structure))))
#+end_src
*** List to string
將一個 list 變成字串回傳。
#+begin_src emacs-lisp
  (defun list-to-string (char-list)
    "RETURN: A new string containing the characters in char-list."
    (let ((result (make-string (length char-list) 0))
          (i 0))
      (dolist (char char-list)
        (aset result i char)
        (setq i (1+ i)))
      result))
#+end_src
** Search
搜尋相關的 function。
*** search-backward-to-char
向後搜尋一個字元。
#+begin_src emacs-lisp
  (defun search-backward-to-char (chr)
    "Search backwards to a character"
    (while (not (= (char-after) chr))
      (backward-char 1)))
#+end_src
*** search-forward-to-char
向前搜尋一個字元。
#+begin_src emacs-lisp
  (defun search-forward-to-char (chr)
    "Search forwards to a character"
    (while (not (= (char-before) chr))
      (forward-char 1)))
#+end_src
*** recursive-find-file
遞迴尋找檔案，若在當前目錄找不到此檔案，則去其父目錄進行尋找。
如果該檔案或是目錄不存在，則回傳 nil.
#+begin_src emacs-lisp
  (defun coldnew/recursive-find-file (file &optional directory)
    "Find the first FILE in DIRECTORY or it's parents.
  If file does not exist return nil."
    (let ((directory (or directory
                         (file-name-directory (buffer-file-name))
                         (pwd))))
      (if (file-exists-p (expand-file-name file directory))
          (expand-file-name file directory)
        (unless (string= "/" directory)
          (coldnew/recursive-find-file file (expand-file-name ".." directory))))))
#+end_src
** Testing
測試用的 function，和測試用的變數很像，但是他允許參數的輸入。
*** font-exist-p
測試這個字體在系統內是否存在。
#+begin_src emacs-lisp
  (defun font-exist-p (fontname)
    "test if this font is exist or not."
    (if (not (x-list-fonts fontname))
        nil t))
#+end_src
** File
*** filesize
#+begin_src emacs-lisp
  (defun file-size (filename)
    "Return the size in bytes of file named FILENAME, as in integer.
  Returns nil if no such file."
    (nth 7 (file-attributes filename)))
#+end_src
** Convert
進行轉換用的 function。
*** 將輸入的 buffer (DOS 格式)　轉換成 UNIX 格式。　
#+begin_src emacs-lisp
  (defun dos->unix (buf)
    "Convert buffer file from dos file to unix file."
    (let* (current-buf (current-buffer))
      (if (not (eq current-buf buf))
          (switch-to-buffer buf))
      (goto-char(point-min))
      (while (search-forward "\r" nil t) (replace-match ""))))
#+end_src
*** 將輸入的 buffer (UNIX 格式)　轉換成 DOS 格式。　
#+begin_src emacs-lisp
  (defun unix->dos (buf)
    "Convert buffer file from unix file to dos file."
    (let* (current-buf (current-buffer))
      (if (not (eq current-buf buf))
          (switch-to-buffer buf))
      (goto-char(point-min))
      (while (search-forward "\n" nil t) (replace-match "\r\n"))))
#+end_src
*** 將檔案變成字串，此 function 比較適用於該檔案只有一行（或少數幾行）的情況。
#+begin_src emacs-lisp
  (defun file->string (file)
    "Convert file to string in buffer with quote."
    (when (file-readable-p file)
      (with-temp-buffer
        (insert-file-contents file)
        (buffer-string))))
#+end_src
*** 十進位轉換成十六進位
#+begin_src emacs-lisp
  (defun dec->hex (decimal)
    "Convert decimal to hexdecimal number."
    (let ((hexstr))
      (if (stringp decimal)
          (setq decimal (string-to-number decimal 16)))
      (cond
       ;; Use #x as hex prefix (elisp, ....)
       ((or (eq major-mode 'emacs-lisp-mode)
            (eq major-mode 'lisp-interaction-mode)) (setq hexstr "#x"))
       ;; Use # as hex prefix (CSS, ....)
       ((eq major-mode 'css-mode) (setq hexstr "#"))
       ;; otherwise use 0x as hexprefix (C, Perl...)
       (t (setq hexstr "0x")))
      (format "%s%02X" hexstr decimal)))
#+end_src
*** 十六進位轉換成十進位
#+begin_src emacs-lisp
  (defun hex->dec (hex)
    "Convert hexdecimal number or string to digit-number."
    (let ((case-fold-search nil)
          (hex-regexp (rx (or
                           ;; elisp
                           (group bol "#x")
                           ;; C perl
                           (group bol "0x")
                           ;; CSS
                           (group bol "#")))))
      (if (not (stringp hex))
          (setq hex (symbol-name hex)))
      (string-to-number
       (replace-regexp-in-string hex-regexp "" hex)
       16)))
#+end_src
** Sort
*** quicksort
#+begin_src emacs-lisp
  (defun quicksort (lst)
    "Implement the quicksort algorithm."
    (if (null lst) nil
      (let* ((spl (car lst))
             (rst (cdr lst))
             (smalp (lambda (x)
                      (< x spl))))
        (append (quicksort (remove-if-not smalp rst))
                (list spl)
                (quicksort (remove-if smalp rst))))))
#+end_src
** Buffer
*** get-buffers-matching-mode
取得 major-mode 和要求符合的所有 buffer，假如我們希望可以列出所有為
emacs-lisp-mode 的 buffer，可以這樣做
#+begin_src emacs-lisp :tangle no
  (get-buffers-matching-mode 'emacs-lisp-mode)
#+end_src

#+begin_src emacs-lisp
  (defun get-buffers-matching-mode (mode)
    "Returns a list of buffers where their major-mode is equal to MODE"
    (let ((buffer-mode-matches '()))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (if (eq mode major-mode)
              (add-to-list 'buffer-mode-matches buf))))
      buffer-mode-matches))
#+end_src
*** show-buffer-major-mode
顯示 buffer 目前所處於的 major-mode

#+begin_src emacs-lisp :tangle no
  (show-buffer-major-mode "*scratch*")
#+end_src

#+begin_src emacs-lisp
  (defun show-buffer-major-mode (buffer-or-string)
    "Returns the major mode associated with a buffer."
    (with-current-buffer buffer-or-string major-mode))
#+end_src
** System
和系統相關的 function。
*** get-ip-address
取得目前的 IP 位置，預設為 eth0。（此 function 不能用於 windows 上）
#+begin_src emacs-lisp
  (defun get-ip-address (&optional dev)
    "get the IP-address for device DEV (default: eth0)"
    (let ((dev (if dev dev "eth0")))
      (format-network-address (car (network-interface-info dev)) t)))
#+end_src
** Date
#+begin_src emacs-lisp
  (defun current-date-time ()
    "return current date in `%Y-%m-%d' format, ex:`2012-04-25'."
    (let ((system-time-locale "en_US")
          (format "%Y-%m-%d"))
      (format-time-string "%Y-%m-%d")))

  (defun day-of-week (year month day)
    "Returns the day of the week as an integer.
     Monday is 1."
    (nth 6 (decode-time (encode-time 0 0 0 day month year))))

  (defun day-of-week-in-string (year month day)
    "Return the day of the week as day name."
    (let* ((day-names '("Sunday" "Monday" "Tuesday" "Wednesday"
                        "Thursday" "Friday" "Saturday"))
           (day-index (nth 6 (decode-time (encode-time 0 0 0 day month year)))))
      (nth day-index day-names)))
#+end_src
** other
#+begin_src emacs-lisp
  (defun map-define-key (mode-map keylist fname)
    "Like define-key but the key arg is a list that should be mapped over.
     For example: (map-define-key '(a b c d) 'function-name)."
    (mapc (lambda (k) (define-key mode-map k fname))
          keylist))

  (defun emacs-process-p (pid)
    "If pid is the process ID of an emacs process, return t, else nil.
  Also returns nil if pid is nil."
    (when pid
      (let ((attributes (process-attributes pid)) (cmd))
        (dolist (attr attributes)
          (if (string= "comm" (car attr))
              (setq cmd (cdr attr))))
        (if (and cmd (or (string= "emacs" cmd) (string= "emacs.exe" cmd))) t))))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Region
  ;;;; ---------------------------------------------------------------------------
  (defun select-region-to-before-match (match &optional dir)
    "Selects from point to the just before the first match of
  'match'.  The 'dir' controls direction, if nil or 'forwards then
  go forwards, if 'backwards go backwards."
    (let ((start (point))
          (end nil))

      (transient-mark-mode 1)    ;; Transient mark
      (push-mark)                ;; Mark the start, where point is now

      (if (or (null dir)
              (equalp 'forwards dir))

          ;; Move forwards to the next match then back off
          (progn
            (search-forward match)
            (backward-char))

        ;; Or search backwards and move forwards
        (progn
          (search-backward match)
          (forward-char)))

      ;; Store, then hilight
      (setq end (point))
      (exchange-point-and-mark)

      ;; And return, swap the start/end depending on direction we're going
      (if (or (null dir)
              (equalp 'forwards dir))
          (list start end)
        (list end start))))
#+end_src
* 字體                                                                 :font:
** 英文字體
#+begin_src emacs-lisp
  (defvar emacs-english-font "Monaco"
    "The font name of English.")
  (defvar emacs-english-font-size 11.5
    "Default English font size.")
#+end_src
** 中文字體
#+begin_src emacs-lisp
  (defvar emacs-cjk-font "Hiragino Sans GB W3"
    "The font name for CJK.")
  (defvar emacs-cjk-font-size 13.5
    "Default CJK font size.")
#+end_src
** 符號字體
*** TODO 不能使用，為什麼？
#+begin_src emacs-lisp
  (defvar emacs-symbol-font "Monaco"
    "The font name for Synbol.")
  (defvar emacs-symbol-font-size 16
    "Default Symbol font size.")
#+end_src
** 在圖形介面下使用我所設定的字體
#+begin_src emacs-lisp
  (cond ((eq window-system 'x)
         ;; Setting English Fonts
         (if (font-exist-p emacs-english-font)
             (set-frame-font (format "%s-%s" (eval emacs-english-font) (eval emacs-english-font-size))))

         ;; Setting Chinese Fonts
         (if (font-exist-p emacs-cjk-font)
             (set-fontset-font (frame-parameter nil 'font)
                               'han (format "%s-%s" (eval emacs-cjk-font) (eval emacs-cjk-font-size))))

         ;; Setting Symbol Fonts
         (if (font-exist-p emacs-symbol-font)
             (set-fontset-font (frame-parameter nil 'font)
                               'symbol (format "%s-%s" (eval emacs-symbol-font) (eval emacs-symbol-font-size))))
         ))
#+end_src
** 設定顯示字體時的格式
使用 *list-face-display* 可以看到所有的 face 顏色與字體。
#+begin_src emacs-lisp
  (setq list-faces-sample-text
        (concat
         "ABCDEFTHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz\n"
         "11223344556677889900       壹貳參肆伍陸柒捌玖零"
         ))
#+end_src
* 佈景主題                                                            :theme:
佈景主題的設置，包含我自訂的佈景主題以及路徑。
** 設定佈景主題的位置。
佈景主題的路徑設定在 emacs-themes-dir 裡面。
#+begin_src emacs-lisp
  (setq custom-theme-directory emacs-themes-dir)
#+end_src
** coldnew-night
我自己設計的暗色系佈景主題，會輸出成 ~/.emacs.d/themes/coldnew-night-theme.el

:PROPERTIES:
:comments: org
:tangle:   ~/.emacs.d/themes/coldnew-night-theme.el
:cache: yes
:padline: no
:END:

*** Header
#+begin_src emacs-lisp
  ;;; coldnew-night-theme.el --- Custom face theme for Emacs

  ;; Copyright (C) 2012 coldnew.

  ;; This file is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This file is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

  ;;; Code:
#+end_src

*** Init
#+begin_src emacs-lisp
  (deftheme coldnew-night
    "coldnew's dark theme.")

  (custom-theme-set-faces
   'coldnew-night
#+end_src
*** 背景與文字
設定 emacs 的背景和文字顏色
#+begin_src emacs-lisp
  '(default ((t (:background "#0B0B0E" :foreground "#DCDCDC"))))
#+end_src
*** 游標
設定 emacs 的游標顏色
#+begin_src emacs-lisp
  '(cursor ((t (:background "#C2C2C2" :foreground "#0B0B0E"))))
#+end_src
*** Region
#+begin_src emacs-lisp
  '(region ((t (:background "#444444" :foreground "#DCDCDC"))))
#+end_src
*** Mode Line
#+begin_src emacs-lisp
  '(mode-line ((t (:background "#0C0C0C" :foreground "#B1C3D4"
                               :box (:line-width 2 :color "#B184CB")))))
  '(mode-line-inactive ((t (:background "#343434" :foreground "#7B8793"
                                        :box (:line-width 2 :color "#565968")))))
  '(mode-line-buffer-id ((t (:foreground "#CDCDCD":bold t :italic t))))
#+end_src
*** fringe
#+begin_src emacs-lisp
  '(fringe ((t (:background "#2A2A2A"))))
#+end_src
*** Minibuffer
#+begin_src emacs-lisp
  '(minibuffer-prompt ((t (:foreground "#E52210" :bold t))))
#+end_src
*** Font-lock
#+begin_src emacs-lisp
  '(font-lock-builtin-face ((t (:foreground "#4BC98A"))))
  ;; Comment
  '(font-lock-comment-face ((t (:foreground "#5D9AE4" :italic t))))
  ;; Constant
  '(font-lock-constant-face ((t (:foreground "#E53F3F" :bold t))))
  ;; Function name
  '(font-lock-function-name-face ((t (:foreground "#AD7FA8" :italic t :bold t))))
  ;; Keyword
  '(font-lock-keyword-face ((t (:foreground "#FFC125"))))
  ;; String
  '(font-lock-string-face ((t (:foreground "#95E454" :italic t))))
  ;; Type
  '(font-lock-type-face ((t (:foreground "#CAE682"))))
  ;; Variable
  '(font-lock-variable-name-face ((t (:foreground "#4BC98A"))))
  ;; Warning
  '(font-lock-warning-face ((t (:foreground "#E91303" :bold t))))
  ;; Doc
  '(font-lock-doc-face ((t (:foreground "#40AAFA"))))

#+end_src
*** Auto-Complete
#+begin_src emacs-lisp
  '(ac-candidate-face ((t (:background "#424242" :foreground "white"))))
  '(ac-selection-face ((t (:background "#CAE682" :foreground "#0C0C0C"))))
#+end_src
*** org-mode
#+begin_src emacs-lisp
  '(org-date ((t (:foreground "#4D85FF" :bold t))))
  '(org-agenda-date ((t (:foreground "#8AC6F2"))))
  '(org-agenda-date-weekend ((t (:bold t :foreground "#E65C00" :weight bold))))
  '(org-hide ((t (:foreground "#0B0B0E"))))
  '(org-todo ((t (:foreground "#F43012" :bold t))))
  '(org-hide ((t (:foreground "#0B0B0E"))))
  '(org-done ((t (:foreground "#4BC98A" :bold t))))
  '(org-link   ((t (:inherit (link)))))
#+end_src
**** org-level
#+begin_src emacs-lisp
  '(org-level-1 ((t (:foreground "#8AC6F2" :bold t))))
  '(org-level-2 ((t (:foreground "#ee9a49"))))
  '(org-level-3 ((t (:foreground "#ff83fa"))))
  '(org-level-4 ((t (:foreground "#efe500"))))
  '(org-level-5 ((t (:foreground "#ff4040"))))
  '(org-level-6 ((t (:foreground "#afe04e"))))
  '(org-level-7 ((t (:foreground "#0A4C64"))))
#+end_src
*** lusty-explorer
#+begin_src emacs-lisp
  '(lusty-match-face ((t (:inherit font-lock-function-name-face))))
  '(lusty-directory-face ((t (:inherit font-lock-type-face))))
  '(lusty-file-face ((t (:inherit font-lock-string-face))))
#+end_src
*** woman
#+begin_src emacs-lisp
  '(woman-italic-face ((t (:slant italic :weight bold))))
  '(woman-unknown ((t (:foreground "#EA0000" :weight bold))))
  '(woman-addition ((t (:foreground "cadet blue"))))
  '(woman-bold ((t (:inherit bold :foreground "CadetBlue3"))))
#+end_src
*** rainbow-delimiters
#+begin_src emacs-lisp
  '(rainbow-delimiters-depth-1-face ((t (:foreground "green"))))
  ;; '(rainbow-delimiters-depth-2-face ((t (:foreground  "yellow"))))
  ;; '(rainbow-delimiters-depth-3-face ((t (:foreground  "blue"))))
  ;; '(rainbow-delimiters-depth-4-face ((t (:foreground "purple"))))
  ;; '(rainbow-delimiters-depth-5-face ((t (:foreground "orange"))))
  ;; '(rainbow-delimiters-depth-6-face ((t (:foreground  "magenta"))))
  ;; '(rainbow-delimiters-depth-7-face ((t (:foreground  "spring green"))))
  ;; '(rainbow-delimiters-depth-8-face ((t (:foreground  "coral"))))
  ;; '(rainbow-delimiters-depth-9-face ((t (:foreground  "dodger blue"))))
  ;; '(rainbow-delimiters-depth-10-face ((t (:foreground "violet red"))))
  ;; '(rainbow-delimiters-depth-11-face ((t (:foreground "DarkOrange1"))))
  ;; '(rainbow-delimiters-depth-12-face ((t (:foreground "chartreuse2"))))
#+end_src
*** Other
#+begin_src emacs-lisp
  ;; Link
  '(link ((t (:foreground "dodger blue" :underline t))))
  ;; '(link-visited ((t (:foreground "#8b008b" :underline t))))

   ;;;; Show Paren
  '(show-paren-match ((t (:background "#E65C00" :foreground "#CDCDCD" :bold t))))
  '(show-paren-mismatch ((t (:background "#0C0C0C" :foreground "#E91303" :bold t))))

   ;;;; isearch
  '(isearch ((t (:background "#F57900" :foreground "#7F6BFF"))))
  '(lazy-highlight ((t (:background "#E9B96E" :foreground "#7F6BFF"))))

   ;;;; Comint
  '(comint-highlight-prompt ((t (:foreground "#5D9AE4" :bold t))))

   ;;;; Hl-line
  '(hl-line ((t :background "#444444")))

   ;;;; selection
  '(secondary-selection ((t (:background "#CAE682" :foreground "#0c0c0c"))))

   ;;;; Diff
  '(diff-added ((t (:foreground "#95E454"))))
  '(diff-removed ((t (:foreground "#E52210"))))
  '(diff-header ((t (:background "#0B0B0E"))))
  '(diff-hunk-header ((t (:foreground "yellow"))))
  '(diff-function ((t :foreground "green")))
  '(diff-file-header ((t (:foreground "aquamarine1" :slant italic :weight bold))))
  '(diff-header ((t (:foreground "VioletRed1"))))
   ;;;;;;
  '(diff-index ((t (:foreground "yellow"))))
  '(diff-context ((t (:inherit font-lock-comment))))
  '(diff-refine-change ((t (:background "#0B0B0E" :foreground "#DCDCDC"))))

   ;;;; cua
  '(cua-rectangle ((t (:background "#444444" :foreground "#DCDCDC"))))

   ;;;; iBuffer
  '(ibuffer-deletion ((t (:foreground "#dfaf8f" :weight bold))))
  '(ibuffer-help-buffer ((t (:inherit font-lock-comment))))
  '(ibuffer-marked ((t (:foreground "#f0dfaf" :weight bold))))
  '(ibuffer-special-buffer ((t (:inherit font-lock-doc))))

   ;;;; iBuffer-git
  '(ibuffer-git-add-face ((t (:inherit (diff-added)))))
  '(ibuffer-git-del-face ((t (:inherit (diff-removed)))))

   ;;;; ECB
  '(ecb-default-highlight-face ((t (:background "#CAE682" :foreground "#0C0C0C" :bold t))))

   ;;;;
  ;; '(button ((t (:underline t))))
  ;; '(header-line ((t (:background "#e5e5e5" :foreground "#333333"))))
#+end_src
*** elscreen
#+begin_src emacs-lisp
  '(elscreen-tab-background-face ((t (:background "#272729" ))))
  '(elscreen-tab-control-face ((t (:foreground "white" :background "black" :weight extra-bold))))
  '(elscreen-tab-current-screen-face ((t (:background "#250628" :foreground "Gray90" :bold t))))
  '(elscreen-tab-other-screen-face ((t (:background "#1D1D1F" :foreground "Gray85" :bold t))))
#+end_src
*** End of File
#+begin_src emacs-lisp
  )

  (provide-theme 'coldnew-night)

  ;; Local Variables:
  ;; no-byte-compile: t
  ;; End:

  ;;; coldnew-night-theme.el  ends here
#+end_src

** 設定預設讀取的佈景主題。
#+begin_src emacs-lisp
  (load-theme 'coldnew-night t)
#+end_src
* Mode
** auto-complete
*** Depends
#+begin_src emacs-lisp
  (require 'auto-complete)
  (require 'auto-complete-config)
  (require* 'auto-complete-clang)
#+end_src
*** Config
**** 使用預設的設定。
#+begin_src emacs-lisp
  (ac-config-default)
#+end_src

**** 不使用 fuzzy-match
#+begin_src emacs-lisp
  (setq ac-use-fuzzy nil)
#+end_src
**** 當輸入 4 個字母以上時，啟用自動補全。
#+begin_src emacs-lisp
  (setq ac-auto-start 4)
#+end_src

#+begin_src emacs-lisp
  ;; Ignore case if completion target string doesn't include upper characters
  (setq ac-ignore-case 'smart)

  ;; Enable auto-complete quick help
  (setq ac-use-quick-help t)

  ;; After 0.01 sec, show help window
  (setq ac-quick-help-delay 0.5)

  ;; Enable ac-comphist
  (setq ac-use-comphist t)

  ;; Setting ac-comphist data
  (setq ac-comphist-file (concat emacs-cache-dir "auto-complete.dat"))

  ;; Show menu
  (setq ac-auto-show-menu t)

  ;; Enable ac-menu-map
  (setq ac-use-menu-map t)
#+end_src
*** Keybinding
auto-complete-mode 的按鍵設定。
#+begin_src emacs-lisp
  (define-key ac-menu-map (kbd "C-n") 'ac-next)
  (define-key ac-menu-map (kbd "C-p") 'ac-previous)
  (define-key ac-completing-map "\t" 'ac-complete)
  (define-key ac-complete-mode-map[tab] 'ac-expand)
#+end_src
** auto-indent
*** Depends
#+begin_src emacs-lisp
  (require* 'auto-indent-mode)
#+end_src
** android                                                         :android:
#+begin_src emacs-lisp
  (require* 'android-mode)
  ;; Set my android-emulator-path
  (setq android-mode-sdk-dir "/opt/android-sdk-update-manager/")
#+end_src
** elscreen                                                       :elscreen:
*** Depends
#+begin_src emacs-lisp
  (require* 'elscreen)
#+end_src
*** Config
**** 自動啟用 elscreen
#+begin_src emacs-lisp
  (elscreen-start)
#+end_src
**** 分頁上顯示 *控制* 圖示
#+begin_src emacs-lisp
  (setq elscreen-tab-display-control t)
#+end_src
**** 分頁上不顯示 *關閉* 圖示
#+begin_src emacs-lisp
  (setq elscreen-tab-display-kill-screen nil)
#+end_src
*** Advice
當目前只有一個 elscreen-tab 存在時，呼叫 *elscreen-next* 、 *elscreen-previous*
或是 *elscreen-toggle* 會自動建立另外一個 elscreen-tab。
#+begin_src emacs-lisp
  (defmacro elscreen-create-automatically (ad-do-it)
    (` (if (not (elscreen-one-screen-p))
           (, ad-do-it)
         (elscreen-create)
         (elscreen-notify-screen-modification 'force-immediately)
         (elscreen-message "New screen is automatically created"))))

  (defadvice elscreen-next (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))

  (defadvice elscreen-previous (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))

  (defadvice elscreen-toggle (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))
#+end_src
** eshell                                                           :eshell:
*** Depends
#+begin_src emacs-lisp
  (require 'eshell)
  (require 'em-dirs)
  (require 'em-hist)
  (require 'em-prompt)
  (require 'em-term)
  (require 'em-cmpl)
#+end_src
*** Config
**** Prompt
將 eshell 的 prompt 設定成和 bash 一樣，也就是　 username@system-name。
#+begin_src emacs-lisp
  (setq eshell-prompt-function
        '(lambda ()
           (concat
            user-login-name "@" system-name " "
            (if (search (directory-file-name (expand-file-name (getenv "HOME"))) (eshell/pwd))
                (replace-regexp-in-string (expand-file-name (getenv "HOME")) "~" (eshell/pwd))
              (eshell/pwd))
            (if (= (user-uid) 0) " # " " $ ")
            )))
#+end_src
#+begin_src emacs-lisp
  ;;; change history file path
  (setq eshell-last-dir-ring-file-name (concat emacs-cache-dir "eshell-lastdir"))
  (setq eshell-history-file-name (concat emacs-cache-dir "eshell-history"))

  ;; other setting
  (setq eshell-save-history-on-exit t)
  (setq eshell-ask-to-save-last-dir nil)
  (setq eshell-history-size 512)
  (setq eshell-hist-ignoredups t)
  (setq eshell-cmpl-cycle-completions nil)
  (setq eshell-scroll-to-bottom-on-output t)
  (setq eshell-show-maximum-output t)

  ;;;; ---------------------------------------------------------------------------
  ;;;; Hooks
  ;;;; ---------------------------------------------------------------------------

  ;;; Make eshell prompt more colorful
  (add-to-list 'eshell-output-filter-functions 'coldnew/colorfy-eshell-prompt)

  ;; my auto-complete for elisp
  (add-hook 'eshell-mode-hook 'auto-complete-mode)
  (add-hook 'eshell-mode-hook 'ac-eshell-mode-setup)

  ;; use helm to complete esehll
  (when (featurep 'helm)
    (add-hook 'eshell-mode-hook
              #'(lambda ()
                  (define-key eshell-mode-map
                    [remap pcomplete]
                    'helm-esh-pcomplete))))


  ;; define ac-source for eshell-pcomplete
  (ac-define-source eshell-pcomplete
    '((candidates . pcomplete-completions)
      (cache)
      (symbol . "f")))

  (defun ac-eshell-mode-setup ()
    "auto-complete settings for eshell-mode"
    (setq ac-sources
          '(
            ac-source-eshell-pcomplete
            ;; ac-source-symbols
            ;; ac-source-variables
            ;; ac-source-functions
            ;; ac-source-features
            ;; ac-source-filename
            ;; ac-source-files-in-current-dir
            ;; ac-source-words-in-same-mode-buffers
            )))
#+end_src
*** Command
#+begin_src emacs-lisp
  ;; find-file
  ;; (defun eshell/ef (file) (find-file file))
  (defun eshell/ef (&rest args) (eshell/emacs args))

  ;; ediff
  (defun eshell/ed (file1 file2) (ediff file1 file2))

  ;; clear
  (defun eshell/clear ()
    "Clears the shell buffer ala Unix's clear or DOS' cls"
    (interactive)
    ;; the shell prompts are read-only, so clear that for the duration
    (let ((inhibit-read-only t))
      ;; simply delete the region
      (delete-region (point-min) (point-max))))


  (defun eshell/info (subject)
    "Read the Info manual on SUBJECT."
    (let ((buf (current-buffer)))
      (Info-directory)
      (let ((node-exists (ignore-errors (Info-menu subject))))
        (if node-exists
            0
          ;; We want to switch back to *eshell* if the requested
          ;; Info manual doesn't exist.
          (switch-to-buffer buf)
          (eshell-print (format "There is no Info manual on %s.\n"
                                subject))
          1))))

  (defun eshell/emacs (&rest args)
    "Open a file in emacs. Some habits die hard."
    (if (null args)
        ;; If I just ran "emacs", I probably expect to be launching
        ;; Emacs, which is rather silly since I'm already in Emacs.
        ;; So just pretend to do what I ask.
        (bury-buffer)
      ;; We have to expand the file names or else naming a directory in an
      ;; argument causes later arguments to be looked for in that directory,
      ;; not the starting directory
      (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))
#+end_src
*** Function
#+begin_src emacs-lisp
  (defun coldnew/colorfy-eshell-prompt ()
    (interactive)
    (let* ((mpoint)
           (user-string-regexp (concat "^" user-login-name "@" system-name)))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward (concat user-string-regexp ".*[$#]") (point-max) t)
          (setq mpoint (point))
          (overlay-put (make-overlay (point-at-bol) mpoint) 'face '(:foreground "dodger blue")))
        (goto-char (point-min))
        (while (re-search-forward user-string-regexp (point-max) t)
          (setq mpoint (point))
          (overlay-put (make-overlay (point-at-bol) mpoint) 'face '(:foreground "green3"))
          ))))
#+end_src
** helm-mode                                                          :helm:
*** Depends
#+begin_src emacs-lisp
  (require* 'helm)
  (require 'helm-config)
;;  (require 'helm-projectile)
;;  (require 'helm-etags+)
  (require 'ctags-update)
#+end_src
*** TODO Config this
#+begin_src emacs-lisp
  ;; Use predefined configurations for `helm.el'
  (setq helm-config t)

  ;; Enable helm globally
  (helm-mode 1)

  ;; Enable dired binding
  (helm-dired-bindings 1)

  (ctags-update-minor-mode 1)
#+end_src
*** Function
#+begin_src emacs-lisp
  (defun helm-c-occur-get-line (s e)
    "rewrite `helm-c-occur-get-line' to make it color on line-number."
    (concat (propertize (format "%7d" (line-number-at-pos (1- s))) 'face '((:foreground "red")))
            (format ": %s" (buffer-substring s e))))
#+end_src
*** Commands
#+begin_src emacs-lisp
  (defun coldnew/helm-filelist ()
    "Preconfigured `anything' to open files/buffers/bookmarks instantly.
   This is a replacement for `anything-for-files'.
   See `anything-c-filelist-file-name' docstring for usage."
    (interactive)
    (helm-other-buffer
     '(
       helm-c-source-buffers-list
       helm-c-source-recentf
       helm-c-source-ffap-line
       helm-c-source-ffap-guesser
       helm-c-source-bookmarks
       helm-c-source-file-cache
        helm-c-source-projectile-files-list
       helm-c-source-files-in-current-dir
       helm-c-source-locate)
     "*coldnew/filelist*"))
  (defun coldnew/helm-occur ()
    "I don't like highlight when goto lines."
    (interactive)
    ;; FIXME: is there more elegent way to make temp face?
    (set (make-local-variable 'face-remapping-alist) '((helm-selection-line nil)))
    (helm-occur))
#+end_src

** lusty-explorer
*** Depends
#+begin_src emacs-lisp
  (require* 'lusty-explorer)
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (add-hook 'lusty-setup-hook
            '(lambda ()
               (define-key lusty-mode-map (kbd "RET") 'lusty-select-current-name)
               ))
#+end_src
*** Command
#+begin_src emacs-lisp
  (defun lusty-sudo-explorer ()
    "Launch the file/directory mode of LustyExplorer."
    (interactive)
    (let ((lusty--active-mode :file-explorer)
          (lusty-prompt "sudo: >>"))
      (lusty--define-mode-map)
      (let* ((lusty--ignored-extensions-regex
              (concat "\\(?:" (regexp-opt completion-ignored-extensions) "\\)$"))
             (minibuffer-local-filename-completion-map lusty-mode-map)
             (file
              ;; read-file-name is silly in that if the result is equal to the
              ;; dir argument, it gets converted to the default-filename
              ;; argument. Set it explicitly to "" so if lusty-launch-dired is
              ;; called in the directory we start at, the result is that directory
              ;; instead of the name of the current buffer.
              (lusty--run 'read-file-name default-directory "")))
        (when file
          (switch-to-buffer
           (find-file-noselect (concat "/sudo:root@localhost:"
                                       (expand-file-name file))))))))
#+end_src
*** Make lusty-explorer use it's own completion, not helm-completion
#+begin_src emacs-lisp
    (when (featurep 'helm)
      (add-to-list 'helm-completing-read-handlers-alist '(lusty-sudo-explorer . nil))
      (add-to-list 'helm-completing-read-handlers-alist '(lusty-file-explorer . nil))
      (add-to-list 'helm-completing-read-handlers-alist '(lusty-buffer-explorer . nil))
  )
#+end_src

** smex                                                               :smex:
*** Depends
#+begin_src emacs-lisp
  (require* 'smex)
#+end_src
*** Init
啟動 smex
#+begin_src emacs-lisp
  (smex-initialize)
#+end_src
*** Config
#+begin_src emacs-lisp
  (setq smex-save-file (concat emacs-cache-dir "smex.dat"))
#+end_src
** minibuffer
*** 設定視窗高度最多為4行高
#+begin_src emacs-lisp
  (setq max-mini-window-height         4) 
#+end_src
*** 按鍵設定
| 按鍵 | 命令                     | 用途           |
|------+--------------------------+----------------|
| M-l  | backward-kill-word       | 刪除前一個詞   |
| M-p  | previous-history-element | 前一個歷史紀錄 |
| M-n  | next-history-element     | 後一個歷史紀錄 |
#+begin_src emacs-lisp
  (define-key minibuffer-local-map (kbd "M-l") 'backward-kill-word)
  (define-key minibuffer-local-map (kbd "M-p") 'previous-history-element)
  (define-key minibuffer-local-map (kbd "M-n") 'next-history-element)
  (define-key minibuffer-local-map (kbd "C-g") 'minibuffer-keyboard-quit)
#+end_src

#+begin_src emacs-lisp
  (define-key minibuffer-local-map (kbd "C-r") 'resolve-sym-link)
  (define-key minibuffer-local-map (kbd "C-u") (lambda () (interactive) (kill-line 0)))
#+end_src
*** 其他
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers     t )
  (setq minibuffer-electric-default-mode t )


  ;;;; ---------------------------------------------------------------------------
  ;;;; Hooks
  ;;;; ---------------------------------------------------------------------------

  ;; Abort the minibuffer when using the mouse
  (add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)

  ;;;; ---------------------------------------------------------------------------
  ;;;; Functions
  ;;;; ---------------------------------------------------------------------------

  (defun stop-using-minibuffer ()
    "kill the minibuffer"
    (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
      (abort-recursive-edit)))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Commands
  ;;;; ---------------------------------------------------------------------------
  (defun resolve-sym-link ()
    "Replace the string at the point with the true path."
    (interactive)
    (beginning-of-line)
    (let* ((file (buffer-substring (point)
                                   (save-excursion (end-of-line) (point))))
           (file-dir (file-name-directory file))
           (file-true-dir (file-truename file-dir))
           (file-name (file-name-nondirectory file)))
      (delete-region (point) (save-excursion (end-of-line) (point)))
      (insert (concat file-true-dir file-name))))

#+end_src

** ido
*** Depends
#+begin_src emacs-lisp
  (require 'ido)
#+end_src
*** Keybindings
#+begin_src emacs-lisp
  (add-hook 'ido-setup-hook
            '(lambda ()
               (define-key ido-completion-map (kbd "C-f") 'ido-next-match)
               (define-key ido-completion-map (kbd "C-b") 'ido-prev-match)
               ))
#+end_src
** yasnippet                                                     :yasnippet:
*** 設定 snippet 所在的資料夾
#+begin_src emacs-lisp
  (setq-default yas/snippet-dirs emacs-snippets-dir)
#+end_src
*** 載入相關套件
#+begin_src emacs-lisp
  (require 'yasnippet)
  (require 'dropdown-list)
#+end_src
*** 初始化 yasnippet
#+begin_src emacs-lisp
  ;;  (yas/initialize)
  (yas-global-mode 1)
#+end_src
*** 設定 yasnippet 讀取 snippet 的資料夾
#+begin_src emacs-lisp
  (yas/load-directory emacs-snippets-dir)
#+end_src
*** 設定 yasnippet 提示用的 function
#+begin_src emacs-lisp
  (setq yas/prompt-functions '(yas/dropdown-prompt yas/ido-prompt yas/completing-prompt))
#+end_src
*** 當存檔時，更新 snippets
#+begin_src emacs-lisp
  (add-hook 'after-save-hook 'coldnew/update-yasnippets-on-save)
#+end_src
*** Functions
#+begin_src emacs-lisp
  (defun yas/dir ()
    (file-name-directory (buffer-file-name)))
  (defun yas/file ()
    (file-name-nondirectory (buffer-file-name)))
  (defun yas/file-sans ()
    (file-name-sans-extension (file-name-nondirectory (buffer-file-name))))
  (defun yas/file-ext ()
    (file-name-extension (file-name-nondirectory (buffer-file-name))))
  (defun yas/file-sans-upcase ()
    (upcase (yas/file-sans)))
  (defun yas/year ()
    (format-time-string "%Y"))
  (defun yas/user-name ()
    (insert user-full-name))
  (defun yas/login-name ()
    (insert user-login-name))
  (defun yas/user-email ()
    (insert user-mail-address))
  (defun yas/user-nickname ()
    (insert user-nickname))
  (defun coldnew/update-yasnippets-on-save ()
    "automatic reloadinf of ghanged snippets"
    (when (string-match "/snippets/" buffer-file-name)
      (yas/load-snippet-dirs)))
#+end_src
** ibuffer                                                         :ibuffer:
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'ibuffer)
  (require 'ibuf-ext)
#+end_src
*** Config
#+begin_src emacs-lisp
  ;;;; Settings
  (setq ibuffer-always-compile-formats         t )
  (setq ibuffer-default-shrink-to-minimum-size t )
  (setq ibuffer-expert                         t )
  (setq ibuffer-show-empty-filter-groups     nil )
  (setq ibuffer-use-other-window             nil )
  (setq ibuffer-always-show-last-buffer      nil )
#+end_src
integrate ibuffer with git
#+begin_src emacs-lisp
  (require 'ibuffer-git)
  (setq ibuffer-formats
        '((mark modified read-only git-status-mini " "
                (name 23 23 :left :elide)
                " "
                (size-h 9 -1 :right)
                "  "
                (mode 16 16 :left :elide)
                " "
                (git-status 8 8 :left)
                "    "
                ;;              (eproject 16 16 :left :elide)
                ;;              "      "
                filename-and-process)))
#+end_src
buffer list
#+begin_src emacs-lisp
  ;;;; buffer-list
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("*Buffer*" (or
                        (name . "^TAGS\\(<[0-9]+>\\)?$")
                        (name . "^\\**Loading Log\\*$")
                        (name . "^\\*coldnew/filelist\\*$")
                        (name . "^\\*Backtrace\\*$")
                        (name . "^\\*Buffer List\\*$")
                        (name . "^\\*CEDET Global\\*$")
                        (name . "^\\*Compile-Log\\*$")
                        (name . "^\\*Completions\\*$")
                        (name . "^\\*EGG:*")
                        (name . "^\\*Kill Ring\\*$")
                        (name . "^\\*Occur\\*$")
                        (name . "^\\*Customize*")
                        (name . "^\\*Process List\\*$")
                        (name . "^\\*Shell Command Output\\*")
                        (name . "^\\*Warnings\\*$")
                        (name . "^\\*compilation\\*$")
                        (name . "^\\*el-get*")
                        (name . "^\\*grep\\*$")
                        (name . "^\\*gud\\*$")
                        (name . "^\\*ielm\\*")
                        (name . "^\\*im.bitlbee.org\\*$")
                        (name . "^\\*scratch\\*$")
                        (name . "^\\*tramp")
                        (name . "^\\*wclock\\*$")
                        (name . "^ipa*")
                        (name . "^loaddefs.el$")
                        (name . "^\\*Messages\\*$")
                        (name . "^\\*WoMan-Log\\*$")
                        ))
           ("Version Control" (or (mode . svn-status-mode)
                                  (mode . svn-log-edit-mode)
                                  (name . "^\\*svn*\\*")
                                  (name . "^\\*vc*\\*$")
                                  (name . "^\\*Annotate")
                                  (name . "^\\*git-*")
                                  (name . "^\\*cvs*")
                                  (name . "^\\*vc-*")
                                  (mode . egg-status-buffer-mode)
                                  (mode . egg-log-buffer-mode)
                                  (mode . egg-commit-buffer-mode)))
           ("Help" (or (mode . woman-mode)
                       (mode . man-mode)
                       (mode . info-mode)
                       (mode . help-mode)
                       (name . "\\*Help\\*$")
                       (name . "\\*info\\*$")))
           ("Dired" (or (mode . dired-mode)
                        (mode . nav-mode)))
           ("IRC"   (or (mode . erc-mode)
                        (mode . rcirc-mode)))
           ("Jabber" (or (mode . jabber-roster-mode)
                         (mode . jabber-chat-mode)))
           ("Terminal" (or (mode . eshell-mode)
                           (mode . term-mode)
                           (mode . inferior-python-mode)
                           (mode . eshell-mode)
                           (mode . comint-mode)
                           (name . "\\*scheme\\*$")))
           ("Config" (name . "*.conf$"))
           ("Text" (or (mode . text-mode)
                       (name . "*.txt$")))
           ("w3m"   (or (mode . w3m-mode)
                        (name . "^\\*w3m*")))
           ("Org"   (mode . org-mode))
           ("LaTEX" (or (mode . latex-mode)
                        (name . "*.tex$")))
           ("Verilog" (mode . verilog-mode))
           ("Web Develop" (or (mode . html-mode)
                              (mode . css-mode)))
           ("Shell Script" (or (mode . shell-script-mode)
                               (mode . shell-mode)
                               (mode . sh-mode)
                               (mode . ruby-mode)))
           ("Perl"  (or (mode . cperl-mode)
                        (mode . perl-mode)))
           ("Python" (or (mode . python-mode)
                         (mode . ipython-mode)))
           ("Octave" (or (mode . octave-mode)
                         (mode . inferior-octave-mode)))
           ("Scala" (or (mode . scala-mode)
                        (name . "\\*inferior-scala\\*$")))
           ("Diff" (mode . diff-mode))
           ;;      ("Project" (mode . qmake-mode))
           ("JavaScript" (or (mode . js-mode)
                             (mode . js2-mode)))
           ("C++ . C#" (or (mode . c++-mode)
                           (mode . csharpmode)))
           ("C"          (mode . c-mode))
           ("Object-C"   (mode . objc-mode))
           ("Snippet" (or (mode . snippet-mode)
                          (name . "*.yas$")))
           ("newLisp"  (mode . newlisp-mode))
           ("Common Lisp"   (mode . slime-mode))
           ("Scheme"  (or (mode . scheme-mode)
                          (mode . gambit-mode)))
           ("Clojure" (or (mode . clojure-mode)
                          (name . "\\*slime-repl clojure\\*")))
           ("Emacs recipes" (name . "*.rcp$"))
           ("Emacs" (or (mode . emacs-lisp-mode)
                        (mode . lisp-interaction-mode)
                        ))
           )))
#+end_src
Following buffer will not show in iBuffer
#+begin_src emacs-lisp
  (setq ibuffer-never-show-predicates
        (list
         "^\\*Buffer List\\*$"
         "^\\*CEDET Global\\*$"
         "^\\*MiniBuf-*"
         "^\\*Egg:Select Action\\*$"
         "^\\*Ido Completions\\*$"
         "^\\*SPEEDBAR\\*$"
         "^\\*nav\\*$"
         "^\\*swank\\*$"
         "^\\*slime-events\\*$"
         "^\\*RE-Builder\\*$"
         "^\\*pomodoro\\*$"
         "^\\*Project Buffers\\*$"
         "^eproject$"
         "\\*fsm-debug\\*$"
         ;; "^"
         "^\\*.*\\(-preprocessed\\)\\>\\*"
         "^\\*ORG.*\\*"
         "^\\*ac-mode-*"
         ".loaddefs.el$"
         "^loaddefs.el$"
         "^\\*magit*"
         "\\*GTAGS SELECT\\**"
         "\\*Symref*"
         "\\*cscope\\*"
         "\\*helm*"
         ))
#+end_src
*** Advice
#+begin_src emacs-lisp
  ;;;; Advice
  ;; Reverse group list
  (defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups () activate)
    (setq ad-return-value (nreverse ad-return-value)))

  ;; Switching to ibuffer puts the cursor on the most recent buffer
  (defadvice ibuffer (around ibuffer-point-to-most-recent activate)
    "Open ibuffer with cursor pointed to most recent buffer name"
    (let ((recent-buffer-name (buffer-name)))
      ad-do-it
      (ibuffer-jump-to-buffer recent-buffer-name)))

  ;; Kill ibuffer after quit
  (defadvice ibuffer-quit (after kill-ibuffer activate)
    "Kill the ibuffer buffer on exit."
    (kill-buffer "*Ibuffer*"))
#+end_src
*** Keybindings
#+begin_src emacs-lisp
  (define-key ibuffer-mode-map (kbd "C-x C-f") 'lusty-file-explorer)
#+end_src
*** Functions
#+begin_src emacs-lisp
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000) (format "%7.3fK" (/ (buffer-size) 1000.0)))
     ((> (buffer-size) 1000000) (format "%7.3fM" (/ (buffer-size) 1000000.0)))
     (t (format "%8dB" (buffer-size)))))
#+end_src
*** Hooks
**** enable highlight-line
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook 'hl-line-mode)
#+end_src
**** setting default group
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook '(lambda () (ibuffer-switch-to-saved-filter-groups "default")))
#+end_src
**** sort filename automatically
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook 'ibuffer-do-sort-by-filename/process)
#+end_src
** winner
*** Depends
#+begin_src emacs-lisp
  (require 'winner)
#+end_src
*** Cpnfig
#+begin_src emacs-lisp
  ;; do not use default keybindings
  (setq winner-dont-bind-my-keys t)
  ;; Enable winner-mode
  (winner-mode t)
#+end_src
** speedbar
#+begin_src emacs-lisp
  (require 'speedbar)
  (setq speedbar-use-images nil)
  (require 'sr-speedbar)
  (setq sr-speedbar-right-side nil)
  (setq sr-speedbar-refresh-turn-on t)
#+end_src
** shell-pop
*** Depends
#+begin_src emacs-lisp
  (require 'shell-pop)
#+end_src
*** Config
#+begin_src emacs-lisp
  (shell-pop-set-internal-mode "eshell")
  (shell-pop-set-internal-mode-shell emacs-default-shell)
  (shell-pop-set-window-height emacs-popup-shell-window-height)
  (shell-pop-set-window-position emacs-popup-shell-window-position)

  (defadvice shell-pop (before kill-dead-term activate)
    "If there is a stopped ansi-term, kill it and create a new one."
    (let ((running-p (term-check-proc (buffer-name)))
          (term-p (string= "term-mode" major-mode)))
      (if term-p
          (when (not running-p)
            (kill-buffer (buffer-name))
            (shell-pop-out)))))
#+end_src
** multi-term
#+begin_src emacs-lisp
  (require 'multi-term)
  (setq multi-term-program emacs-default-shell)
#+end_src
** term
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'term)
  (require 'ansi-color)
#+end_src
*** Config
term-mode 的設定會影響到 multi-term，這邊我主要是設定顏色。

**** Color
移除 term-mode 預設的前景與背景顏色。
#+begin_src emacs-lisp
  (setq term-default-bg-color nil)
  (setq term-default-fg-color nil)
#+end_src

重新設定 Ansi-Color，讓他和我的佈景主題配合。
#+begin_src emacs-lisp
  ;; reset ansi-color
  (setq-default ansi-color-names-vector
                (vector (frame-parameter nil 'background-color)
                        "#0B0B0E" "#CA3839" "#8ae234" "#edd400"
                        "#729fcf" "#ad7fa8" "cyan3"   "#DCDCDC"))
  (setq ansi-term-color-vector ansi-color-names-vector)
  ;; (setq ansi-color-map (ansi-color-make-color-map))
#+end_src

*** Keybindings
#+begin_src emacs-lisp
  ;;;; keybindings
  ;; (define-key term-raw-map (kbd "<f4>") 'shell-pop)
  (define-key term-raw-map (kbd "M-x") 'execute-extended-command)
  (define-key term-raw-map (kbd "C-g") 'term-interrupt-subjob)
  (define-key term-raw-map (kbd "C-n") 'term-send-down)
  (define-key term-raw-map (kbd "C-p") 'term-send-up)
  (define-key term-raw-map (kbd "<enter>") 'term-send-input)
  (define-key term-raw-map (kbd "C-o") 'coldnew/execute-in-command-mode)
#+end_src

** comint
#+begin_src emacs-lisp
  (require 'comint)
  ;; Do not show password in comint-mode
  (setq comint-output-filter-functions  '(comint-watch-for-password-prompt))
  (setq comint-password-prompt-regexp
        "\\(\\([Oo]ld \\|]e]eew \\|^\\)[Pp]assword\\|Enter password\\):\\s *\\'")

  ;;;; Keybindings
  (define-key comint-mode-map (kbd "C-g") 'comint-interrupt-subjob)
#+end_src
** undo-tree
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'undo-tree)
#+end_src
*** Enable undo-tree globally
#+begin_src emacs-lisp
  (global-undo-tree-mode)
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (define-key undo-tree-visualizer-map (kbd "C-g") 'undo-tree-visualizer-quit)
#+end_src
** hungry-delete
#+begin_src emacs-lisp
  (require 'hungry-delete)
  (add-hook 'coldnew-editor-hook 'turn-on-hungry-delete-mode)
#+end_src
** cua                                                                 :cua:
#+begin_src emacs-lisp
  (require 'cua-base)
  (require 'cua-rect)
  ;; don't add C-x, C-c, C-v
  (setq cua-enable-cua-keys nil)
  (setq cua-rectangle-mark-key (kbd "C-c RET"))
  ;; Enable cua-mode
  (cua-mode t)

  (cua--init-rectangles)
  (cua--rect-M/H-key ?n   'cua-scroll-up)
  (cua--rect-M/H-key ?N   'cua-sequence-rectangle)
  (cua--rect-M/H-key ?p   'cua-scroll-down)
#+end_src
** paredit
#+begin_src emacs-lisp
  (require 'paredit)

  (defun paredit-blink-paren-match (another-line-p)
    "redefine this function, i don't like paredit to blikn math paren")

  (defadvice paredit-backward-delete (around paredit-backward-delete activate)
    "Intergrated paredit-backward-delete with hungry-delete."
    ad-do-it
    (when (featurep 'hungry-delete)
      (if (eq (char-before) ?\s)
          (hungry-delete-backward))))

  (defadvice paredit-forward-delete (around paredit-forward-delete activate)
    "Intergrated paredit-forward-delete with hungry-delete."
    ad-do-it
    (when (featurep 'hungry-delete)
      (if (eolp)
          (hungry-delete-forward))))
#+end_src
** projectile
#+begin_src emacs-lisp
  (require 'projectile)
  (projectile-global-mode)
  (setq projectile-enable-caching t)
#+end_src
** hideshow
#+begin_src emacs-lisp
  (require 'hideshow)
  (require* 'hideshowvis)

  ;;; enable following mode to use hideshow
  (dolist (hook (list 'emacs-lisp-mode-hook
                      'c++-mode-hook
                      'c-mode-hook))
    (add-hook hook 'hideshowvis-enable))
#+end_src
** slime
#+begin_src emacs-lisp
  (require 'slime)
  (require 'ac-slime)
  ;; Save REPL history to emacs-cache-dir
  (setq slime-repl-history-file (concat emacs-cache-dir "slime-hist.dat"))

  ;; REPL history size set to 300
  (setq slime-repl-history-size 300)

  ;; Use global programming mode
  (add-hook 'slime-repl-mode-hook 'programming-mode)
  (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
#+end_src
** ielm-mode
#+begin_src emacs-lisp
  (defun ielm-auto-complete ()
    "Enables `auto-complete' support in \\[ielm]."
    (setq ac-sources '(ac-source-functions
                       ac-source-variables
                       ac-source-features
                       ac-source-symbols
                       ac-source-words-in-same-mode-buffers))
    (add-to-list 'ac-modes 'inferior-emacs-lisp-mode)
    (auto-complete-mode 1))
  (add-hook 'ielm-mode-hook 'ielm-auto-complete)
#+end_src
** compilation
#+begin_src emacs-lisp
  ;; FIXME: move to other place
  (defun notify-compilation-result(buffer msg)
    "Notify that the compilation is finished,
     close the *compilation* buffer if the compilation is successful,
     and set the focus back to Emacs frame"
    (if (string-match "^finished" msg)
        (progn
          (delete-windows-on buffer)
          (message (propertize "COMPILATION SUCCESSFUL :-) " 'face 'font-lock-warning-face))
          ;;       (tooltip-show "\n Compilation Successful :-) \n ")
          )
      (tooltip-show "\n Compilation Failed :-( \n "))
    ;; FIXME: When I use dualscreen, following functiokn will make error,
    ;;        after compilation, current frame will jump to another DISPLAY
    ;;  (setq current-frame (car (car (cdr (current-frame-configuration)))))
    ;; (select-frame-set-input-focus current-frame)
    )

  (add-to-list 'compilation-finish-functions 'notify-compilation-result)
  ;; Make compilaction buffer always scrolls to follow output as it comes in.
  (setq compilation-scroll-output t)

  ;; Auto jump to the first error.
  (setq compilation-auto-jump-to-first-error t)
#+end_src
** cmake
*** Depends
#+begin_src emacs-lisp
  (require* 'cmake-mode)
#+end_src
*** Mode List
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.cmake\\'" . cmake-mode))
  (add-to-list 'auto-mode-alist '("CMakeLists\\.txt\\'" . cmake-mode))
#+end_src

** Easy PG                                                          :easypg:
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'epa-file)
#+end_src
*** Config
#+begin_src emacs-lisp
  ;; use local gpg program instaed of system one
  ;; only work under linux
  (cond
   ;; (linux-32bit-p (setq epg-gpg-program (concat emacs-bin-dir "gpg-x86")))
   (linux-64bit-p (setq epg-gpg-program (concat emacs-bin-dir "gpg")))
   )

  (setenv "GPG_AGENT_INFO" nil)

  (epa-file-enable)

  ;; Control whether or not to pop up the key selection dialog.
  (setq epa-file-select-keys 0)

  ;; Cache passphrase for symmetric encryption.
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)

#+end_src
* 文檔幫助
這邊放置 manpage、womanpage、info 等幫助文檔模式的設定。
** WoMan                                                              :woman:
woman 是 emacs 下顯示 manpage 最好的方式。
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'woman)
#+end_src
*** WoMan 快取儲存位置設定
#+begin_src emacs-lisp
  (setq woman-cache-filename (concat emacs-cache-dir "woman.cache"))
#+end_src
*** 對 woMan 緩衝區上色
#+begin_src emacs-lisp
  (setq woman-fontify t)
#+end_src
*** TODO 其他
#+begin_src emacs-lisp
  (setq woman-use-topic-at-point nil)
  ;; Colorful fonts
  (setq woman-fill-column 100)
#+end_src
* org-mode                                                              :org:
因為 org-mode 在這個設定檔裡佔有非常重要的比例，所以獨立出來。
** 載入相關套件
#+begin_src emacs-lisp
  (require 'org-install)
  (require 'org-table)
  (require 'ob-ditaa)
  (require 'org-latex)
#+end_src

google-weather 是提供　 emacs 連接 google-weathre 的 API，
在 org 檔案裏面加入如下的code，則可以在 agenda view 裏面看到天氣資訊。
#+begin_example
  * Weather
  %%(org-google-weather "New York")
#+end_example

#+begin_src emacs-lisp
  (require 'google-weather)
  (require 'org-google-weather)
#+end_src
** 設定 org-mode 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.org_archive$" . org-mode))
#+end_src
** Config
#+begin_src emacs-lisp
  (setq org-directory "~/Dropbox/Org/")
  (setq org-agenda-files (list "~/Dropbox/Org/"))
  (setq org-log-done t)
  (setq org-pretty-entities t)
  (setq org-use-speed-commands t)

  (setq org-tag-alist '(
                        (:startgroup . nil) ("Business" . ?b) ("School" . ?s) ("Weintek" . ?w) ("Personal" . ?p) (:endgroup . nil)
                        ))
  (setq org-confirm-babel-evaluate nil)
#+end_src
** 預設讓 org-mode 使用自動縮排模式
#+begin_src emacs-lisp
  (setq org-startup-indented t)
#+end_src
** 打開新的 org-mode 時，預設將所有項目都隱藏
只保留最上層的父目錄
#+begin_src emacs-lisp
  (setq org-startup-folded t)
#+end_src
** 將前面的 *星號* 隱藏，只顯示最後一個
#+begin_src emacs-lisp
  (setq org-hide-leading-stars t)
#+end_src
** 切換成程式碼欄位時使用目前的視窗
#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src
** 直接在程式碼欄位上為程式碼上色
#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src
** 讓 org-mode 與 cua-mode 相容
#+begin_src emacs-lisp
  (setq org-CUA-compatible t)
#+end_src
** 增加模版
#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("E" "#+begin_src emacs-lisp\n?\n#+end_src"))
               (add-to-list 'org-structure-template-alist
               '("S" "#+begin_src sh\n?\n#+end_src"))
#+end_src

** Capture
#+begin_src emacs-lisp
  (setq org-default-notes-file (concat org-directory "TODO.org"))
  (setq org-capture-templates '(("t" "TODO" entry (file+headline "" "Tasks")
                                 "* TODO %?\n %i\n %a")
                                ("f" "FIXME" entry (file+headline "" "Tasks")
                                 "* FIXME %?\n %i\n %a")
                                ("w" "Weintek" entry (file+headline "" "Weintek")
                                 "* TODO %?\n %i\n %a")
                                ))

#+end_src

*** Keybinding
#+begin_src emacs-lisp :tangle no
  (add-hook 'org-capture-mode-hook
            '(lambda ()
               (define-key coldnew/command-mode-map "c" 'org-capture-finalize)
               ))

#+end_src
** Agenda
設定 Agenda 顯示在目前的 window 上。
#+begin_src emacs-lisp
  (setq org-agenda-window-setup 'current-window)
#+end_src
*** Hooks
啟用 hl-line
#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook
            '(lambda ()
               (local-set-key (kbd "C-g") 'org-agenda-exit)))
#+end_src
** 讓 org-mode 裡面可以加密文章                                      :crypt:
用於加密 org-mode 裡面具有 :encrypt: 這個 TAG 的區塊。
注意到這需啟用 [[*Easy%20PG][Easy PG]] 才能夠使用。
*** 載入相關模組
#+begin_src emacs-lisp
  (require 'org-crypt)
#+end_src
*** 設定要加密的 tag 標籤為 *encrypt*
#+begin_src emacs-lisp
  (setq org-crypt-tag-matcher "encrypt")
#+end_src
*** Add a hook to automatically encrypt entries before a file is saved to disk.
#+begin_src emacs-lisp
  (org-crypt-use-before-save-magic)
#+end_src
*** 避免 encrypt 這個 tag 被子項目繼承
#+begin_src emacs-lisp
  (setq org-tags-exclude-from-inheritance (quote ("encrypt")))
#+end_src
*** 設定 org-crypt-disable-auto-save 成 encrypt 模式。
此模式並不會停用 auto-save-mode，反之，當自動儲存時，解密過的區域將會加密回去。
#+begin_src emacs-lisp
  (setq org-crypt-disable-auto-save 'encrypt)
#+end_src
** 在 org-mode 裡面顯示圖片
*** 增加 org-mode 圖片的正規表達式到 iimage-mode 裡面
#+begin_src emacs-lisp
  (require 'iimage)
  (add-to-list 'iimage-mode-image-regex-alist
               (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex "\\)\\]\\]")  1))
#+end_src
*** 打開 iimage-mode 並取消 org-link 的顏色
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (turn-on-iimage-mode)
               (set-face-underline-p 'org-link nil)))
#+end_src
*** 切換顯示圖片的命令
#+begin_src emacs-lisp
  (defun org-display-image ()
    "Toggle display images in org file."
    (interactive)
    (if (face-underline-p 'org-link)
        (set-face-underline-p 'org-link nil)
      (set-face-underline-p 'org-link t))
    (call-interactively 'iimage-mode))
#+end_src
** Keybinding
*** org-mode
設定自定義的按鍵。
#+begin_src emacs-lisp
    (add-hook 'org-mode-hook
              '(lambda ()
                 (define-key org-mode-map (kbd "C-c C-p") 'org-backward-same-level)
                 (define-key org-mode-map (kbd "C-c C-n") 'org-forward-same-level)
                 (define-key org-mode-map (kbd "C-c C-b") 'coldnew/org-up-parent)
                 (define-key org-mode-map (kbd "C-c C-f") 'coldnew/org-down-children)
                 (define-key org-mode-map (kbd "C-c i") 'org-display-image)
                 ;;(define-key coldnew/command-mode-map "c" 'org-edit-special)
                 ))

  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-\'") nil)
               (define-key org-mode-map (kbd "C-,") nil)
               (define-key org-mode-map (kbd "C-c C-e") nil)
               ))
#+end_src


#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-c b") 'org-metaleft)
               (define-key org-mode-map (kbd "C-c f") 'org-metaright)
               (define-key org-mode-map (kbd "C-c p") 'org-metaup)
               (define-key org-mode-map (kbd "C-c n") 'org-metadown)))
#+end_src
*** org-src-mode
#+begin_src emacs-lisp
  (add-hook 'org-src-mode-hook
            '(lambda ()
               ;;(local-set-key (kbd "C-c C-c") 'org-edit-src-exit)
               ;;(define-key coldnew/command-mode-map "c" 'org-edit-src-exit)
               ))
#+end_src
** Hooks
*** TODO Disable linum
#+begin_src emacs-lisp
;;  (add-to-list 'org-mode-hook '(lambda () (linum-mode -1)))
#+end_src
** Conflict Fix
some packages conflict with org-mode
*** yasnippet
#+begin_src emacs-lisp
  ;; (when (featurep 'yasnippet)
  ;;   (add-hook 'org-mode-hook
  ;;             (lambda ()
  ;;               (org-set-local 'yas/trigger-key[tab])
  ;;               (define-key yas/keymap[tab] 'yas/next-field-group)
                
  ;;               )))
  (when (featurep 'yasnippet)
    (defun yas/org-very-safe-expand ()
      (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))
  
    (add-hook 'org-mode-hook
              (lambda ()
                (make-variable-buffer-local 'yas/trigger-key)
                (setq yas/trigger-key [tab])
                (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                (define-key yas/keymap [tab] 'yas/next-field)))
    )
  
#+end_src

*** windmove
#+begin_src emacs-lisp
  ;; Make windmove work in org-mode:
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src
** Commands
*** org-archive-done-tasks
將標記為 *DONE* 的結點收錄到 archive 裡。
#+begin_src emacs-lisp
  (defun org-archive-done-tasks ()
    "Make all DONE subtree to archive."
    (interactive)
    (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+end_src
*** coldnew/org-up-parent
跑到目前節點的父節點，並收起目前的結點。
#+begin_src emacs-lisp
  (defun coldnew/org-up-parent ()
    "Move to the parent of current point. If current is the parent heading,
            move to the previous parent heading."
    (interactive)
    (if (not (org-on-heading-p))
        (outline-back-to-heading)
      (let* ((level (funcall outline-level))
             (point-to-move-to
              (save-excursion
                (outline-previous-visible-heading 1)
                (while (>= (funcall outline-level) level)
                  (outline-previous-visible-heading 1))
                (point))))
        (if point-to-move-to
            (goto-char point-to-move-to))))
    (org-cycle))
#+end_src
*** coldnew/org-down-children
跑到目前節點的子節點，並展開子節點。
#+begin_src emacs-lisp
  (defun coldnew/org-down-children ()
    "Move to children of current heading. If current heading only has subtree,
          expand the subtree."
    (interactive)
    (outline-back-to-heading)
    (show-children)
    (let* ((level (funcall outline-level))
           (point-to-move-to
            (save-excursion
              (outline-next-visible-heading 1)
              (if (<= (funcall outline-level) level)
                  nil
                        (point)))))
              (if point-to-move-to
                  (goto-char point-to-move-to)
                (show-subtree))))
#+end_src
** COMMENT remember the milk ?
:PROPERTIES:
:tangle: no
:END:
#+begin_src emacs-lisp
  (require org-feed)
  (setq org-feed-alist
        '(("Remember The Milk"
           "https://www.rememberthemilk.com/rss/jonnay/"
           "~/org/GTD.org"
           "Remember The Milk"
           :template "* TODO %title\n  %a\n "
           )))

  ;;* rtm feed timer
  (run-at-time 3600 3600 'org-feed-update-all)
#+end_src
** presentation
#+begin_src emacs-lisp
    ;; allow for export=>beamer by placing

  ;; #+LaTeX_CLASS: beamer in org files
  (unless (boundp 'org-export-latex-classes)
      (setq org-export-latex-classes nil))
    (add-to-list 'org-export-latex-classes
                 ;; beamer class, for presentations
                 '("beamer"
                   "\\documentclass[11pt]{beamer}\n
          \\mode<{{{beamermode}}}>\n
          \\usetheme{{{{beamertheme}}}}\n
          \\usecolortheme{{{{beamercolortheme}}}}\n
          \\beamertemplateballitem\n
          \\setbeameroption{show notes}
          \\usepackage[utf8]{inputenc}\n
          \\usepackage[T1]{fontenc}\n
          \\usepackage{hyperref}\n
          \\usepackage{color}\n
          \\usepackage{listings}\n
          \\usepackage{xeCJK}\n
          \\setCJKmainfont{LiHei Pro}\n
          \\XeTeXlinebreaklocale \"zh\"\n
          \\XeTeXlinebreakskip = 0pt plus 1pt
          \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
      frame=single,
      basicstyle=\\small,
      showspaces=false,showstringspaces=false,
      showtabs=false,
      keywordstyle=\\color{blue}\\bfseries,
      commentstyle=\\color{red},
      }\n
          \\usepackage{verbatim}\n
          \\institute{{{{beamerinstitute}}}}\n
           \\subject{{{{beamersubject}}}}\n"

                   ("\\section{%s}" . "\\section*{%s}")

                   ("\\begin{frame}[fragile]\\frametitle{%s}"
                    "\\end{frame}"
                    "\\begin{frame}[fragile]\\frametitle{%s}"
                    "\\end{frame}")))

    ;; letter class, for formal letters

    (add-to-list 'org-export-latex-classes

                 '("letter"
                   "\\documentclass[11pt]{letter}\n
          \\usepackage[utf8]{inputenc}\n
          \\usepackage[T1]{fontenc}\n
          \\usepackage{color}"

                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src
** Babel 支援的語言
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (ditaa . t)
     (dot . t)
     (js . t)
     (latex . t)
     (perl . t)
     (python . t)
     (ruby . t)
     (sh . t)
     ))
#+end_src
** 輸出成 PDF 檔案設定
*** 使用 minted 將程式碼加上色彩
#+begin_src emacs-lisp
  (require 'org-latex)
  (add-to-list 'org-export-latex-packages-alist '("" "minted"))
  (setq org-export-latex-listings 'minted)
  (setq org-export-latex-minted-options
        '(("frame" "lines")
          ("fontsize" "\\scriptsize")))
#+end_src

*** 使用 xelatex 產生 PDF 檔案
當系統有安裝 latexmk 時，使用 latexmk 呼叫 xelatex 進行編譯，
反之則直接呼叫 xelatex 進行二次編譯。
#+begin_src emacs-lisp
  (setq org-latex-to-pdf-process
        (if (executable-find "latexmk")
            '("latexmk -pdflatex=xelatex -pdf -silent --shell-escape -f %f")
          '("xelatex -interaction nonstopmode --shell-escape %f"
            "xelatex -interaction nonstopmode --shell-escape %f")))
#+end_src

*** 一般文章所使用的 latex 配置
#+begin_src emacs-lisp
  (add-to-list 'org-export-latex-classes
               '("coldnew-article"
                 "\\documentclass[12pt,a4paper]{article}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{fontspec}
                  \\usepackage{xeCJK}
                  \\setCJKmainfont{Hiragino Sans GB W3}
                  \\XeTeXlinebreaklocale \"zh\"
                  \\XeTeXlinebreakskip = 0pt plus 1pt
                  \\usepackage{graphicx}
                  \\usepackage{tikz}
                  \\usepackage[bookmarks=true,colorlinks,linkcolor=black]{hyperref}
                  \\defaultfontfeatures{Mapping=tex-text}
                  \\setmonofont[Scale=0.8]{DejaVu Sans Mono}
                  \\usepackage{geometry}
                  \\geometry{a4paper, textwidth=6.5in, textheight=8in,
                              marginparsep=10pt, marginparwidth=.6in}
                  \\pagestyle{plain}
                  \\linespread{1.5}
                  \\title{}
                        [NO-DEFAULT-PACKAGES]
                        [NO-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))

#+end_src

*** 投影片所使用的 latex 配置
#+begin_src emacs-lisp
  (add-to-list 'org-export-latex-classes
               ;; beamer class, for presentations
               '("beamer"
                 "\\documentclass[11pt]{beamer}
                  \\mode<{{{beamermode}}}>
                  \\usetheme{{{{beamertheme}}}}
                  \\usecolortheme{{{{beamercolortheme}}}}
                  \\beamertemplateballitem
                  \\setbeameroption{show notes}
                  \\usepackage[utf8]{inputenc}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{xeCJK}
                  \\setCJKmainfont{Hiragino Sans GB W3}
                  \\XeTeXlinebreaklocale \"zh\"
                  \\XeTeXlinebreakskip = 0pt plus 1pt
                  \\usepackage{minted}
                  \\usemintedstyle{emacs}
                  \\setmainfont{Monaco}
                  \\usepackage{hyperref}
                  \\usepackage{color}
                  \\usepackage{verbatim}
                  \\usepackage{upquote}
                  \\institute{{{{beamerinstitute}}}}
                  \\subject{{{{beamersubject}}}}"

                 ("\\section{%s}" . "\\section*{%s}")

                 ("\\begin{frame}[fragile]\\frametitle{%s}"
                  "\\end{frame}"
                  "\\begin{frame}[fragile]\\frametitle{%s}"
                  "\\end{frame}")))
#+end_src

*** TODO 投影片所使用的 html5 配置
* Editor
try to define my editor-mode , some function  or macros copy from evil :)
** electric-pair-mode
#+begin_src emacs-lisp
  (electric-pair-mode 1)
  ;; setting for auto-close brackets for electric-pair-mode regardless of current major mode syntax table
  (setq electric-pair-pairs '(
                              (?\" . ?\")
                              (?\{ . ?\})
                              ) )
#+end_src
** 替中文字和英文字中間加入空格
mixen 是我自己設計的 minor-mode，能夠自動替中文與英文字元間加入空格。
#+begin_src emacs-lisp
;;  (require* 'mixen)
;;  (setq mixen-enable-write-to-file t)
;;  (mixen-mode)
#+end_src
** 在文章中顯示圖片
#+begin_src emacs-lisp
  (iimage-mode)
#+end_src
** Mode
#+begin_src emacs-lisp :tangle no
    (define-minor-mode coldnew-editor-local-mode
      "Minor mode for setting up coldnew-editor in a single bufer."
      :init-value nil
      (cond
       (load-in-progress)                   ; don't enable coldnew-editor in loading buffers
       (coldnew-editor-local-mode
        ;; restore the proper value of `major-mode' in Fundamental buffers
        (when (eq major-mode 'turn-on-coldnew-editor-mode)
          (setq major-mode 'fundamental-mode))

        ;; determine and enable the initial state
        ;; (unless coldnew-editor-state
        ;;   (coldnew-editor-initialize-state)
        ;;   ;; re-determine the initial state in `post-command-hook' since
        ;;   ;; the major mode may not have been initialized yet
        ;;   (add-hook 'post-command-hook #'coldnew-editor-initialize-state t t))
        ;; TODO:remove
        (run-hooks 'coldnew-editor-hook)
        )
       (t
        ;; refresh mode-line
        )))

  (defun turn-on-coldnew-editor-mode (&optional arg)
    "Turn on coldnew-editor in the current buffer."
    (interactive)
    (coldnew-editor-local-mode (or arg 1)))

  (defun turn-off-coldnew-editor-mode (&optional arg)
    "Turn off coldnew-editor in the current buffer."
    (interactive)
    (coldnew-editor-local-mode (or arg -1)))

  (defun coldnew-editor-initialize ()
    "Enable coldnew-editor in the current buffer, if appropriate.
    To enable coldnew-editor globally, do `(coldnew-editor-mode 1)'."
    (unless (minibufferp)
      (coldnew-editor-local-mode 1)))

    ;;;### autoload
  (define-global-minor-mode coldnew-editor-mode
    coldnew-editor-local-mode coldnew-editor-initialize)

#+end_src

** Variables
#+begin_src emacs-lisp
  (defvar coldnew-global-keymaps-alist nil
    "Association list of keymap variables.
  Entries have the form (MODE . KEYMAP), where KEYMAP
  is the variable containing the keymap for MODE.")

  (defvar coldnew-local-keymaps-alist nil
    "Association list of keymap variables that must be
  reinitialized in each buffer. Entries have the form
  \(MODE . KEYMAP), where KEYMAP is the variable containing
  the keymap for MODE.")
#+end_src
** Macro
#+begin_src emacs-lisp :tangle no
  (defmacro coldnew/define-local-var (symbol &optional value doc &rest body)
    "Define SYMBOL as perment buffer local variable, and return SYMBOL.
  The parameters are the same as for `defvar', but the variable
  SYMBOL is made `permanent' buffer local."
    (declare (indent defun)
             (debug (symbolp &optional form stringp[&rest[keywordp sexp]]def-body))
             )
    (let (key arg)
      (if (keywordp (car-safe body))
          (setq key (pop body)
                arg (pop body)))
      `(progn
         (defvar ,symbol ,value ,doc)
         (make-variable-buffer-local ',symbol)
         ;; collect keywords
         (if (eq key :permanent)
             (put ',symbol 'permanent-local arg)))))

  (coldnew/define-local-var aa "sd" :permanent nil)
#+end_src
#+begin_src emacs-lisp
  (defmacro coldnew/define-state (state doc &rest body)
    "Define an coldnew-editor mode MODE.
  DOC is a general description and shows up in all docstrings;
  the first line of the string should be the full name of the state.
  Then follows one or more optional keywords:

  :tag STRING             Mode line indicator.
  :message STRING         Echo area message when changing to STATE.
  :cursor SPEC            Cursor to use in STATE.
  :entry-hook LIST        Hooks run when changing to STATE.
  :exit-hook LIST         Hooks run when changing from STATE.
  :suppress-keymap FLAG   If FLAG is non-nil, disabling bindings to
                          `self-insert-command'."
    (declare (indent defun)
             (debug (&define name
                             [&optional stringp]
                             [&rest[keywordp sexp]]
                             def-body)))
    (let* (
           (name (intern (format "%s" state)))
           (doc (if (or (null doc) (string= doc "")) ""
                  (format "\n%s" doc)))
           (toggle (intern (format "coldnew-%s" state)))
           (major-mode (intern (format "%s-modes" toggle)))
           (minor-mode (intern (format "%s-minor-mode" toggle)))
           (keymap (intern (format "%s-map" toggle)))
           (local (intern (format "%s-local-minor-mode" toggle)))
           (local-keymap (intern (format "%s-local-map" toggle)))
           (tag (intern (format "%s-tag" toggle)))
           (message (intern (format "%s-message" toggle)))
           (cursor (intern (format "%s-cursor" toggle)))
           (entry-hook (intern (format "%s-entry-hook" toggle)))
           (exit-hook (intern (format "%s-exit-hook" toggle)))
           (predicate (intern (format "%s-p" toggle)))
           arg cursor-value enable entry-hook-value exit-hook-value
           input-method key message-value suppress-keymap tag-value)
      ;; collect keywords
      (while (keywordp (car-safe body))
        (setq key (pop body)
              arg (pop body))
        (cond
         ((eq key :tag)
          (setq tag-value arg))
         ((eq key :message)
          (setq message-value arg))
         ((eq key :cursor)
          (setq cursor-value arg))
         ((eq key :entry-hook)
          (setq entry-hook-value arg)
          (unless (listp entry-hook-value)
            (setq entry-hook-value (list entry-hook-value))))
         ((eq key :exit-hook)
          (setq exit-hook-value arg)
          (unless (listp exit-hook-value)
            (setq exit-hook-value (list entry-hook-value))))
         ;; ((eq key :enable)
         ;;  (setq enable arg))
         ((eq key :input-method)
          (setq input-method arg))
         ((eq key :suppress-keymap)
          (setq suppress-keymap arg))))
      ;; macro expansion
      `(progn
         (defvar ,minor-mode nil
           ,(format "Non-nil if %s is enabled.
                              Use the command `%s' to change this variable." name toggle))
         (defvar ,major-mode nil
           ,(format "Modes that should come up in %s." name))
         ;; (defun ,predicate (&optional state)
         ;;        ,(format "Whether the current `coldnew-editor' state is `%s'.)" name)
         ;;        )
         )
      ))

#+end_src
** COMMENT Function
#+begin_src emacs-lisp :tangle no
  (defmacro coldnew-define-local-var (symbol &optional initvalue docstring)
    "Define SYMBOL as permanent buffer local variable, and return SYMBOL.
  The parameters are the same as for `defvar', but the variable
  SYMBOL is made permanent buffer local."
    (declare (indent defun)
             (debug (symbolp &optional form stringp)))
    `(progn
       (defvar ,symbol ,initvalue ,docstring)
       (make-variable-buffer-local ',symbol)
       (put ',symbol 'permanent-local t)))

  (coldnew-define-local-var coldnew-editor-state nil
                            "The current coldnew-editor-state.
  To change the state, use `coldnew-change-state'
  or call the state function (e.g., `coldnew-editor-state').")

  (coldnew-define-local-var coldnew-editor-previous-state nil
                            "The coldnew-editor-state being switched from.")

  (coldnew-define-local-var coldnew-mode-line-tag nil
                            "Mode-Line indicator for the current state.")
  (put 'coldnew-mode-line-tag 'risky-local-variable t)

  (defun coldnew-add-to-alist (list-var key val &rest elements)
    "Add the assocation of KEY and VAL to the value of LIST-VAR.
  If the list already contains an entry for KEY, update that entry;
  otherwise add at the end of the list."
    (let ((tail (symbol-value list-var)))
      (while (and tail (not (equal (car-safe (car-safe tail)) key)))
        (setq tail (cdr tail)))
      (if tail
          (setcar tail (cons key val))
        (set list-var (append (symbol-value list-var)
                              (list (cons key val)))))
      (if elements
          (apply #'coldnew-add-to-alist list-var elements)
        (symbol-value list-var))))



  (defmacro coldnew/define-keymap (keymap doc &rest body)
    "Define a keymap KEYMAP listed in `coldnew-mode-map-alist'.
  That means it will have precedence over regular keymaps.

  DOC is the documentation for the variable. BODY, if specified,
  is executed after toggling the mode. Optional keyword arguments
  may be specified before the body code:

  :mode VAR       Mode variable. If unspecified, the variable
                  is based on the keymap name.
  :local BOOLEAN  Whether the keymap should be buffer-local, that is,
                  reinitialized for each buffer.
  :func BOOLEAN   Create a toggle function even if BODY is empty.

  \(fn KEYMAP DOC[[KEY VAL]...]BODY...)"
    (declare (indent defun)
             (debug (&define name
                             [&optional stringp]
                             [&rest[keywordp sexp]]
                             def-body)))
    (let ((func t)
          arg intercept key local mode overriding)
      (while (keywordp (car-safe body))
        (setq key (pop body)
              arg (pop body))
        (cond
         ((eq key :mode)
          (setq mode arg))
         ((eq key :local)
          (setq local arg))
         ((eq key :func)
          (setq func arg))
         ((eq key :intercept)
          (setq intercept arg))
         ((eq key :overriding)
          (setq overriding arg))))
      (setq mode (or mode
                     (intern (replace-regexp-in-string
                              "\\(?:-\\(?:mode-\\)?\\(?:key\\)?map\\)?$"
                              "-mode"
                              (symbol-name keymap)))))
      `(progn
         (defvar ,keymap ,(unless local '(make-sparse-keymap)))
         (unless (get ',keymap 'variable-documentation)
           (put ',keymap 'variable-documentation ,doc))
         (defvar ,mode nil)
         (unless (get ',mode 'variable-documentation)
           (put ',mode 'variable-documentation ,doc))
         (make-variable-buffer-local ',mode)
         (put ',mode 'permanent-local t)
         (when ,intercept
           (evil-make-intercept-map ,keymap))
         (when ,overriding
           (evil-make-overriding-map ,keymap))
         ,@(if local
               `((make-variable-buffer-local ',keymap)
                 (put ',keymap 'permanent-local t)
                 (coldnew-add-to-alist 'coldnew-local-keymaps-alist
                                       ',mode ',keymap))
             `((coldnew-add-to-alist 'coldnew-global-keymaps-alist
                                     ',mode ',keymap)))
         ,(when (or body func)
            `(defun ,mode (&optional arg)
               ,@(when doc `(,doc))
               (interactive)
               (cond
                ((numberp arg)
                 (setq ,mode (> arg 0)))
                (t
                 (setq ,mode (not ,mode))))
               ,@body))
         ',keymap)))

  (coldnew/define-state test
    "doc"
    :tag "e"
    )



#+end_src
#+begin_src emacs-lisp :tangle no
    ;;;; lisp common setting
  (defun coldnew-lisp-common-setting ()
    "coldnew's common setting for lisp-like mode"
    ;; Use coldnew's editor mode
    (coldnew-editor-mode)
    ;; Use Greek character lambda insteda of string
    (turn-on-pretty-lambda-mode)
    (require 'rainbow-delimiters)
;;    (rainbow-delimiters-mode)
    )


  ;;;; cc-mode common setting
  (defun coldnew-cc-mode-common-setting ()
    "coldnew's common setting for cc-mode"
    ;; Use coldnew's editor mode
    (coldnew-editor-mode)
    ;; enable doxygen
    ;;  (doxymacs-mode t)
    ;;  (doxymacs-font-lock)

    ;; hide-if-def mode
    (hide-ifdef-mode)
    ;; use shadow
    (setq hide-ifdef-shadow t)

    ;; gtags
    ;;  (gtags-mode t)
    ;;  (if-not (string-match "/usr/src/linux/" (expand-file-name default-directory))
    ;;        (gtags-create-or-update))

    ;; keybindings
    (local-set-key (kbd "C-x C-o") 'ff-find-other-file)
    (local-set-key (kbd "C-x C-o") 'ff-find-other-file)
    (local-set-key (kbd "<f9>") 'smarter-compile)
    )

#+end_src
This section contains my editor state
#+begin_src emacs-lisp :tangle no
  (defvar coldnew-editor-hook nil
    "Hooks for coldnew-editor-mode.")

  (defvar coldnew-editor-state "Emacs"
    "default editor mode is Emacs-mode")

  (defvar coldnew-editor-map
    (let ((map (make-sparse-keymap)))
      map)
    "Keymap for coldnew-editor-mode.")

  (define-minor-mode coldnew-editor-mode
    "Minor mode for coldnew's editor."
    :init-value t
    :lighter " coldnew-editor"
    :keymap coldnew-editor-map
    (run-hooks 'coldnew-editor-hook))

  (defun coldnew/disable-mode-according-state ()
    (cond
     ((string= "View"  coldnew-editor-state) (view-mode -1))
     ((string= "Command"  coldnew-editor-state) (coldnew/command-mode -1))
     ))

  (defun coldnew/switch-to-emacs-mode ()
    (interactive)
    ;; disable other state according mode
    (coldnew/disable-mode-according-state)
    (setq coldnew-editor-state "Emacs"))

  (defun coldnew/switch-to-command-mode ()
    (interactive)
    ;; disable other state according mode
    (coldnew/disable-mode-according-state)
    (setq coldnew-editor-state "Command")
    (coldnew/command-mode 1))

  (defvar coldnew/command-mode-map
    (let ((map (make-sparse-keymap)))
      (suppress-keymap map)
      ;; simulate vim keys
      (define-key map "i" 'coldnew/switch-to-emacs-mode)
      (define-key map "%" 'match-paren)
      (define-key map "." 'repeat)
      (define-key map "*" 'vjo-forward-current-word-keep-offset)
      (define-key map "#" 'vjo-backward-current-word-keep-offset)
      ;; my keymap
      (define-key map "C" 'capitalize-word-backward)
      (define-key map "c" 'capitalize-word-backward)
      (define-key map "L" 'downcase-word-backward)
      (define-key map "U" 'upcase-word-backward)
      (define-key map "Z" 'zap-up-to-char-backward)
      (define-key map "e" 'ecb-toggle-ecb-windows)
      ;; (define-key map "a" 'backward-sentence)
      ;; (define-key map "e" 'forward-sentence)
      (define-key map "g" 'linum-ace-jump)
      (define-key map "o" 'org-ido-switchb)
      (define-key map "q" 'quoted-insert)
      (define-key map "r" 'org-capture)
      (define-key map "w" 'kill-region)
      ;; (define-key map "n" 'windmove-down)
      ;; (define-key map "p" 'windmove-up)
      ;; (define-key map "f" 'windmove-right)
      ;; (define-key map "b" 'windmove-left)
      (define-key map "b" 'ido-switch-buffer)
      (define-key map "\C-m" 'bm-toggle)
      (define-key map "\C-n" 'bm-next)
      (define-key map "\C-p" 'bm-previous)
      (define-key map "x" 'helm-M-x)
      (define-key map "y" 'yank)
      (define-key map "z" 'zap-up-to-char)
      ;; FIXME: I think this must change to vc-next-action
      (define-key map "v" 'egg-next-action)
      (define-key map "h" 'coldnew/helm-filelist)
      (define-key map (kbd "<SPC>") 'ace-jump-mode)
      (define-key map (kbd "(")  '(lambda () (interactive) (delete-between-pair ?\()))
      (define-key map (kbd "\"") '(lambda () (interactive) (delete-between-pair ?\")))
      (define-key map (kbd "[")  '(lambda () (interactive) (delete-between-pair ?\[)))
      (define-key map (kbd "{")  '(lambda () (interactive) (delete-between-pair ?\{)))
      (define-key map (kbd "\'") '(lambda () (interactive) (delete-between-pair ?\')))
      ;; elscreen
      ;; TODO: move to coldnew-elscreen
      (define-key map "t0" 'elscreen-jump-0)
      (define-key map "t9" 'elscreen-jump-9)
      (define-key map "tc" 'elscreen-create)
      (define-key map "td" 'elscreen-kill)
      (define-key map "tn" 'elscreen-next)
      (define-key map "tp" 'elscreen-previous)
      map)
    "Keymap for coldnew-editor-Mode.")

  (define-minor-mode coldnew/command-mode
    "Minor mode like vi's normal mode"
    :init-value nil
    :global t
    :lighter " "
    :keymap coldnew/command-mode-map
    (if coldnew/command-mode
        (progn
          ;; use key-chord
          (setq input-method-function 'key-chord-input-method))
      (progn
        ;; disable keychord
        (setq input-method-function nil))))

  (add-hook 'post-command-hook 'coldnew/set-mode-according-state)

  (defun coldnew/toggle-state ()
    (interactive)
    (cond
     ((string= "Command" coldnew-editor-state) (coldnew/switch-to-emacs-mode))
     ((string= "Emacs"   coldnew-editor-state) (coldnew/switch-to-command-mode)) )
    )

  (defvar coldnew/buffer-state-alist
    '((eshell-mode . "Emacs")
      (term-mode   . "Emacs")
      (ibuffer-mode . "Emacs")
      ))

  (defun coldnew/set-mode-according-state ()
    (let* ((mode major-mode)
           (state (cdr-safe (assoc mode coldnew/buffer-state-alist))))
      (if (minibufferp) (setq state "Emacs"))
      (cond
       ((string= "Command" state) (coldnew/switch-to-command-mode))
       ((string= "Emacs"   state) (coldnew/switch-to-emacs-mode)) )
      ))

  ;; FIXME: change to my own code one day
  (defun coldnew/evil-delay (condition form hook &optional append local name)
    "Execute FORM when CONDITION becomes true, checking with HOOK.
  NAME specifies the name of the entry added to HOOK. If APPEND is
  non-nil, the entry is appended to the hook. If LOCAL is non-nil,
  the buffer-local value of HOOK is modified."
    (if (and (not (booleanp condition)) (eval condition))
        (eval form)
      (let* ((name (or name (format "evil-delay-form-in-%s" hook)))
             (fun (make-symbol name))
             (condition (or condition t)))
        (fset fun `(lambda (&rest args)
                     (when ,condition
                       (remove-hook ',hook #',fun ',local)
                       ,form)))
        (put fun 'permanent-local-hook t)
        (add-hook hook fun append local))))

  (defun coldnew/execute-in-command-mode ()
    "Execute the next command in Command mode."
    (interactive)
    (coldnew/evil-delay '(not (eq this-command #'coldnew/execute-in-command-mode))
                        `(progn (coldnew/switch-to-emacs-mode))
                        'post-command-hook)
    (coldnew/switch-to-command-mode)
    )

  (global-set-key (kbd "C-o") 'coldnew/execute-in-command-mode)
  (global-set-key (kbd "C-j") 'linum-ace-jump)

#+end_src
#+begin_src emacs-lisp
  ;;;; ---------------------------------------------------------------------------
  ;;;; Initial Editor Setting
  ;;;; ---------------------------------------------------------------------------
  (setq indent-tabs-mode nil )          ; don't use tabs to indent
  (setq tab-width          8 )          ; default tab-width is 8
  (setq line-spacing       4 )          ; Additional space between lines
  (setq fill-column      100 ) ; column beyond which automatic line-wrapping shold happen
  (setq kill-ring-max    300 ) ; Maximum lenght of kill-ring
  (setq require-final-newline  t ) ; Auto add a newline at the end of line
  (setq next-line-add-newlines t ) ;
  (setq shift-select-mode      t ) ; Enable shift-select mode

  ;; Enable global font-lock
  (global-font-lock-mode t)
  ;; Revert buffers automatically when underlying files are changed externally
  (global-auto-revert-mode t)
  ;; Show matching parentheses all the time
  (show-paren-mode t)
  ;; Enable auto-complete-mode
  (global-auto-complete-mode t)
  ;; Enable delete-selection-mode
  (delete-selection-mode t)
#+end_src

** hooks
#+begin_src emacs-lisp :tangle no
       ;; After save buffer, indent whole file.
;;       (add-hook 'coldnew-editor-hook 'indent-file-after-save)
       ;; Before save buffer, cleanup whitespace
       (add-hook 'coldnew-editor-hook 'cleanup-whitespace-before-save)
       ;; Enable line-number
       (require 'linum)
      ;; (add-hook 'coldnew-editor-hook 'linum-mode)
       ;; use electric-indent-mode
       (add-hook 'coldnew-editor-hook 'electric-indent-mode)
       ;; highlight special keywords like TODO, BUF
       (add-hook 'coldnew-editor-hook 'highlight-additional-keywords)
     ;; highlight fontify numbers and constant
  ;;    (add-hook 'coldnew-editor-hook 'highlight-fontify-numbers)
      ;; highlight escape char in string
      (add-hook 'coldnew-editor-hook 'highlight-escape-char)
    ;;   ;; Add spaces between Chinese and English character.
     ;; (add-hook 'before-save-hook 'insert-space-between-english-chinese)
#+end_src
** TODO conflict
#+begin_src emacs-lisp
  ;;   ;; Color nested parentheses, brackets, and braces according to their dept
  ;;   (require 'rainbow-delimiters)
  ;;   (add-hook 'coldnew-editor-hook 'rainbow-delimiters-mode)
#+end_src
** Functions
#+begin_src emacs-lisp
  (defun indent-file-after-save ()
    "Indent whole file after saved."
    (make-local-variable 'after-save-hook)
    (add-hook 'after-save-hook
              '(lambda ()
                 (indent-region (point-min) (point-max) nil)
                 (save-buffer))))

  (defun cleanup-whitespace-before-save ()
    "Cleanup whitespaces before save to a file."
    (make-local-variable 'before-save-hook)
    (add-hook 'before-save-hook
              '(lambda ()
                 (whitespace-cleanup)
                 (delete-trailing-whitespace))))

  (defun highlight-additional-keywords ()
    "Highlight additional keywords."
    (font-lock-add-keywords nil '(("\\<\\(FIXME\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)))
    (font-lock-add-keywords nil '(("\\<\\(NOTE\\):" 1 'org-level-2 t)))
    (font-lock-add-keywords nil '(("\\<\\(TODO\\):" 1 'org-todo t)))
    (font-lock-add-keywords nil '(("\\<\\(DONE\\):" 1 'org-done t)))
    )

  (defun highlight-fontify-numbers ()
    "Use this function as a hook to fontify numbers as constant"
    (font-lock-add-keywords nil
                            '(
                              ;; hexadecimal
                              ("\\b\\(0[00-9a-fA-F]+\\)" 1 font-lock-constant-face)
                              ;; float
                              ("\\b\\([+-]?[0-9]+\\.[0-9]+\\)" 1 font-lock-constant-face)
                              ;; int
                              ("[\`^(\{\[,\+\-\*/\%=\s-]\\(-?[0-9]+U?L?L?\\)" 1 font-lock-constant-face)
                              )))

  (defun highlight-escape-char ()
    "Use this function as a hook to fontify escape char."
    (font-lock-add-keywords nil
                            '(
                              ("\\\\\\(?:[abfnrtv'\"?\\0]\\|x[a-fA-F]\\{2\\}\\|[0-7]\\{3\\}\\)"
                               0 'font-lock-escape-char-face prepend)
                              )))

  (defun insert-space-between-english-chinese ()
    "Insert a space between English words and Chinese charactors"
    (save-excursion
      (goto-char (point-min))
      (while (or (re-search-forward "\\(\\cc\\)\\([a-zA-Z0-9]\\)" nil t)
                 (re-search-forward "\\([a-zA-Z0-9]\\)\\(\\cc\\)" nil t))
        (replace-match "\\1 \\2" nil nil))
      (goto-char (point-min))
      (while (or (re-search-forward "\\([。，！？；：「」（）、]\\) \\([a-zA-Z0-9]\\)" nil t)
                 (re-search-forward "\\([a-zA-Z0-9]\\) \\([。，！？；：「」（）、]\\)" nil t))
        (replace-match "\\1\\2" nil nil))))
#+end_src

* Cedet                                                                :cede:
#+begin_src emacs-lisp
  (require 'semantic)

  ;; Enable Semantic features
  (semantic-mode 1)

  ;; Maintain tag database
  (global-semanticdb-minor-mode 1)
  ;; Reparse buffer when idle
  (global-semantic-idle-scheduler-mode 1)
  ;; Show completions when idle
  (global-semantic-idle-completions-mode 1)
  ;; Provide `switch-to-buffer'-like keybinding for tag names.
  (global-semantic-mru-bookmark-mode 1)
  ;; Show summary of tag at point
  (global-semantic-idle-summary-mode 1)
  ;;;; Disable
  ;; Highlight the current tag.
  (global-semantic-highlight-func-mode -1)
  ;; Show current fun in header line
  (global-semantic-stickyfunc-mode -1)
  ;; Additional tag decorations
  (global-semantic-decoration-mode -1)

  ;;;; Enable support for GNU Global
  (semanticdb-enable-gnu-global-databases 'c-mode)
  (semanticdb-enable-gnu-global-databases 'c++-mode)

  (setq semanticdb-default-save-directory (concat emacs-cache-dir "semanticdb"))
  (set-default 'semantic-case-fold t)

#+end_src
* ECB                                                                   :ecb:
** Depends
#+begin_src emacs-lisp
  (require* 'ecb)
#+end_src
** Config
*** Do not show tips-of-the-day
不要顯示　 tips-of-the-day，感覺很煩人
#+begin_src emacs-lisp
  (setq ecb-tip-of-the-day nil)
#+end_src
*** Do not check ecb options for compatibility across versions
不要自動檢查版本是否相容，很煩人...
#+begin_src emacs-lisp
  (setq ecb-auto-compatibility-check nil)
#+end_src
** Advice
** Commands
#+begin_src emacs-lisp
  (defun ccc-toggle-ecb-mode ()
    "Toggle ecb-minor-mode and resize window accordingly"
    (interactive)
    (if ecb-minor-mode
        (progn
          (let ((w (frame-width ecb-frame)))
            (message "%i" w)
            )
          (ecb-minor-mode)
          )
      (progn
        (message "%s" "turning on, make frame wider")
        (ecb-minor-mode)
        )
      ))
#+end_src
* 書籤
** Bookmark 說明
:PROPERTIES:
:tangle:   no
:END:

*** 預設按鍵
| 快捷鍵  | 命令                | 用途                                        |
|---------+---------------------+---------------------------------------------|
| C-x r m | bookmark-set        | 設置新的書籤                                |
| C-x r l | bookmark-bmenu-list | 列出所有已設置的書籤                        |
| C-x r b | bookmarj-jump       | 跳轉到書籤                                  |
|         | bookmark-delete     | 刪除書籤                                    |
|         | bookmark-load       | 讀取已儲存的書籤檔案                        |
|         | bookmark-save       | 儲存書籤至 bookmark-default-file 指定的地方 |

** Config
#+begin_src emacs-lisp
  (setq bookmark-default-file emacs-bookmark-file)
#+end_src

#+begin_src emacs-lisp
  (require* 'bm)
#+end_src
* Cscope                                                             :cscope:
** cscope 說明
:PROPERTIES:
:tangle:   no
:END:

*** 安裝 cscope
**** Debian / Ubuntu
#+begin_src sh
  sudo apt-get install cscope
#+end_src
**** Gentoo
#+begin_src sh
  sudo emerge cscope
#+end_src
*** 使用 xcscope
emacs 和 cscope 相關的套件蠻多的，xcscope 包含在 cscope 的套件裡。
將 xcscope.el 加入你的　 load-path 並載入他。
#+begin_src emacs-lisp
  (require 'xcscope)
#+end_src
*** 預設按鍵
所有的預設按鍵都是以 Ctrl-c s 作為 prefix

| 快捷鍵  | elisp function                              | 用途                                     |
|---------+---------------------------------------------+------------------------------------------|
| C-c s s | cscope-find-this-symbol                     | Find symbol                              |
| C-c s d | cscope-find-global-definition               | Find global definition                   |
| C-c s g | cscope-find-global-definition               | Find global definition                   |
| C-c s G | cscope-find-global-definition-no-prompting  | Find global definition without prompting |
| C-c s c | cscope-find-functions-calling-this-function | Find finctions calling a function        |
| C-c s C | cscope-find-called-functions                | Find caled functions                     |
|         |                                             | (list functions called from a function)  |
| C-c s t | cscope-find-this-text-string                | Find text string                         |
| C-c s e | cscope-find-egrep-pattern                   | Find egrep pattern                       |
| C-c s f | cscope-find-this-file                       | Find a file                              |
| C-c s i | cscope-find-files-including-file            | Find files #including a file             |

*** 搜索時切換用的快捷鍵
| 快捷鍵  | elisp function               | 用途                                  |
|---------+------------------------------+---------------------------------------|
| C-c s b | cscope-display-buffer        | Display **cscope** buffer             |
| C-c s B | cosope-display-buffer-toggle | Auto display **cscope** buffer toggle |
| C-c s n | cscope-next-symbol           | Next symbol                           |
| C-c s N | cscope-next-file             | Next file                             |
| C-c s p | cscope-prev-symbol           | Previous symbol                       |
| C-c s P | cscope-prev-file             | Previous file                         |
| C-c s u | cscope-pop-mark              | Pop mark                              |

** 載入和 cscope 相關的 package
#+begin_src emacs-lisp
  (require* 'xcscope)
  (require* 'xcscope+)
  (setq cscope-do-not-update-database t)
#+end_src
* Auto Compression Mode
#+begin_src emacs-lisp
  (auto-compression-mode 1)
#+end_src
* 程式開發                                                         :language:
各種不同程式語言開發用的設定。
** Bash
*** 設定 Bash 語言 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.sh" . sh-mode))
  (add-to-list 'auto-mode-alist '("\\.bash" . sh-mode))
#+end_src
*** Auto complete
#+begin_src emacs-lisp
  ;; auto-complete
  (add-hook 'shell-mode-hook 'ac-shell-script-mode-setup)
  ;; define ac-source for pcomplete
  (ac-define-source pcomplete
    '((candidates . pcomplete-completions)
      (cache)
      (symbol . "f")))

  (defun ac-shell-script-mode-setup ()
    "auto-complete settings for shell-script-mode"
    (setq ac-sources
          '(ac-source-pcomplete
            ac-source-dictionary
            ac-source-filename
            ac-source-files-in-current-dir
            ac-source-words-in-same-mode-buffers
            )))
#+end_src
#+begin_src emacs-lisp
    ;;;; ---------------------------------------------------------------------------
    ;;;; Hooks
    ;;;; ---------------------------------------------------------------------------

  ;; use my editor-mode
  (add-hook 'shell-mode-hook '(lambda() (coldnew-editor-mode 1)))


  ;; bash-completion
;;  (require 'bash-completion)
;;  (bash-completion-setup)

  ;; use flymake-shell
  (require* 'flymake-shell)
  (add-hook 'shell-mode-hook 'flymake-shell-load)

#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (add-hook 'sh-mode-hook
            '(lambda ()
               (local-set-key (kbd "}") 'self-insert-command)
               (local-set-key (kbd "]") 'self-insert-command)
               (local-set-key (kbd ")") 'self-insert-command)
               ))
#+end_src
** C
*** 設定 C 語言 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.c$" . c-mode))
  (add-to-list 'auto-mode-alist '("\\.h$" . c-mode))
#+end_src
*** 預設使用 Linux Coding Style
#+begin_src emacs-lisp
  (add-hook 'c-mode-hook
            '(lambda ()
               (c-set-style "linux")))
#+end_src
*** Hooks
**** prefix
**** c-eldoc
adeff
#+begin_src emacs-lisp
    (add-hook 'c-mode-hook
            '(lambda ()
               (require 'c-eldoc)
               (setq c-eldoc-includes "`pkg-config gtk+-3.0 opencv --cflags --libs` -I./ -I../")
               (c-turn-on-eldoc-mode)))
#+end_src
#+begin_src emacs-lisp
  ;; use my cc-mode-common-setting
;;  (add-hook 'c-mode-hook 'coldnew-cc-mode-common-setting)

  ;; use ctypes
  (require 'ctypes)
  (setq-default ctypes-file-name (concat emacs-cache-dir "ctypes_std_c.dat"))
  (add-hook 'ctypes-load-hook 'my-ctypes-load-hook)

  ;; use hide-if-def-mode
  ;;(add-hook 'c-mode-hook 'hide-ifdef-mode)

  (require 'gccsense)

  ;;;; ---------------------------------------------------------------------------
  ;;;; Functions
  ;;;; ---------------------------------------------------------------------------
  (defun my-ctypes-load-hook ()
    (ctypes-read-file ctypes-file-name nil t t))


  ;;;; ---------------------------------------------------------------------------
  ;;;; Commands
  ;;;; ---------------------------------------------------------------------------

  (defun c-mode:insert-inc-or-if ()
    "If at the start of line. add `inc' and expand it,
  else add `if' and expand it."
    (interactive)
    (let* ((current (point))
           (begin (line-beginning-position)))
      (if (eq current begin)
          (progn
            (c-mode:insert-include)
            (newline-and-indent))
        (progn
          (insert "if")
          (yas/expand)))))
#+end_src
**** TODO 自動偵測 c-basic-offset
#+begin_src emacs-lisp
  (require* 'guess-offset)
#+end_src
**** 自動猜測縮排風格
#+begin_src emacs-lisp
  (when (require 'dtrt-indent nil 'noerror)
    (add-hook 'c-mode-hook
              (lambda () (dtrt-indent-mode t))))
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (define-key c-mode-map (kbd "C-x C-o") 'ff-find-other-file)
#+end_src
*** Cscope
C-c s s             序找符号
C-c s g             寻找全局的定义
C-c s c             看看指定函数被哪些函数所调用
C-c s C             看看指定函数调用了哪些函数
C-c s e             寻找正则表达式
C-c s f             寻找文件
C-c s i             看看指定的文件被哪些文件 include
C-c s a             设定初始化的目录，一般是你代码的根目录
C-s s I             对目录中的相关文件建立列表并进行索引
*** Functions
*** Commands
#+begin_src emacs-lisp
  (defun c-mode:insert-main-function ()
    "insert main()."
    (interactive)
    (let* ((current (point))
           (begin (line-beginning-position)))
      (if (equal current begin)
          (insert "main"))
      (yas/expand)))
#+end_src
** C++
*** 設定 C++ 語言 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.hpp$" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.cpp$" . c++-mode))
  (add-to-list 'magic-mode-alist
               `(,(lambda ()
                    (and (string= (file-name-extension buffer-file-name) "h")
                         (re-search-forward "\\W\\(class\\|template\\namespace\\)\\W"
                                            magic-mode-regexp-match-limit t)))
                 . c++-mode))
#+end_src
*** Config
**** Codinf Style
#+begin_src emacs-lisp
    ;;;; CodingStyle
  (add-hook 'c++-mode-hook
            '(lambda ()

               ;; TODO: add comment here
               (setq c-macro-shrink-window-flag t)
               (setq c-macro-preprocessor "cpp")
               (setq c-macro-cppflags " ")
               (setq c-macro-prompt-flag t)

               ;; Use linux-kernel style
               (c-set-style "linux")

               ;; Setting indentation lvel
               (setq c-basic-offset 4)

               ;; Make TAB equivilent to 4 spaces
               (setq tab-width 4)

               ;; Use spaces to indent instead of tabs.
               (setq indent-tabs-mode nil)

               ;; Indent the continuation by 2
               (setq c-continued-statement-offset 2)

               ;; Brackets should be at same indentation level as the statements they open
               ;; for example:
               ;;                 if (0)        becomes        if (0)
               ;;                     {                        {
               ;;                        ;                         ;
               ;;                     }                        }
               (c-set-offset 'substatement-open '0)
               ;; make open-braces after a case
               (c-set-offset 'case-label '+)

               ))

#+end_src
#+begin_src emacs-lisp
  ;; use my cc-mode-common-setting
  ;;(add-hook 'c++-mode-hook 'coldnew-cc-mode-common-setting)

  ;;;; Auto Complete
  ;;;; ---------------------------------------------------------------------------

    ;; Default clang completion flags
    ;;    (setq clang-completion-flags
    (setq ac-clang-flags
          (split-string
           (concat
            "-pthread -I./ -I../ "
            (shell-command-to-string "pkg-config --cflags-only-I opencv gtk+-3.0"))))
#+end_src

*** Hooks
**** c-eldoc
#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook
            '(lambda ()
               ;; Enable c-eldoc
               (require 'c-eldoc)
               (setq c-eldoc-includes "`pkg-config gtk+-3.0 opencv --cflags --libs` -I./ -I../")
               (c-turn-on-eldoc-mode)))
#+end_src
**** 自動猜測縮排風格
#+begin_src emacs-lisp
  (when (require 'dtrt-indent nil 'noerror)
    (add-hook 'c++-mode-hook
              (lambda () (dtrt-indent-mode t))))
#+end_src
*** 自動補全設定
**** 載入其餘需要使用的套件。
#+begin_src emacs-lisp
  (require 'auto-complete-clang)
#+end_src
**** 設定用來補全的資訊。
#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook 'ac-cpp-mode-setup)
  (defun ac-cpp-mode-setup ()
    "auto-complete settings for c-mode."
    (setq ac-sources '(
                       ac-source-clang
                       ac-source-dictionary
                       ac-source-abbrev
                       ac-source-semantic
                       ac-source-filename
                       ac-source-files-in-current-dir
                       ac-source-words-in-same-mode-buffers
                       )))
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (define-key c++-mode-map (kbd "C-x C-o") 'ff-find-other-file)
#+end_src
C-c  s             序找符号
C-c  g             寻找全局的定义
C-c  c             看看指定函数被哪些函数所调用
C-c  C             看看指定函数调用了哪些函数
C-c  e             寻找正则表达式
C-c  f             寻找文件
C-c  i             看看指定的文件被哪些文件 include
C-c  a             设定初始化的目录，一般是你代码的根目录
C-c  I             对目录中的相关文件建立列表并进行索引
#+begin_src emacs-lisp
  (define-key c++-mode-map (kbd "C-c s") 'cscope-find-this-symbol)
  (define-key c++-mode-map (kbd "C-c g") 'cscope-find-global-definition)
  (define-key c++-mode-map (kbd "C-c I") 'cscope-create-list-of-files-to-index)
 ;; remember to remove
  (define-key c++-mode-map (kbd "C-c f") 'cscope-find-this-file)
#+end_src
** Common Lisp
*** 設定 Common Lisp 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.cl$" . lisp-mode))
#+end_src
** Clojure
*** 載入相關套件
#+begin_src emacs-lisp
  (require 'clojure-mode)
#+end_src
*** 設定 Clojure 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))
#+end_src
*** 啟用 rainbow-delimiters
#+begin_src emacs-lisp
  (add-hook 'clojure-mode-hook
            '(lambda ()
               (when (require rainbow-delimiters)
                 (rainbow-delimiters-mode-enable))))
#+end_src
** Clojure Script
** Emacs Lisp
*** 設定 emacs-lisp 的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.el$" . emacs-lisp-mode))
#+end_src
*** Hooks
**** eldoc
eldoc 能夠將目前所使用的 elisp function 所需要的 argument 顯示在 minibuffer 上。
#+begin_src emacs-lisp
  (require 'eldoc)
  (require 'eldoc-extension)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
#+end_src

讓 pairedit 相容於 eldoc。
#+begin_src emacs-lisp
  (when (featurep 'paredit)
    (eldoc-add-command 'paredit-backward-delete 'paredit-close-round))
#+end_src

**** highlight-cl
高亮屬於 cl.el 套件的 function 或是 macro。
#+begin_src emacs-lisp
  (require 'highlight-cl)
  (add-hook 'emacs-lisp-mode-hook 'highlight-cl-add-font-lock-keywords)
#+end_src

**** auto-indent
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'auto-indent-minor-mode)
#+end_src
**** Other
#+begin_src emacs-lisp
;;  (add-hook 'emacs-lisp-mode-hook 'coldnew-lisp-common-setting)
#+end_src
*** 自動補全
#+begin_src emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'ac-emacs-lisp-mode-setup)
    (defun ac-emacs-lisp-mode-setup ()
        "auto-complete settings for emacs-lisp-mode"
        (setq ac-sources
              '(ac-source-symbols
                ac-source-variables
                ac-source-functions
                ac-source-features
                ac-source-filename
                ac-source-files-in-current-dir
                ac-source-words-in-same-mode-buffers
                )))
#+end_src
*** TODO Flymake
#+begin_src emacs-lisp :tangle no
  (require 'flymake)
  (defun flymake-elisp-init ()
    (unless (string-match "^ " (buffer-name))
      (let* ((temp-file   (flymake-init-create-temp-buffer-copy
                           'flymake-create-temp-inplace))
             (local-file  (file-relative-name
                           temp-file
                           (file-name-directory buffer-file-name))))
        (list
         (expand-file-name invocation-name invocation-directory)
         (list
          "-Q" "--batch" "--eval"
          (prin1-to-string
           (quote
            (dolist (file command-line-args-left)
              (with-temp-buffer
                (insert-file-contents file)
                (condition-case data
                    (scan-sexps (point-min) (point-max))
                  (scan-error
                   (goto-char(nth 2 data))
                   (princ (format "%s:%s: error: Unmatched bracket or quote\n"
                                  file (line-number-at-pos)))))))
            )
           )
          local-file)))))
  (push '("\\.el$" flymake-elisp-init) flymake-allowed-file-name-masks)
  (add-hook 'emacs-lisp-mode-hook
            ;; workaround for (eq buffer-file-name nil)
            '(lambda () (if buffer-file-name (flymake-mode t))))


#+end_src
*** Functions
#+begin_src emacs-lisp
    (defun remove-elc-when-visit ()
      "After visit elisp file, remove .elc extension file."
      (make-local-variable 'find-file-hook)
      (add-hook 'find-file-hook
                (lambda ()
                  (if (and (file-exists-p (concat buffer-file-name "c"))
                           (file-writable-p (concat buffer-file-name "c")))
                      (delete-file (concat buffer-file-name "c"))))))
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               (define-key emacs-lisp-mode-map (kbd "M-i r") '(lambda () (interactive) (insert "require") (yas/expand)))
               ))
#+end_src

#+begin_src emacs-lisp
  <<emacs-lisp-mode-hook-begin>>

  (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'backward-sexp)

  <<emacs-lisp-mode-hook-end>>
#+end_src

#+name: emacs-lisp-mode-hook-begin
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
#+end_src

#+name: emacs-lisp-mode-hook-end
#+begin_src emacs-lisp
))
#+end_src
** JavaScript
*** 設定 javascript 的副檔名與對應的模式
使用 js2-mode 替代原本系統內建的 js-mode。
#+begin_src emacs-lisp
  (require* 'js2-mode)
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src
*** 自動補全
#+begin_src emacs-lisp
  (add-hook 'js-mode-hook 'ac-javascript-mode-setup)
  (defun ac-javascript-mode-setup ()
    "auto-complete settings for javascript-mode"
    (setq ac-sources
          '(ac-source-dictionary
            ac-source-filename
            ac-source-files-in-current-dir
            ac-source-words-in-same-mode-buffers
            )))
#+end_src
*** REPL 設定
使用 js-comint 來設定 REPL 模式。
**** 設定起始位置
#+begin_src emacs-lisp
  (when (require 'js-comint nil 'noerror)
#+end_src
**** 設定 REPL 程式為 node.js
#+begin_src emacs-lisp
    (setq inferior-js-program-command "node")
#+end_src
**** 在 REPL 啟用 ANSI 色彩
#+begin_src emacs-lisp
;;  (add-hook 'js-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src
**** 設定終止位置
#+begin_src emacs-lisp
    )
#+end_src
** LaTex
** Scheme
*** 設定 Scheme 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.scm$" . scheme-mode))
#+end_src
** Perl
*** 設定 Perl 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pl" . perl-mode))
#+end_src
** Python
*** 設定 Python 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.py" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))
#+end_src
*** pymacs
**** 設定檔起始
#+begin_src emacs-lisp
  (eval-after-load "python-mode"
    '(progn
#+end_src
**** require
#+begin_src emacs-lisp
  (require* 'pymacs)
#+end_src
**** TODO 讓 pymacs 找的到 rope 以及 ropemacs
我將 pymacs 必須使用的 rope、ropemacs、ropemode 安裝在 lisp 資料夾裏面，
必須設定 PATH 讓 pymacs 知道他們在哪。
#+begin_src emacs-lisp
;; no use?
;;  (setq pymacs-load-path '("~/.emacs.d/lisp/rope"
;;                          "~/.emacs.d/lisp/ropemacs"))
#+end_src
**** 設定 pymacs 使用的 python 版本
使用 python2.7
#+begin_src emacs-lisp
  (setenv "PYMACS_PYTHON" "python2.7")
#+end_src
**** 修改 ropemacs 預設的 keymap-prefix
#+begin_src emacs-lisp
  (setq ropemacs-enable-shortcuts nil)
  (setq ropemacs-local-prefix "C-c C-p")
  (setq ropemacs-global-prefix "C-c p")
#+end_src
**** 啟用 ropemacs
#+begin_src emacs-lisp
  (pymacs-load "ropemacs" "rope-")
#+end_src
**** 設定檔結速
#+begin_src emacs-lisp
  ))
#+end_src
*** 自動補全
#+begin_src emacs-lisp
(require* 'ac-python)
#+end_src
** Verilog
*** 設定 verilog 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.v$" . verilog-mode))
#+end_src
*** 自動添加 *end //blockname* 註解
#+begin_src emacs-lisp
  (setq verilog-auto-endcomments t)
#+end_src
*** 按鍵設定
#+begin_src emacs-lisp
    (add-hook 'verilog-mode-hook
              '(lambda ()
                 (define-key verilog-mode-map (kbd "C-;") 'iedit-mode)
                 (auto-complete-mode)
                 ))
#+end_src
* Mode Line                                                        :modeline:
** TODO 分類
#+begin_src emacs-lisp
  ;;;; ---------------------------------------------------------------------------
  ;;;; Initial modeline setting
  ;;;; ---------------------------------------------------------------------------
  (line-number-mode t)
  (column-number-mode t)
  (size-indication-mode t)

  ;;;; ---------------------------------------------------------------------------
  ;;;; Functions
  ;;;; ---------------------------------------------------------------------------
  (defun mode-line-major-mode ()
    "Get major-mode name with << >>."
    (concat "<< " (propertize mode-name 'face 'mode-line-mode-name-face) " >>"))
  (defun coldnew-editor-mode-string ()
    (let* ((mode-string-face
            (cond
             ((string= "Command" coldnew-editor-state) 'mode-line-evil-state-string-V)
             ((string= "View" coldnew-editor-state) 'mode-line-evil-state-string-N)
             (t 'mode-line-evil-state-string-E)
             )))
      (concat "<" (propertize coldnew-editor-state 'face mode-string-face) ">")))
  ;;;; ---------------------------------------------------------------------------
  ;;;; modeline User-Interfaced setting
  ;;;; ---------------------------------------------------------------------------
#+end_src
** 設定 mode-line 樣式
#+begin_src emacs-lisp
  (setq-default mode-line-format
                  '((" "
                     mode-line-mule-info
                     ;; read-only or modified status
                     (:eval
                      (cond (buffer-read-only
                             (propertize "RO" 'face 'mode-line-read-only-face))
                            ((buffer-modified-p)
                             (propertize "**" 'face 'mode-line-modified-face))
                            (t "--")))
                     "   "
                     (:eval (coldnew-editor-mode-string))
                     "   "
                     ;;              (:eval (mode-line-state))
                     mode-line-buffer-identification
                     "   "
                     ;; major-mode name
                     (:eval (mode-line-major-mode))
                     "   "
                     ;; line and column
                     "("
                     (:eval (propertize "%02l" 'face 'font-lock-type-face))
                     ","
                     (:eval (propertize "%02c" 'face 'font-lock-type-face))
                     ")"

                     "   "
                     (vc-mode vc-mode)
                     "   "
                     ;; relative position, size of file
                     "["
                     (:eval (propertize "%p" 'face 'font-lock-constant-face)) ;; % above top
                     "/"
                     (:eval (propertize "%I" 'face 'font-lock-constant-face)) ;; size
                     "] "
                     )))
#+end_src
* 互動式命令                                                        :command:
** Buffer
*** 跳轉到 **scratch**
跳轉目前 buffer 與 **scratch**，假如 **scratch** 不存在，
則建立一個 major-mode 為 lisp-interaction-mode 的 **scratch**
#+begin_src emacs-lisp
  (defun scratch-toggle ()
    "Toggle between *scratch* buffer and the current buffer.
     If the *scratch* buffer does not exist, create it."
    (interactive)
    (let ((scratch-buffer-name (get-buffer-create "*scratch*")))
      (if (equal (current-buffer) scratch-buffer-name)
          (switch-to-buffer (other-buffer))
        ;;        (previous-user-buffer)
        (progn
          (switch-to-buffer scratch-buffer-name)
          (unless (equal major-mode 'lisp-interaction-mode)
            (lisp-interaction-mode))))))
#+end_src
*** save-buffer-always
預設的 save-buffer 在 buffer 沒有變動時，不會進行儲存，
使用此命令可以使得在呼叫 save-buffer-always 時，將 buffer 變更為修改過，
並進行儲存。
#+begin_src emacs-lisp
  (defun save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))
#+end_src
*** revert-all-buffer
#+begin_src emacs-lisp
(defun revert-all-buffers ()
  "Revert all non-modified buffers associated with a file.
This is to update existing buffers after a Git pull of their underlying files."
  (interactive)
  (save-current-buffer
    (mapc (lambda (b)
            (set-buffer b)
            (unless (or (null (buffer-file-name)) (buffer-modified-p))
              (revert-buffer t t)
              (message "Reverted %s\n" (buffer-file-name))))
          (buffer-list))))
#+end_src
*** nuke-all-buffers
關閉除了 **scratch** 以外的所有 buffer。
#+begin_src emacs-lisp
  (defun nuke-all-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapcar (lambda (x) (kill-buffer x)) (buffer-list))
    (delete-other-windows))
#+end_src
** 其他、未歸類
*** 縮排整個 buffer
#+begin_src emacs-lisp
  (defun indent-whole-buffer ()
    "Indent whole buffer and delete trailing whitespace.
  This command will also do untabify."
    (interactive)
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max))
    (untabify (point-min) (point-max)))
#+end_src
*** 縮牌區域或是整個 buffer
#+begin_src emacs-lisp
  (defun indent-region-or-buffer ()
    "Indents a region if selected, otherwise the whole buffer."
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (delete-trailing-whitespace (region-beginning) (region-end))
            (indent-region (region-beginning) (region-end))
            (untabify (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-region-or-buffer)
          (message "Indented buffer.")))))
#+end_src
*** TODO rewrite
#+begin_src emacs-lisp
  (defun align-code (beg end &optional arg)
    (interactive "rP")
    (if (null arg)
        (align beg end)
      (let ((end-mark (copy-marker end)))
        (indent-region beg end-mark nil)
        (align beg end-mark))))
#+end_src
#+begin_src emacs-lisp
  (defun mark-line (&optional arg)
    (interactive "p")
    (beginning-of-line)
    (let ((here (point)))
      (dotimes (i arg)
        (end-of-line))
      (set-mark (point))
      (goto-char here)))
  (defun mark-sentence (&optional arg)
    (interactive "P")
    (backward-sentence)
    (mark-end-of-sentence arg))
(defun delete-indentation-forward ()
  (interactive)
  (delete-indentation t))
(defun delete-current-line (&optional arg)
  (interactive "p")
  (let ((here (point)))
    (beginning-of-line)
    (kill-line arg)
    (goto-char here)))
#+end_src
#+begin_src emacs-lisp
  (defun window-horizontal-to-vertical ()
    "Switches from a horizontal split to a vertical split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-horizontally)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))

  (defun window-vertical-to-horizontal ()
    "Switches from a vertical split to a horizontal split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-vertically)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))

  (defun my-column-ruler (width)
    "Display temp ruler at point."
    (interactive `(,(+ (window-hscroll)(window-width))))
    (momentary-string-display
     (let* ((iterations (/ (1- width) 10))
            (result1 "|...|....|")
            (result2 "1   5   10")
            (inc1 "....|....|")
            (inc2 "        %d0")
            (i 1))
       (while  (<= i iterations)
         (setq i (1+ i))
         (setq result1 (concat result1 inc1))
         (setq result2 (concat result2 (substring (format inc2 i) -10))))
       (concat (substring result2 0 width) "\n"
               (substring result1 0 width) "\n"))
     (line-beginning-position)
     nil "[space]Clears ruler"))

#+end_src

#+begin_src emacs-lisp
  (defun swap-with (dir)
    (interactive)
    (let ((other-window (windmove-find-other-window dir)))
      (when other-window
        (let* ((this-window (selected-window))
               (this-buffer (window-buffer this-window))
               (other-buffer (window-buffer other-window))
               (this-start (window-start this-window))
               (other-start (window-start other-window)))
          (set-window-buffer this-window other-buffer)
          (set-window-buffer other-window this-buffer)
          (set-window-start this-window other-start)
          (set-window-start other-window this-start)))))

  ;; (global-set-key (kbd "C-M-J") (lambda () (interactive) (swap-with 'down)))
  ;; (global-set-key (kbd "C-M-K") (lambda () (interactive) (swap-with 'up)))
  ;; (global-set-key (kbd "C-M-H") (lambda () (interactive) (swap-with 'left)))
  ;; (global-set-key (kbd "C-M-L") (lambda () (interactive) (swap-with 'right)))

  ;; (global-set-key (kbd "M-J") (lambda () (interactive) (enlarge-window 1)))
  ;; (global-set-key (kbd "M-K") (lambda () (interactive) (enlarge-window -1)))
  ;; (global-set-key (kbd "M-H") (lambda () (interactive) (enlarge-window -1 t)))
  ;; (global-set-key (kbd "M-L") (lambda () (interactive) (enlarge-window 1 t)))


  (defun select-forwards-to-before-match (match)
    "Selects forwards to just before next match, uses
  select-region-to-before-match"
    (interactive "MSelect forwards to just before: ")
    (select-region-to-before-match match 'forwards))

  (defun select-backwards-to-before-match (match)
    "Selects backwards to just before next match, uses
  select-region-to-before-match"
    (interactive "MSelect backwards to just before: ")
    (select-region-to-before-match match 'backwards))

  (defun kill-forwards-to-before-match (match)
    "Selects forwards to just before next match, uses
  select-region-to-before-match, then kills that region."
    (interactive "MKill forwards to just before: ")
    (let* ((positions (select-region-to-before-match match 'forwards))
           (start (car positions))
           (end (cadr positions)))
      (kill-region start end)))

  (defun kill-backwards-to-before-match (match)
    "Selects backwards to just before next match, uses
  select-region-to-before-match, then kills that region."
    (interactive "MKill backwards to just before: ")
    (let* ((positions (select-region-to-before-match match 'backwards))
           (start (car positions))
           (end (cadr positions)))
      (kill-region start end)))

  (defun match-paren (arg)
    "Go to the matching paren if on a paren; otherwise insert %."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
          (t (self-insert-command (or arg 1)))))



  (defun cua-set-mark-or-rectangle-mark (&optional arg)
    "toggle between cua-set-mark or cua-rectangle-mark"
    (interactive "P")
    (if (or (not mark-active) arg)
        (cua-set-mark arg)
      (cua-toggle-rectangle-mark)))


  (defadvice kill-ring-save (before slickcopy activate compile)
    "When called interactively with no active region, copy a single line
  instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slickcut activate compile)
    "When called interactively with no active region, kill a single line
  instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defun zap-up-to-char-backward (arg char)
    (interactive "p\ncZap up to char backward: ")
    (zap-up-to-char (- arg) char))

  (defun go-to-char (arg char)
    (interactive "p\ncGo to char: ")
    (forward-char 1)
    (if (if arg
            (search-forward (char-to-string char) nil nil arg)
          (search-forward (char-to-string char)))
        (backward-char 1)))

  (defun go-back-to-char (arg char)
    (interactive "p\ncGo back to char: ")
    (forward-char -1)
    (if arg
        (search-backward (char-to-string char) nil nil arg)
      (search-backward (char-to-string char))))

  (defun vjo-forward-current-word-keep-offset ()
    " (Vagn Johansen 1999)"
    (interactive)
    (let ((re-curword) (curword) (offset (point))
          (old-case-fold-search case-fold-search) )
      (setq curword (thing-at-point 'symbol))
      (setq re-curword (concat "\\<" (thing-at-point 'symbol) "\\>") )
      (beginning-of-thing 'symbol)
      (setq offset (- offset (point)))    ; offset from start of symbol/word
      (setq offset (- (length curword) offset)) ; offset from end
      (forward-char)
      (setq case-fold-search nil)
      (if (re-search-forward re-curword nil t)
          (backward-char offset)
        ;; else
        (progn (goto-char (point-min))
               (if (re-search-forward re-curword nil t)
                   (progn (message "Searching from top. %s" (what-line))
                          (backward-char offset))
                 ;; else
                 (message "Searching from top: Not found"))
               ))
      (setq case-fold-search old-case-fold-search)
      ))

  (defun vjo-backward-current-word-keep-offset ()
    " (Vagn Johansen 2002)"
    (interactive)
    (let ((re-curword) (curword) (offset (point))
          (old-case-fold-search case-fold-search) )
      (setq curword (thing-at-point 'symbol))
      (setq re-curword (concat "\\<" curword "\\>") )
      (beginning-of-thing 'symbol)
      (setq offset (- offset (point)))    ; offset from start of symbol/word
      (forward-char)
      (setq case-fold-search nil)
      (if (re-search-backward re-curword nil t)
          (forward-char offset)
        ;; else
        (progn (goto-char (point-max))
               (if (re-search-backward re-curword nil t)
                   (progn (message "Searching from bottom. %s" (what-line))
                          (forward-char offset))
                 ;; else
                 (message "Searching from bottom: Not found"))
               ))
      (setq case-fold-search old-case-fold-search)
      ))

  ;; ;; FIXME: need to test
  ;; (defun set-frame-size-according-to-resolution ()
  ;;   (interactive)
  ;;   (if window-system
  ;;       (progn
  ;;      (if (> (x-display-pixel-width) 1500) ;; 1500 is the delimiter marging in px to consider the screen big
  ;;          (set-frame-width (selected-frame) 237) ;; on the big screen make the fram 237 columns big
  ;;        (set-frame-width (selected-frame) 177)) ;; on the small screen we use 177 columns
  ;;      (setq my-height (/ (- (x-display-pixel-height) 150) ;; cut 150 px of the screen height and use the rest as height for the frame
  ;;                         (frame-char-height)))
  ;;      (set-frame-height (selected-frame) my-height)
  ;;      (set-frame-position (selected-frame) 3 90) ;; position the frame 3 pixels left and 90 px down
  ;;      )))

  ;; (set-frame-size-according-to-resolution)
  ;;  (global-set-key (kbd "C-x 9") 'set-frame-size-according-to-resolution)

  (defun open-in-largest-window()
    "Open current buffer in largest window"
    (interactive)
    (let ((oldbuf (current-buffer)))
      (select-window (get-largest-window))
      (switch-to-buffer oldbuf))
    )
  ;;(global-set-key (kbd "C-x 5") 'open-in-largest-window)

#+end_src
** 檔案處理
*** find-files
#+begin_src emacs-lisp
  (defun find-files (files)
    "Open the given files"
    (interactive)
    (foreach (f files) (find-file f)))
#+end_src
*** my-clone-and-open-file
#+begin_src emacs-lisp
  (defun my-clone-and-open-file (filename)
    "Clone the current buffer writing it into FILENAME and open it"
    (interactive "FClone to file: ")
    (save-restriction
      (widen)
      (write-region (point-min) (point-max) filename nil nil nil 'confirm))
    (find-file filename))
#+end_src
** 視窗
*** 將整個 emacs 全螢幕
#+begin_src emacs-lisp
  (defun fullscreen-window ()
    "Make the window full-screen."
    (interactive)
    (let ((current-value (frame-parameter nil 'fullscreen))
          (old-value nil))
      (set-frame-parameter nil 'fullscreen
                           (if (equal 'fullboth current-value)
                               'old-value
                             (progn
                               (setq old-value current-value)
                               'fullboth)))))
#+end_src
#+begin_src emacs-lisp
  (defun collapse-or-expand ()
    (interactive)
    (if (> (length (window-list)) 1)
        (delete-other-windows)
      (bury-buffer)))
#+end_src
#+begin_src emacs-lisp
  (defun gitg ()
    "Launch gitg in the current directory."
    (interactive)
    (start-process "gitg" nil "gitg"))


  (defun windmove-down-fullscreen ()
    "Select window below current one and make it fullscreen."
    (interactive)
    (if (windmove-down)
        (delete-other-windows)))

  (defun windmove-up-fullscreen ()
    "Select window above the current one and make it fullscreen."
    (interactive)
    (if (windmove-up)
        (delete-other-windows)))

  (defun windmove-left-fullscreen ()
    "Select window left to current one and make it fullscreen."
    (interactive)
    (if (windmove-left)
        (delete-other-windows)))

  (defun windmove-right-fullscreen ()
    "Select window right to current one and make it fullscreen."
    (interactive)
    (if (windmove-right)
        (delete-other-windows)))

  (defun sudo-edit (&optional arg)
    "Edit file with sudo in emacs"
    (interactive "p")
    (if (or arg (not buffer-file-name))
        ;; (find-file (concat "/sudo:root@localhost:" (anything-read-file-name "File: ")))
        (find-file (concat "/sudo:root@localhost:" (read-file-name "File: ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

(setq tramp-debug-buffer t)
(setq tramp-chunksize 500)


  (defun toggle-selective-display (column)
    (interactive "P")
    (set-selective-display
     (if selective-display nil (or column 1))))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Insert
  ;;; ---------------------------------------------------------------------------
  (require 'mm-url)

  (defun insert-tinyurl (url)
    "Insert a shortend URL at point by passed in URL"
    (interactive "sEnter url: " )
    (let* ((url (replace-regexp-in-string "^http://" "" url))
           (tinyurl
            (save-excursion
              (with-temp-buffer
                (mm-url-insert
                 (concat "http://tinyurl.com/api-create.php?url=http://" url))
                (kill-ring-save (point-min) (point-max))
                (buffer-string)))))
      (insert tinyurl)))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Search
  ;;;; ---------------------------------------------------------------------------
  (defun multi-occur-in-this-mode ()
    "Show all lines matching REGEXP in buffers with this major mode."
    (interactive)
    (multi-occur
     (get-buffers-matching-mode major-mode)
     (car (occur-read-primary-args)))
    (select-window (get-buffer-window "*Occur*")))

  ;;;; ---------------------------------------------------------------------------
  ;;;; key-macro
  ;;;; ---------------------------------------------------------------------------
  (defun toggle-kbd-macro-recording-on ()
    "One-key keyboard macros: turn recording on."
    (interactive)
    (define-key
      global-map
      (this-command-keys)
      'toggle-kbd-macro-recording-off)
    (start-kbd-macro nil))

  (defun toggle-kbd-macro-recording-off ()
    "One-key keyboard macros: turn recording off."
    (interactive)
    (define-key
      global-map
      (this-command-keys)
      'toggle-kbd-macro-recording-on)
    (end-kbd-macro))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Commands that define for key-chord
  ;;;; ---------------------------------------------------------------------------
  (defun upcase-word-backward ()
    "upcase word backward."
    (interactive)
    (upcase-word -1))

  (defun downcase-word-backward ()
    "downcase word backward."
    (interactive)
    (downcase-word -1))

  (defun capitalize-word-backward ()
    "captialize word backward."
    (interactive)
    (capitalize-word -1))

  (defun backward-kill-line (arg)
    "Kill chars backward until encountering the end of a line."
    (interactive "p")
    (kill-line 0))
#+end_src
** 插入
*** 插入時間
#+begin_src emacs-lisp
  (defun insert-date-time ()
    "Insert current-date."
    (interactive)
    (insert (current-date-time)))
#+end_src
*** 插入空白行
#+begin_src emacs-lisp
  (defun insert-empty-line ()
    "Insert an empty line after current line and position cursor on newline."
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line 1))
#+end_src
*** 多次貼上
emacs 本身的 yank 命令是無法使用 universla-argument 的，
也就是說無法使用 C-u 80 C-y 來貼上複製的東西 80 次，
而是貼上前幾次紀錄在 kill-ring 的資訊。

yank-n-times 則可以重複的進行貼上。

當沒有使用 universal-argument 指定要貼上多少次時，
會使用 prompt 詢問貼上的次數。
#+begin_src emacs-lisp
  (defun yank-n-times (&optional arg)
    "yank multiple times."
    (interactive "P")
    (let ((times (if (equal current-prefix-arg nil)
                     (read-number "yank repet times: ")
                   arg)))
      (if (< times 1)
          (setq times 1)
        (dotimes 'times (yank)))))
#+end_src
** 刪除
*** 刪除相對應的括號
#+begin_src emacs-lisp
  (defun delete-between-pair (char)
    "Delete in between the given pair"
    (interactive "cDelete between pair: ")
    (let ((pair-char))
      (search-backward-to-char char)
      (forward-char 1)
      (cond
       ((char-equal char ?\() (setq pair-char ?\)))
       ((char-equal char ?\") (setq pair-char ?\"))
       ((char-equal char ?\') (setq pair-char ?\'))
       ((char-equal char ?\[) (setq pair-char ?\]))
       ((char-equal char ?\{) (setq pair-char ?\}))
       ((char-equal char ?\<) (setq pair-char ?\>)))
      (zap-up-to-char 1 pair-char)))
#+end_src

*** 刪除一個 '字'
#+begin_src emacs-lisp
  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-region (point) (progn (forward-word arg) (point))))

#+end_src

*** 向左刪除一個 '字'
#+begin_src emacs-lisp
  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))
#+end_src
*** 刪除目前的檔案與 buffer
#+begin_src emacs-lisp
  (defun delete-file-and-buffer ()
    "Kills the current buffer and deletes the file it is visiting"
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
        (delete-file filename)
        (message "Deleted file %s" filename)))
    (kill-buffer))
#+end_src
** 轉換
*** 將 unix 格式的文件轉換成 dos 格式
#+begin_src emacs-lisp
  (defun unix2dos ()
    "Convert buffer file from unix file to dos file."
    (interactive)
    (unix->dos (current-buffer)))
#+end_src
*** 將 dos 格式的文件轉換成 unix 格式
#+begin_src emacs-lisp
  (defun dos2unix ()
    "Convert buffer file from dos file to unix file."
    (interactive)
    (dos->unix (current-buffer)))
#+end_src
*** 將 buffer 的編碼改成 utf8
#+begin_src emacs-lisp
  (defun encode-to-utf8 ()
    "Sets the buffer-file-coding-system to UTF8."
    (interactive)
    (set-buffer-file-coding-system 'utf-8 nil))
#+end_src
*** eval-and-replace
將前面的 sexp 刪除並進行 eval 的動作，如果 eval 失敗則還原前面的 sexp。
#+begin_src emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
#+end_src
*** expand-last-sexp
#+begin_src emacs-lisp
  (defun expand-last-sexp ()
    "Expand macro from sexp before point;print value in pp eval buffer"
    (interactive)
    (pp-eval-expression '(macroexpand (read (thing-at-point 'sexp)))))
#+end_src
* Google 翻譯
google-translate 套件提供 emacs 透過 google 的 API 進行翻譯的動作。
** 載入相關套件
#+begin_src emacs-lisp
  (require* 'google-translate)
#+end_src
** 預設設定為 正體中文 -> 英文
#+begin_src emacs-lisp
(setq google-translate-default-source-language "zh-TW")
(setq google-translate-default-target-language "en")
#+end_src
** 命令
#+begin_src emacs-lisp
  (defun google-translate-en-zh ()
    "Translate English to Tranditional Chinese by google-translate."
    (interactive)
    (let ((google-translate-default-source-language "en")
          (google-translate-default-target-language "zh-TW"))
      (google-translate-query-translate)))

  (defun google-translate-zh-en ()
    "Translate Tranditional Chinese to English by google-translate."
    (interactive)
    (let ((google-translate-default-source-language "zh-TW")
          (google-translate-default-target-language "en"))
      (google-translate-query-translate)))
#+end_src
* Tramp                                                               :tramp:
#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")
  (add-to-list 'tramp-default-method-alist
               '("\\`localhost\\'" "\\`root\\'" "su"))
#+end_src
** Remote sudo access with tramp
#+begin_src emacs-lisp
  (add-to-list 'tramp-default-proxies-alist
               '(nil "\\`root\\'" "/ssh:%h:"))
  (add-to-list 'tramp-default-proxies-alist
               '((regexp-quote (system-name)) nil nil))
#+end_src
* 聊天室                                                               :chat:
** IRC
emacs 底下最常用的 IRC 軟體為 ERC 和 RCIRC，以下是這兩種環境的設置。
*** ERC
**** 載入相依套件
#+begin_src emacs-lisp
  (require 'erc)
  (require 'erc-notify)
  (require 'erc-spelling)
  (require 'erc-autoaway)
#+end_src
**** 設定 prompt
#+begin_src emacs-lisp
  (setq erc-prompt ">>")
#+end_src
**** 編碼設定為 utf-8
#+begin_src emacs-lisp
  (setq erc-server-coding-system '(utf-8 . utf-8))
#+end_src
**** 當 ERC 啟動時，自動連入 IRC 伺服器
#+begin_src emacs-lisp
  (erc-autojoin-mode t)
#+end_src
**** 自動連線的伺服器與聊天室
#+begin_src emacs-lisp
  (setq erc-autojoin-channels-alist
        '(;; english channel
          (".*\\.freenode.net" "#emacs" "#lisp" "#clojure" "##linux" "#gentoo")
          ;; Chinese channel
          (".*\\.freenode.net" "#emacs.tw" "#tossug")
          (".*\\debian.org" "#dot")
          ))
#+end_src
**** 關閉部份訊息顯示
#+begin_src emacs-lisp
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src
**** 加入時間戳
#+begin_src emacs-lisp
  (erc-timestamp-mode 1)
#+end_src
**** 紀錄聊天訊息
***** 載入相依套件
#+begin_src emacs-lisp
  (require 'erc-log)
#+end_src
***** 啟動 erc-log-mode
#+begin_src emacs-lisp
  (erc-log-mode 1)
#+end_src
***** 設定紀錄檔儲存位置
#+begin_src emacs-lisp
  (setq erc-log-channels-directory emacs-log-dir)
#+end_src
***** 如果儲存紀錄檔的資料夾不存在，建立他
#+begin_src emacs-lisp
  (unless (file-exists-p erc-log-channels-directory)
    (mkdir erc-log-channels-directory t))
#+end_src
***** 紀錄檔編碼為 utf-8
#+begin_src emacs-lisp
  (setq erc-log-file-coding-system 'utf-8)
#+end_src
***** 送出訊息後寫入到 log
#+begin_src emacs-lisp
  (setq erc-log-write-after-send t)
#+end_src
***** 當有新訊息時，寫入到log
#+begin_src emacs-lisp
  (setq erc-log-write-after-insert t)
#+end_src
**** 設定聊天時的行寬為 100
#+begin_src emacs-lisp
  (setq erc-fill-column 100)
#+end_src
**** 為聊天室裡的使用者暱稱上色
#+begin_src emacs-lisp
  (and
   (require 'erc-highlight-nicknames)
   (add-to-list 'erc-modules 'highlight-nicknames)
   (erc-update-modules))
#+end_src
**** Configs
***** Misc
#+begin_src emacs-lisp
  ;; check channels
  ;; exclude boring stuff from tracking
  (erc-track-mode t)
  (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"

                                  "324" "329" "332" "333" "353" "477"))
  ;; Interpret mIRC-style color commands in IRC chats
  (setq erc-interpret-mirc-color t)
  ;; The following are commented out by default, but users of other
  ;; non-Emacs IRC clients might find them useful.
  ;; Kill buffers for channels after /part
  (setq erc-kill-buffer-on-part t)
  ;; Kill buffers for private queries after quitting the server
  (setq erc-kill-queries-on-quit t)
  ;; Kill buffers for server messages after quitting the server
  (setq erc-kill-server-buffer-on-quit t)
  ;; open query buffers in the current window
  (setq erc-query-display 'buffer)
  (setq erc-save-buffer-on-part t)
  (defadvice save-buffers-kill-emacs (before save-logs (arg) activate)
    (save-some-buffers t (lambda () (when (eq major-mode 'erc-mode) t))))
  ;; truncate long irc buffers
  (erc-truncate-mode +1)
  ;; enable spell checking
  (erc-spelling-mode 1)
  ;; autoaway setup
  (setq erc-auto-discard-away t)
  (setq erc-autoaway-idle-seconds 600)
  (setq erc-autoaway-use-emacs-idle t)
#+end_src
**** Commands
#+begin_src emacs-lisp
  (defun i-wanna-be-social ()
    "Connect to IM networks using bitlbee."
    (interactive)
    (erc :server "localhost" :port 6667 :nick "user"))
#+end_src
#+begin_src emacs-lisp
  (defun erc-cmd-WII (nick &rest ignore)
    "`/WHOIS' command with extra user information."
    (erc-send-command (mapconcat #'identity
                                 (list "WHOIS" nick nick) " ")))
  (defun erc-cmd-IDENTIFY (password &rest ignore)
    "Short-hand alias for `/msg NickServ identify PASS'."
    (erc-send-command (mapconcat #'identity
                                 (list "identify" password) " ")))
  (defun erc-cmd-CS (&rest args)
    "Short alias for `/chanserv ARGS'."
    (let ((command-args (append (list "CHANSERV") args)))
      (let ((chanserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command chanserv-command))))

  (defun erc-cmd-MS (&rest args)
    "Short alias for `/memoserv ARGS'."
    (let ((command-args (append (list "MEMOSERV") args)))
      (let ((memoserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command memoserv-command))))

  (defun erc-cmd-NS (&rest args)
    "Short alias for `/nickserv ARGS'."
    (let ((command-args (append (list "NICKSERV") args)))
      (let ((nickserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command nickserv-command))))
#+end_src
**** Function
#+begin_src emacs-lisp
(defun avoid-erc-oops (txt)
  (when (member txt '("ls" "xb" "cd"))
      (setq erc-send-this nil)))

(add-to-list 'erc-send-pre-hook 'avoid-erc-oops)
#+end_src
**** Command
#+begin_src emacs-lisp
  (defun irc ()
    (interactive)
    (erc :server "irc.freenode.net" :port 6667 :nick erc-nick)
    (erc :server "irc.debian.org" :port 6667 :nick erc-nick))
#+end_src
*** RCIRC
:PROPERTIES:
:tangle: no
:END:
這邊是以前所使用的 rcirc 設定，由於我改用 erc 作為我的 irc client，這邊的設定將不輸出至
我的 emacs 設定。
**** 載入相依套件
#+begin_src emacs-lisp
  (require 'rcirc)
#+end_src
**** Config
#+begin_src emacs-lisp
  ;; for debugging.
  (setq rcirc-debug-flag t)
  ;; Include date in time stamp.
  (setq rcirc-time-format "%Y-%m-%d %H:%M ")
  ;; Enable Logging rcirc
  (setq rcirc-log-flag t)
  ;; Put logs in this directory
  (setq rcirc-log-directory "~/.emacs.d/var/log/rcirc/")
  ;;
  (setq rcirc-notify-open t)
  ;;
  (setq rcirc-notify-timeout 1)
  ;;
  (setq rcirc-omit-responses '("JOIN" "PART" "QUIT" "NICK" "AWAY" "MODE"))
  ;; Prompt Settings
  (setq rcirc-prompt " %n  >> ")
  ;; Do not show on modline
  (setq rcirc-track-minor-mode nil)

  ;; Join these channels at startup.
  (setq rcirc-server-alist
        '(
          ("irc.freenode.net" :channels  ("#emacs" "#lisp" "##linux" "#gentoo"    ; english channel
                                          "#tossug" "#gentoo-tw" "#python.tw" "#ubuntu-tw"))
          ("irc.debian.org" :channels ("#dot"))
          ))
#+end_src
**** Hooks
#+begin_src emacs-lisp
  (add-hook 'rcirc-mode-hook
            '(lambda ()
               ;; Keep input line at bottom.
               (set (make-local-variable 'scroll-conservatively) 8192)
               ;; Use Omit-mode
               (rcirc-omit-mode)
               ))
#+end_src
**** Commands
#+begin_src emacs-lisp
  (defun-rcirc-command all (input)
    "Run the arguments as a command for all connections.
         Example use: /all away food or /all quit zzzz."
    (interactive "s")
    (let ((buffers (mapcar 'process-buffer (rcirc-process-list))))
      (dolist (buf buffers)
        (with-current-buffer buf
          (goto-char (point-max))
          (insert "/" input)
          (rcirc-send-input)))))

  (defun-rcirc-command calc (input)
    "calculate value of some expression using bc"
    (let ((expr (mapconcat 'identity args " ")))
      (when (length expr)
        (let ((result (shell-command-to-string (concat "echo '" expr "' | bc ")))
              (when result (rcirc-send-message (concat expr " = " result))))))))
#+end_src
**** Fix
不顯示任何 /away 訊息。
#+begin_src emacs-lisp
  (defun rcirc-handler-301 (process cmd sender args)
    "/away message handler.")
#+end_src

** Jabber
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'jabber)
#+end_src
* Alias                                                               :alias:
** git
和 git 相關的命令的 alias。
#+begin_src emacs-lisp
  (defalias 'git-log    'egg-log)
  (defalias 'git-status 'egg-status)
  (defalias 'git-rebase 'magit-rebase-step)
  (defalias 'git-push   'magit-push)
  (defalias 'git-commit 'egg-commit-log-edit)
#+end_src
** Misc
#+begin_src emacs-lisp
  (defalias 'coldnew/set-mark-command 'cua-set-mark-or-rectangle-mark)
  (defalias 'coldnew/folding-toggle   'toggle-selective-display)
  (defalias 'iwb 'indent-whole-buffer)
#+end_src
* 版本管理
**  Git
*** egg
**** Depends
#+begin_src emacs-lisp
  (require 'egg)
#+end_src
**** Config
#+begin_src emacs-lisp
  ;; do not auto-update egg-status on file save
  (setq egg-auto-update nil)

  ;; do not switch to the status buffer in the same window
  (setq egg-switch-to-buffer t)

  ;; make egg auto guess next action
  (setq egg-confirm-next-action nil)

  ;; remodify next-action priority
  (defsubst egg-guess-next-action (desc)
    (cond
     ((memq :file-has-merged-conflict desc) :merge-file)
     ((memq :file-is-modified desc)         :stage-file)
     ((memq :has-staged-changes desc)       :commit)
     ((memq :file-is-unmerged desc)         :stage-file)
     ((memq :wdir-has-merged-conflict desc) :status)
     ((memq :wdir-has-unmerged-files  desc) :stage-all)
     ((memq :wdir-is-modified desc)         :stage-all)
     ((memq :rebase-in-progress desc)       :rebase-continue)
     (t                                     :quit)))
#+end_src
**** Keybinding
#+begin_src emacs-lisp :tangle no
  (add-hook 'egg-commit-buffer-mode-hook
            '(lambda ()
               (define-key coldnew/command-mode-map "c" 'egg-log-msg-done)
               ))

#+end_src
**** Advice                                                       :advice:
當進入 egg-status 或是 egg-commit-log-edit 時，關掉其他 window。
#+begin_src emacs-lisp
  (defadvice egg-status (around goto-egg-status-buffer activate)
    "Delete other windows after visiting egg-status."
    ad-do-it
    (delete-other-windows))

  (defadvice egg-commit-log-edit (around goto-egg-commit-buffer activate)
    "Delete other windows after visiting egg-commit-buffer."
    ad-do-it
    (delete-other-windows))
#+end_src
*** magit
#+begin_src emacs-lisp
  ;;;;;;;; Magit
  (require 'magit)
  ;; if use magit, do not use vc-git to handle Git interface.
  ;; (when (featurep 'magit)
  ;;   (setq vc-handled-backends (remq 'Git vc-handled-backends)))
#+end_src
**** Magit 的使用
每個 magit buffer
*** git-emacs
#+begin_src emacs-lisp
  (require 'git-emacs)
  ;;   ;; disable git-emacs's advice
  ;;   (ad-disable-advice 'vc-next-action 'around 'git--vc-git-next-action)
  ;;   (ad-activate 'vc-next-action)
  (define-key git--branch-mode-map (kbd "C-g") 'git--quit-buffer)
#+end_src
* Hooks                                                               :hook:
** find-file-hook
#+begin_src emacs-lisp
  ;; Auto add HEADER in new file
  (add-hook 'find-file-hook
            '(lambda ()
               (when (and (buffer-file-name)
                          (not (file-exists-p (buffer-file-name)))
                          (= (point-max) 1))
                 (let ((header-snippet "HEADER")
                       (yas/fallback-behavior 'return-nil))
                   (insert header-snippet)
                   ;; if can't expand snippet, clear whole buffer
                   (if (not (yas/expand))
                       (delete-region (point-min) (point-max)))))))
#+end_src

** before-save-hook
#+begin_src emacs-lisp
  ;; If save a newfile to nonexist directory, create the directory before save.
  (add-hook 'before-save-hook
            '(lambda ()
               (or (file-exists-p  (file-name-directory buffer-file-name))
                   (make-directory (file-name-directory buffer-file-name) t))))
#+end_src
* 檔案備份
#+begin_src emacs-lisp
  (setq auto-save-interval  50)           ; Number of input events between auto-saves
  (setq auto-save-timeout   30)           ; Number of seconds idle time before auto-save
  (setq auto-save-visited-file-name t)    ; auto-save buffer in the file it is visiting
  (setq delete-by-moving-to-trash nil)    ; delete file don't use system's trash can
  (setq delete-auto-save-files      t)    ; delete auto-save file when bffer is saved or killed
  (setq auto-save-default    t)           ; auto-save of every file-visiting buffer

  ;; if emacs-backup-dir does not exist, create it
  (if (not (file-exists-p emacs-backup-dir))
      (make-directory emacs-backup-dir t))

  (setq backup-directory-alist `(("." . ,emacs-backup-dir)))
  (setq version-control      t )          ; enable version-control
  (setq backup-by-copying    t )          ; backup by copy
  (setq kept-old-versions   10 )          ; keep 10 old-version
  (setq kept-new-versions   20 )          ; keep 20 new-version
  (setq delete-old-versions  t )          ; delete non-of-above version

  ;; change auto-save-list setting
  (setq auto-save-list-file-prefix (concat emacs-backup-dir "auto-saves-"))
  (setq auto-save-file-name-transforms `((".*"  ,emacs-backup-dir)))
#+end_src
* 多媒體                                                               :emms:
:PROPERTIES:
:tangle: no
:END:
使用 emacs 聽音樂。
** 預先載入套件
#+begin_src emacs-lisp
  (require 'emms-setup)
#+end_src
** 選用開發中的 emms 功能
啟用 emms 所有穩定版的功能。
在 emms-setup 裡面，emms 提供了 minimalistic、tandard、all 以及包含各種含在測試中的外掛。
選擇 all 啟用了所有穩定版本的外掛，devel 是選用開發中的外掛。
#+begin_src emacs-lisp
  (emms-devel)
#+end_src
** 自動根據音樂檔的 id3 Tag 進行語言解碼
#+begin_src emacs-lisp
  (require 'emms-i18n)
#+end_src
** 設定 emms 所使用的播放器
emms-setup 提供了 emms-default-players 這個函數來簡化播放器的設定，
這邊重新設定我所需要使用的多媒體播放程式。
#+begin_src emacs-lisp
  (setq emms-player-list '(emms-player-mpg321
                           ;;emms-player-ogg123
                           emms-player-mplayer-playlist
                           emms-player-mplayer
                           emms-player-vlc
                           ))
#+end_src
** 設定預設的音樂資料夾路徑
#+begin_src emacs-lisp

#+end_src
** 播放清單設置
#+begin_src emacs-lisp
  (setq emms-playlist-buffer-name "*EMMS Playlist*"
        emms-playlist-mode-open-playlists t)

  (require 'emms-info-libtag)
  (setq emms-info-functions '(emms-info-libtag))

  (setq xwl-emms-playlist-last-track nil)
  (setq xwl-emms-playlist-last-indent "\\")

  (defun xwl-emms-track-description-function (track)
    "Return a description of the current track."
    (let* ((name (emms-track-name track))
           (type (emms-track-type track))
           (short-name (file-name-nondirectory name))
           (play-count (or (emms-track-get track 'play-count) 0))
           (last-played (or (emms-track-get track 'last-played) '(0 0 0)))
           (empty "..."))
      (prog1
          (case (emms-track-type track)
            ((file url)
             (let* ((artist (or (emms-track-get track 'info-artist) empty))
                    (year (emms-track-get track 'info-year))
                    (playing-time (or (emms-track-get track 'info-playing-time) 0))
                    (min (/ playing-time 60))
                    (sec (% playing-time 60))
                    (album (or (emms-track-get track 'info-album) empty))
                    (tracknumber (emms-track-get track 'info-tracknumber))
                    (short-name (file-name-sans-extension
                                 (file-name-nondirectory name)))
                    (title (or (emms-track-get track 'info-title) short-name))

                    ;; last track
                    (ltrack xwl-emms-playlist-last-track)
                    (lartist (or (and ltrack (emms-track-get ltrack 'info-artist))
                                 empty))
                    (lalbum (or (and ltrack (emms-track-get ltrack 'info-album))
                                empty))

                    (same-album-p (and (not (string= lalbum empty))
                                       (string= album lalbum))))
               (format "%10s  %3d   %-20s%-60s%-35s%-15s%s"
                       (emms-last-played-format-date last-played)
                       play-count
                       artist

                       ;; Combine indention, tracknumber, title.
                       (concat
                        (if same-album-p ; indention by album
                            (setq xwl-emms-playlist-last-indent
                                  (concat " " xwl-emms-playlist-last-indent))
                          (setq xwl-emms-playlist-last-indent "\\")
                          "")
                        (if (and tracknumber ; tracknumber
                                 (not (zerop (string-to-number tracknumber))))
                            (format "%02d." (string-to-number tracknumber))
                          "")
                        title        ; title
                        )

                       ;; album
                       (cond ((string= album empty) empty)
                             ;; (same-album-p "  ")
                             (t (concat "《" album "》")))

                       (or year empty)
                       (if (or (> min 0)  (> sec 0))
                           (format "%02d:%02d" min sec)
                         empty))))
            ((url)
             (concat (symbol-name type) ":" name))
            (t
             (format "%-3d%s"
                     play-count
                     (concat (symbol-name type) ":" name))))
        (setq xwl-emms-playlist-last-track track))))

  (setq emms-track-description-function
        'xwl-emms-track-description-function)
#+end_src
* Session
** filecache
#+begin_src emacs-lisp
  (require 'filecache)
  ;; setup file-cache-filter-regexps
  (setq file-cache-filter-regexps
        '("~$" "\\.o$" "\\.exe$" "\\.a$" "\\.out$"  "\\.elc$"
          "\\.output$" "\\.$" "#$" "\\.class$" "\\.pyc$" "\\.png$" "\\.jpg$" "\\.gif$"
          "\\.svn$" "\\.svn-base$" "\\.git$" "\\.hg$"
          ))

  (file-cache-add-directory-list '("~/.emacs.d/" ))
#+end_src
** savehist
#+begin_src emacs-lisp
  (require 'savehist)
  ;; keep minibuffer history between session
  (setq savehist-file (concat emacs-cache-dir "savehist.dat"))
  (savehist-mode 1)
#+end_src
** saveplace
#+begin_src emacs-lisp
  (require 'saveplace)
  (setq save-place-file (concat emacs-cache-dir "saveplace.dat"))
  (setq-default save-place t)
#+end_src
** recentf
#+begin_src emacs-lisp
  (require 'recentf)
  (require 'recentf-ext)
  ;; Setting cache file for recentf
  (setq recentf-save-file (concat emacs-cache-dir "recentf"))
  ;; Following file won;t contain in recentf
  (setq recentf-exclude '("\\.elc$" "\\.pyc$" "\\.recentd$" "^/tmp/"))
#+end_src
** desktop
#+begin_src emacs-lisp
  (require 'desktop)
  (setq desktop-path (list emacs-cache-dir))
  (setq desktop-dirname emacs-cache-dir)
  (setq desktop-base-file-name "desktop.dat")
  (setq desktop-missing-file-warning nil)

  ;; Enable desktop
  (desktop-save-mode t)

  (defadvice desktop-owner (after pry-from-cold-dead-hands activate)
    "Don't allow dead emacsen to own the desktop file."
    (when (not (emacs-process-p ad-return-value))
      (setq ad-return-value nil)))

  (defun desktop-in-use? ()
    (and (file-exists-p desktop-base-file-name) (file-exists-p desktop-base-lock-name)))

  (defun autosave-desktop ()
    (if (desktop-in-use?) (desktop-save-in-desktop-dir)))

  ;; auto save desktop
  (add-hook 'after-init-hook
            (lambda ()
              (setq *desktop-saver-timer*
                    (run-with-timer 5 300 'autosave-desktop))))

  ;; Following modes are ignore and won't save to desktop
  (setq desktop-buffers-not-to-save
        (concat "\\("
                "^\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
                "\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
                "\\)$"))

  (add-to-list 'desktop-modes-not-to-save 'fundamental-mode)
  (add-to-list 'desktop-modes-not-to-save 'dired-mode)
  (add-to-list 'desktop-modes-not-to-save 'Info-mode)
  (add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
  (add-to-list 'desktop-modes-not-to-save 'w3m-mode)
  (add-to-list 'desktop-modes-not-to-save 'view-mode)
#+end_src
* 游標                                                               :cursor:
** TODO remove
#+begin_src emacs-lisp :tangle no
  (defvar emacs-normal-cursor-color "white")
  (defvar emacs-normal-cursor-type 'bar)

  (defvar emacs-read-only-cursor-color "gray")
  (defvar emacs-read-only-cursor-type 'box)

  (defvar emacs-overwrite-cursor-color "yellow")
  (defvar emacs-overwrite-cursor-type 'hbar)

  ;;;; ---------------------------------------------------------------------------
  ;;;; Hooks
  ;;;; ---------------------------------------------------------------------------
  (add-hook 'post-command-hook 'coldnew/set-cursor-according-mode)


  ;;;; ---------------------------------------------------------------------------
  ;;;; Functions
  ;;;; ---------------------------------------------------------------------------
  (defun coldnew/set-cursor-according-mode ()
    "change cursor shap and color according mode"
    (cond
     ((string= "Command" coldnew-editor-state)
      (setq cursor-type emacs-read-only-cursor-type)
      (setq cursor-color emacs-read-only-cursor-color))
     (buffer-read-only
      (setq cursor-type emacs-read-only-cursor-type)
      (setq cursor-color emacs-read-only-cursor-color))
     ;; (overwrite-mode
     ;;   (set-cursor-color djcb-overwrite-color)
     ;;   (setq cursor-type djcb-overwrite-cursor-type))
     (t
      (setq cursor-type emacs-normal-cursor-type)
      (setq cursor-color emacs-normal-cursor-color))))
#+end_src
** TODO remove
#+begin_src emacs-lisp
  (defvar emacs-normal-cursor-color "white")
  (defvar emacs-normal-cursor-type 'bar)
  (add-hook 'post-command-hook 'coldnew/set-cursor-according-mode)
  (defun coldnew/set-cursor-according-mode ()
    "change cursor shap and color according mode"
    (cond
     (t
      (setq cursor-type emacs-normal-cursor-type)
      (setq cursor-color emacs-normal-cursor-color))))
#+end_src
* 全域性按鍵設置
** Unset key
#+begin_src emacs-lisp
  (defmacro coldnew/global-unset-key (key &rest bindings)
    `(progn
       (let* ((keyf ,key)
              (bindings (list ,@bindings)))
         (with-temp-buffer
           ;;(with-current-buffer (get-buffer-create "tttmp")
           (insert "| unset key ")
           (newline)
           (insert "|-")
           (newline)
           (while keyf
             (global-unset-key keyf)
             (insert (format "| %s \n" (coldnew/parse-keymap keyf)))
             (setq keyf (pop bindings))
             )
           (princ (buffer-string))
           ))))

  (defun coldnew/parse-keymap (s)
    "Parse \C-x to Ctrl-x, and return string."
    (let ((char-list (string-to-list (replace-regexp-in-string " " "" s)))
          (result-list))
      (dolist (char char-list)
        ;;\A to \Z
        ;; set char to cdr of coldnew/keymap-string-alist if assoc succes
        ;; else set char to char
        (setq char (or (reverse (string-to-list (cdr-safe (assoc char coldnew/keymap-string-alist))))
                       char))
        (setq result-list (cons char result-list))
        (setq result-list  (cons  ?\s result-list))
        )
      ;;result-list
      (list-to-string (nreverse
                       (cdr-safe
                        (flatten result-list))))
      ))

  (defvar coldnew/keymap-string-alist
    (let ((result))
      (dolist (char (number-sequence ?\^a ?\^z))
        (add-to-list 'result (cons char (concat "Ctrl-" (char-to-string (1- (+ char ?a)))))))
      result))

  (coldnew/parse-keymap (kbd "C-a e C-x y"))
  (coldnew/parse-keymap "\C-x e ")

  (setq show-paren-delay 0)



#+end_src

#+results: global-unset-key
| unset key |
|-----------|
| Ctrl-x e  |
| Ctrl-x d  |
| Ctrl-x e  |

** test
#+name: global-unset-key
#+begin_src emacs-lisp :results value raw
      (coldnew/global-unset-key
       (kbd "C-x e")
       (kbd "C-x d")
       "\C-x e"
  "\C-x n"
    ;;   "\C-c e"
       )
  (global-unset-key (kbd "C-w"))
#+end_src

** Function key prefix
Function key 設置常用的命令。

| Key | Command             |
|-----+---------------------|
| F1  | woman               |
| F2  | shell-pop           |
| F3  | call-last-kcd-macro |
| F4  | sr-speedbar-toggle  |

#+begin_src emacs-lisp
  (global-set-key (kbd "<f1>")     'woman)
  (global-set-key (kbd "<f2>")     'shell-pop)
  (global-set-key (kbd "<f3>")     'call-last-kbd-macro)
  (global-set-key (kbd "<f4>")     'sr-speedbar-toggle)
#+end_src
** Ctrl Prefix
*** Default Emacs keybinding
#+begin_src emacs-lisp
  (global-set-key (kbd "C-n") 'next-line)
  (global-set-key (kbd "C-p") 'previous-line)
  (global-set-key (kbd "C-b") 'backward-char)
  (global-set-key (kbd "C-f") 'forward-char)
  (global-set-key (kbd "C-e") 'move-end-of-line)
  (global-set-key (kbd "C-a") 'move-beginning-of-line)
#+end_src

*** 向右貪婪刪除
#+begin_src emacs-lisp
  (global-set-key (kbd "C-d") 'hungry-delete-forward)
#+end_src

*** 向左貪婪刪除
#+begin_src emacs-lisp
  (global-set-key (kbd "C-l") 'hungry-delete-backward)
#+end_src

*** Misc
#+begin_src emacs-lisp
  (global-set-key (kbd "C-v") 'coldnew/set-mark-command)
  (global-set-key (kbd "C-]") 'coldnew/toggle-state)
#+end_src

*** iedit
#+begin_src emacs-lisp
  (global-set-key (kbd "C-;") 'iedit-mode)
#+end_src

*** Undo
#+begin_src emacs-lisp
  (global-set-key (kbd "C-/") 'undo-tree-undo)
#+end_src

*** 放大字體
#+begin_src emacs-lisp
  (global-set-key (kbd "C-=") 'text-scale-increase)
#+end_src

*** 縮小字體
#+begin_src emacs-lisp
  (global-set-key (kbd "C--") 'text-scale-decrease)
#+end_src
** Ctrl-x Prefix
*** Misc
| 按鍵    | 命令                | 用途                   |
|---------+---------------------+------------------------|
| C-x C-f | lusty-file-explorer | 查詢並打開檔案         |
| C-x C-y | yank-n-times        | 多次貼上               |
| C-x C-r | lusty-sudo-explorer | 使用 sudo 打開檔案     |
| C-x C-b | ibuffer             | 顯示 ibuffer           |
| C-x C-l | recenter            | 將游標至於 buffer 中間 |
|         |                     |                        |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-f")  'lusty-file-explorer)
  (global-set-key (kbd "C-x C-r")  'lusty-sudo-explorer)
  (global-set-key (kbd "C-x C-y")  'yank-n-times)
  (global-set-key (kbd "C-x C-l")  'recenter)
  (global-set-key (kbd "C-x C-b")  'ibuffer)
#+end_src

#+begin_src emacs-lisp
  ;;  (global-set-key (kbd "C-x b")    'coldnew/helm-filelist)
  (global-set-key (kbd "C-x C-d")  'dired)
  (global-set-key (kbd "C-x vv") 'egg-next-action)
  (global-set-key (kbd "C-x M-x") 'helm-M-x)
  (global-set-key (kbd "C-x o")   'switch-window)
  (global-set-key (kbd "C-x C-n") 'auto-complete)
  (global-set-key (kbd "C-x C-s") 'save-buffer-always)
  (global-set-key (kbd "C-x F") 'fullscreen-window)
  (global-set-key (kbd "C-x s") 'shell-command)
#+end_src

*** Google 相關
| 按鍵    | 命令                   | 用途           |
|---------+------------------------+----------------|
| C-x g e | google-translate-zh-en | 中文翻譯成英文 |
| C-x g t | google-translate-en-zh | 英文翻譯成中文 |
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x g e") 'google-translate-zh-en)
  (global-set-key (kbd "C-x g t") 'google-translate-en-zh)
#+end_src
*** 轉換
| 按鍵    | 命令                     | 用途                             |
|---------+--------------------------+----------------------------------|
| C-x c c | capitalize-word-backward | 將前面的 word 第一個字母大寫     |
| C-x c l | downcase-word-backward   | 將前面的 word 變成小寫           |
| C-x c u | upcase-word-backward     | 將前面的 word 變成大寫           |
| C-x c x | dos2unix                 | 將目前的檔案轉換成 unix 檔案型式 |
| C-x c d | unix2dos                 | 將目前的檔案轉換成 dos 檔案型式  |
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x c c") 'capitalize-word-backward)
  (global-set-key (kbd "C-x c l") 'downcase-word-backward)
  (global-set-key (kbd "C-x c u") 'upcase-word-backward)
  (global-set-key (kbd "C-x c x") 'dos2unix)
  (global-set-key (kbd "C-x c d") 'unix2dos)
#+end_src
*** emms
| 按鍵        | 命令              | 用途       |
|-------------+-------------------+------------|
| C-x e s     | emms-start        | 啟動 emms  |
| C-x e n     | emms-next         | 下一首曲目 |
| C-x e p     | emms-previous     | 前一首曲目 |
| C-x e <SPC> | emms-pause        | 暫停曲目   |
| C-x e =     | emms-volume-raise | 放大音量   |
| C-x e -     | emms-volume-lower | 縮小音量   |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x e n") 'emms-next)
  (global-set-key (kbd "C-x e p") 'emms-previous)
  (global-set-key (kbd "C-x e <SPC>") 'emms-pause)
  (global-set-key (kbd "C-x e s") 'emms-start)
  ;;(require 'emms-volume)
  (global-set-key (kbd "C-x e =") 'emms-volume-raise)
  (global-set-key (kbd "C-x e -") 'emms-volume-lower)
#+end_src
** Ctrl-c prefix
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-h") 'coldnew/folding-toggle)
  (global-set-key (kbd "C-c C-e") 'eval-and-replace)
#+end_src

*** org-mode                                                          :org:
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c C-l") 'org-insert-link)
  (global-set-key (kbd "C-c o") 'org-iswitchb)
#+end_src

** Ctrl-w prefix
*** 窗口移動
| 按鍵  | 命令           | 用途             |
|-------+----------------+------------------|
| C-x n | windmove-down  | 移動到下面的窗口 |
| C-x p | windmove-up    | 移動到上面的窗口 |
| C-x b | windmove-left  | 移動到左邊的窗口 |
| C-x f | windmove-right | 移動到右邊的窗口 |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x n") 'windmove-down)
  (global-set-key (kbd "C-x f") 'windmove-right)
  (global-set-key (kbd "C-x b") 'windmove-left)
  (global-set-key (kbd "C-x p") 'windmove-up)
#+end_src
*** TODO 刪除區域或是一行
#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'kill-region)
  (global-set-key (kbd "M-w") 'kill-ring-save)
#+end_src
** Ctrl-Meta Prefix
#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-,") 'beginning-of-buffer)
  (global-set-key (kbd "C-M-.") 'end-of-buffer)
  (global-set-key (kbd "C-M-n") 'scroll-other-window)
  (global-set-key (kbd "C-M-p") 'scroll-other-window-down)
#+end_src

** Meta Prefix
*** Default Emacs keybinding
#+begin_src emacs-lisp
(global-set-key (kbd "M-f") 'forward-word)
(global-set-key (kbd "M-b") 'backward-word)
(global-set-key (kbd "M-e") 'forward-sentence)
(global-set-key (kbd "M-a") 'backward-sentence)
#+end_src

#+begin_src emacs-lisp
(global-set-key (kbd "M-r") 'query-replace-regexp)
#+end_src

*** Misc
#+begin_src emacs-lisp
  (global-set-key (kbd "M-s") 'coldnew/helm-occur)
  (global-set-key (kbd "M-l") 'backward-delete-word)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "M-n") 'scroll-up)
  (global-set-key (kbd "M-p") 'scroll-down)
  (global-set-key (kbd "M-g") 'linum-ace-jump)
  (global-set-key (kbd "M-v") 'er/expand-region)
  (global-set-key (kbd "M-q") 'coldnew/switch-to-command-mode)
  (global-set-key (kbd "M-/") 'undo-tree-redo)
  (global-set-key (kbd "M-.") 'helm-etags+-select-one-key)
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; (global-set-key (kbd "M-1") 'delete-other-windows)
  ;; (global-set-key (kbd "M-2") 'split-window-below)
  ;; (global-set-key (kbd "M-3") 'split-window-right)
  ;; (global-set-key (kbd "M-4") 'delete-window)
  ;; (global-set-key (kbd "M-0") 'other-window)
  ;;  (global-set-key (kbd "M-j") 'switch-window)
  ;;  (global-set-key (kbd "M-i") 'yas/expand)


#+end_src

** Meta-j prefix
*** ECB
#+begin_src emacs-lisp
;;  (global-set-key (kbd "C-0 e") 'ecb-toggle-ecb-windows)
;;  (global-set-key (kbd "C-0 1") 'ecb-goto-window-edit1)
;;  (global-set-key (kbd "C-0 2") 'ecb-goto-window-edit2)
;;  (global-set-key (kbd "C-0 m") 'ecb-goto-window-methods)
; ; (global-set-key (kbd "C-0 l") 'ecb-toggle-layout)
#+end_src
*** Window move
#+begin_src emacs-lisp
;;  (global-set-key (kbd "M-j n") 'windmove-down)
;;  (global-set-key (kbd "M-j p") 'windmove-up)
;;  (global-set-key (kbd "M-j b") 'windmove-left)
;;  (global-set-key (kbd "M-j f") 'windmove-right)
#+end_src
** Shift prefix
#+begin_src emacs-lisp
  (global-set-key[(shift return)] 'insert-empty-line)
#+end_src

** Super prefix
#+begin_src emacs-lisp
  (global-set-key (kbd "s-l") 'linum-mode)
  (global-set-key (kbd "s-s") 'shell-command)
#+end_src
** Other
#+begin_src emacs-lisp
  (global-set-key (kbd "<delete>") 'hungry-delete-forward)
  (global-set-key (kbd "C-.") 'repeat)
  (global-set-key (kbd "%") 'match-paren)

#+end_src
全域性設定 (）、 ""、 []、 {}具有自動補全功能
#+begin_src emacs-lisp
  ;; (global-set-key (kbd "(") 'paredit-open-parenthesis)
  ;; (global-set-key (kbd ")") 'paredit-close-parenthesis)
  ;; (global-set-key (kbd "[") 'paredit-open-square)
  ;; (global-set-key (kbd "]") 'paredit-close-square)
  ;; (global-set-key (kbd "{") 'paredit-open-curly)
  ;; (global-set-key (kbd "}") 'paredit-close-curly)
  ;; (global-set-key (kbd "\"") 'paredit-doublequote)
#+end_src

* Register                                                         :register:
** TODO add now doc
** 複製貼上多次
Use registers. Mark the region, store it in register `a' and insert the
contents of register `a' multiple times.

Mark region

C-x r s a

C-x r i a
C-x r i a
*** C-x r s copy-to-register
*** C-x r i insert-register
** 放置快速跳轉的捷徑命令。
使用 Ctrl-x r j <char> 就可以進行快速跳轉至檔案，其中 <char> 為以下所設定。
#+begin_src emacs-lisp
  (dolist
      (r `(
           ;; emacs-config
           (?e (file . ,(expand-file-name emacs-config-file)))
           ;; TODO.org
           (?t (file . "~/Dropbox/Org/TODO.org"))
           ;; (?b (file . "~/personal/business.org"))
           ))
    (set-register (car r) (cadr r)))
#+end_src

* Deprecated
:PROPERTIES:
:tangle: no
:END:
這邊放置的是不再使用的設定,並且這邊的設定並不會輸出至我的 emacs-config 上。
#+begin_src emacs-lisp
  (defun sacha/search-word-backward ()
    "Find the previous occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-backward "w_")
      (goto-char
       (if (re-search-backward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))

  (defun sacha/search-word-forward ()
    "Find the next occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-forward "w_")
      (goto-char
       (if (re-search-forward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))
  (global-set-key '[M-up] 'sacha/search-word-backward)
  (global-set-key '[M-down] 'sacha/search-word-forward)
#+end_src

#+begin_src emacs-lisp
  (defun sacha/find-tags ()
    "Set the TAGS file."
    (set (make-variable-buffer-local 'tags-table-list) nil)
    (set (make-variable-buffer-local 'tags-file-name)
         (sacha/recursive-find-file "TAGS")))
#+end_src

https://github.com/travisbhartwell/emacs-config/blob/master/HOME/_emacs.d/init-helpers.el
http://doc.norang.ca/org-mode.html
http://jixiuf.github.com/tags/@Emacs.html

#+begin_src emacs-lisp
  (defun run-rand (n times)
    (defun run-rand-iter (k)
      (cond ((= k times) (princ (concat (number-to-string (random n)) "\n")))
            (t
             (princ (concat (number-to-string (random n)) "\n"))
             (run-rand-iter (+ k 1)))))
    (run-rand-iter 0))

#+end_src

* Other
** TODO 為 google-weather 增加編碼的設定
#+begin_src emacs-lisp
  (defun google-weather-build-url (location &optional language)
    "Build URL to retrieve weather for LOCATION in LANGUAGE."
    (concat "http" (when google-weather-use-https "s") "://" google-weather-url "?weather=" (url-hexify-string location)
            (when language
              (concat "&hl=" language))
            ;; add for encoding
            (concat "&oe=" "utf8")))
#+end_src

* Local File Variable
# Local Variables:
# mode: org
# End:









