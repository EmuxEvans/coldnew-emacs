#+TITLE: coldnew's emacs
#+AUTHOR: Yen-Chin, Lee <coldnew>
#+email: coldnew.tw at gmail.com
#+STARTUP: overview indent align
#+BABEL: :cache yes
#+OPTIONS: ^:nil

#+BEGIN_SRC emacs-lisp
  (modify-all-frames-parameters '((fullscreen . maximized)))
#+END_SRC

* 語言與編碼                                                         :locale:

emacs 編碼設定，大部份都設定成 utf-8。

- 系統編碼。

  #+begin_src emacs-lisp
    (prefer-coding-system 'utf-8 )
  #+end_src

- 語言環境。

 #+begin_src emacs-lisp
   (set-language-environment 'utf-8 )
 #+end_src

- 文件保存時的編碼設置

  #+begin_src emacs-lisp
    (set-buffer-file-coding-system 'utf-8 )
  #+end_src

- 鍵盤編碼設定

  #+begin_src emacs-lisp
    (set-keyboard-coding-system    'utf-8 )
  #+end_src

- 設定終端機的編碼

  #+begin_src emacs-lisp
    (set-terminal-coding-system    'utf-8 )
  #+end_src

- 選擇區域內編碼

  #+begin_src emacs-lisp
    (set-selection-coding-system   'utf-8 )
  #+end_src

- 剪貼簿編碼設定

  #+begin_src emacs-lisp
    (set-clipboard-coding-system   'utf-8 )
  #+end_src

- 使用 utf-8 編碼顯示文件名

  #+begin_src emacs-lisp
    (set-file-name-coding-system   'utf-8 )
  #+end_src

- 設定時間顯示使用英文

  時間顯示中文還是怪怪的，所以這邊設定成英文

  #+begin_src emacs-lisp
    (setq system-time-locale "en_US" )
  #+end_src

- 讀寫緩衝區或是檔案時使用的編碼

  #+BEGIN_SRC emacs-lisp
    (setq coding-system-for-read 'utf-8)
    (setq coding-system-for-write 'utf-8)
  #+END_SRC

* 套件管理                                                          :package:

emacs 在 24 版後終於有自己的套件管理器 ELPA，不過有些外部的套件沒
辦法透過他來安裝，所以我又使用了另外一個非常好用的套件管理器 el-get,
透過這兩個套件管理器，在 emacs 下安裝新的套件是非常方便的。

我將我的套件都存放在 =~/.emacs.d/lisp= 裡面，但是這個資料夾是不使用 git
進行管理的(避免沒必要的 commit 以及提高可以移植性)，因此在使用
=use-package= 以及 =req-package= 來對套件進行管理以及自動安裝。

** 使用 el-get 進行套件管理

El-Get allows you to install and manage elisp code for Emacs. It
supports lots of differents types of sources and is able to install
them, update them and remove them, but more importantly it will init
them for you. That means it will require the features you need, load
the necessary files, set the Info paths so that C-h i shows the new
documentation you now depend on, and finally call your own
initialisation code for you to setup the extension. Or call it a
package.

Github: https://github.com/dimitri/el-get

*** 設定安裝套件位置為 ~/.emacs.d/lisp

我不喜歡 el-get 預設使用 =~/.emacs.d/el-get= 目錄來安裝檔案，這邊將他
改為 =~/.emacs.d/lisp=

#+begin_src emacs-lisp
  (setq-default el-get-dir "~/.emacs.d/lisp")
#+end_src

*** 如果 el-get 不存在的話，重新安裝 el-get

曾經有一次手殘不小心砍掉我整個 lisp 資料夾，因此特別加了這個程式來進行
保護，如果 el-get 不存在，則重新安裝他。

#+begin_src emacs-lisp
      (unless (require 'el-get nil t)
        (setq el-get-install-branch "master")
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
          (end-of-buffer)
          (eval-print-last-sexp)))
#+end_src

*** 如果 elpa 的 recepies 不存在的話，自動建立他

第一次下載 el-get 的時候，並不會自動建立 elpa 的 recipes, 這邊進行檢查，
若 elpa 的 recipes 不存在，則自動建立他。

#+begin_src emacs-lisp
  (unless (file-exists-p el-get-recipe-path-elpa)
    (el-get-elpa-build-local-recipes))
#+end_src

*** 將我的 recipes 加入 el-get-recipe-path

el-get 雖然好用，但是還是有一些 recipes 沒有，所以我自己維護另外
一份 recipes，我自己寫的 recipes 則放置在 =~/.emacs.d/recipes= 。

#+begin_src emacs-lisp
  (add-to-list 'el-get-recipe-path "~/.emacs.d/recipes")
#+end_src

*** 設定 el-get 的 recipes 預設使用 emacs-lisp-mode

el-get 的 recipes 使用 *.rcp 來作為其副檔名，這邊將這類檔案設定為
emacs-lisp-mode。

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rcp$" . emacs-lisp-mode))
#+end_src

** 使用 packages.el 來進行套件管理

packages.el (或 [[http://elpa.gnu.org/][ELPA]])是 emacs 自版本 24 後自帶的套件管理程式，雖然我是使用
el-get 進行套件管理，但是實際上 el-get 對於 ELPA 有附帶的套件，還是會透過
ELPA 進行安裝，因此也要對他進行設定。

URL: http://elpa.gnu.org/

*** 設定安裝套件位置為 ~/.emacs.d/lisp/package/elpa

在 el-get 裡面，好像是將 packages 下載的套件置放到
=~/.emacs.d/lisp/package/elpa= ，可是預設的 packages 會安裝檔案到
=~/.emacs.d/elpa= 裡面，這邊將他修改一下，讓我比較好管理我的 emacs。

#+begin_src emacs-lisp
  (setq package-user-dir "~/.emacs.d/lisp/package/elpa/")
#+end_src

*** 設定我需要的 packages 倉庫

除了 ELPA 以外，還有許多好用的倉庫可以讓 packages.el 進行下載，這邊將他們
全部加入到 =package-archives= 裡面。

#+begin_src emacs-lisp
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (add-to-list 'package-archives '("ELPA" . "http://tromey.com/elpa/") t)
  (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/") t)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
#+end_src

*** 初始化 package

設定都完成後，要記得進行 package 的初始化。

#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC

** 使用 use-package 進行套件管理

use-package 是一套透過 elisp 的巨集功能來進行 emacs 套件管理的套件。

Github: https://github.com/jwiegley/use-package

*** 當 use-package 無法載入時，使用 el-get 自動安裝他

#+BEGIN_SRC emacs-lisp
  (unless (require 'use-package nil 'noerror)
    (el-get-reinstall 'use-package))
#+END_SRC

*** 使用 el-get 自動安裝遺失的套件

在 use-package 原先設定的方法中，是透過 ELPA 來安裝遺失的套件，我偏好這件
事情交給 el-get 來管理，所以要修改 use-package 的 function call。

這邊透過 defadvice 來修改 use-package 裡面安裝 elpa﻿﻿ 套件的方法，當有安
裝 el-get 的時候，使用 el-get 的方式來維護套件，反之使用 elpa 的方式來維護套
件。

#+BEGIN_SRC emacs-lisp
  (defadvice use-package-ensure-elpa (before package-install (package) activate)
    (if (require 'el-get nil 'noerror)
        (unless (el-get-package-installed-p package)
          (el-get-reinstall package))
      ad-do-it))
#+END_SRC

** 使用 req-package 簡化 use-package 的設定

req-package is a macro wrapper on top of use-package. It's goal is to
simplify package dependencies management, when using use-package for
your .emacs

Github: https://github.com/edvorg/req-package

#+BEGIN_SRC emacs-lisp
  (unless (require 'use-package nil 'noerror)
    (el-get-reinstall 'req-package))
#+END_SRC

使用 req-package 有一點要特別注意，那就是你必須在檔案尾巴加上以下的設
定

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package-finish)
#+END_SRC

這樣當套件遺失的時候，req-package 才會呼叫 use-package 的方法來幫你安裝遺
失的套件。

** 使用 require* 來進行套件載入

雖然 req-package 很好用，不過對我這個喜新厭舊的人來說，說不定某天會看到
更好用的套件管理方式，因此我自定義我用來載入套件的方式, =require*= 。

require* 實際上就是 req-package 的綁定，只是語法和傳統 emacs 的 require
相同。

#+BEGIN_SRC emacs-lisp
  (defmacro require* (feature &rest body)
    "require FEATURE wrapper for `req-package'.
  This function is used to abstract package loading."
    (eval
     ``(req-package ,,feature ,@body)))
#+END_SRC

使用時如下，也可以像 req-package 那樣加上參數

#+BEGIN_SRC emacs-lisp :tangle no
  (require* 'dired) ;; you can omit this empty requirement because of dired-single

  (require* 'dired-single
            :require dired
            :init (...))
#+END_SRC

為了讓我的 =require*= 可以很清楚的在 elisp 程式碼中顯示，我替他加上和
emacs 中的 =require= 相同的色彩，這樣可以很清楚看到我哪些程式是進行套件
載入使用。

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'emacs-lisp-mode
                          '(("(\\(require\*\\*\\)\\s [ \t']*\\(\\sw+\\)?"
                             (1 font-lock-keyword-face)
                             (2 font-lock-constant-face nil t))))
  (font-lock-add-keywords 'lisp-interaction-mode
                          '(("(\\(require\*\\*\\)\\s [ \t']*\\(\\sw+\\)?"
                             (1 font-lock-keyword-face)
                             (2 font-lock-constant-face nil t))))
#+END_SRC

* TODO ----------------- Prepare for re-write ---------------------------------

ref : http://steckerhalter.co.vu/steckemacs.html

* 關於這份檔案

使用 emacs 自 2006 年至今，最初我的 emacs 配置也是英文版，並且分散了許多檔案，
直到我知道了 org-mode 以及所謂的文學編程，我二話不說就將我的 emacs 設定移植到
org-mode 上面，並重新改寫用中文來寫配置的說明。

在這幾年的時間裡，用 emacs 學 emacs 以及配置 emacs 花費了我不少時間，網路上
太多太多中文的配置都是複製貼上、複製貼上，連用途都不懂就轉用了別人的文章放到
自己的部若格上，讓我剛開始學 emacs 查找資料時有許多困擾， 為了讓以後有人
看到我的 emacs 配置，能夠一看就很明白這個配置是做什麼，於是我將所有的配置
改寫回正體中文。

對現在我而言，修改 emacs 的設定已經開始變成了習慣，就當作自己再寫作文/部若格吧，
很多配置以及外掛是非常棒的，但是若只是將官方網站上的英文介紹複製過來，不免太無
趣，經過理解才能成為自己的東西。於是我慢慢著手增加自己配置文件的說明份量。

                                                               <待續>

* 基礎設置                                                             :base:

這邊放置的是 *初始化* 的設定，為了避免設定衝突，部份 Macro 和 Function 會放置於此。

** 預先載入 cl 套件。

#+begin_src emacs-lisp
  (eval-when-compile (require 'cl))
#+end_src

** 複製系統的 PATH 變數

在一開始 emacs 啟動時，複製系統的 Shell PATH 給 emacs 知道，這樣有些額外安
裝的程式，比如 OSX 下的 homebrew 路徑，emacs 也可以知道他在那邊，當有需要呼
叫外部程式的時候會比較方便。

#+BEGIN_SRC emacs-lisp
  (defun set-exec-path-from-shell-PATH ()
    "Set up Emacs' `exec-path' and PATH environment variable to match that used by the user's shell.

  This is particularly useful under Mac OSX, where GUI apps are not started from a shell."
    (interactive)
    (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator))))

  (set-exec-path-from-shell-PATH)
#+END_SRC

** 資料夾相關變數設定                                             :variable:

這邊設定了各種類型資料夾的路徑。

- emacs 設定檔預設所在的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-dir "~/.emacs.d/"
      "The top-level emacs-configure directory.")
  #+end_src

- 佈景主題的資料夾設定

  #+begin_src emacs-lisp
    (defconst emacs-themes-dir (concat emacs-dir "themes/")
      "directory to place emacs theme.")
  #+end_src

- el-get 安裝套件的路徑

  #+begin_src emacs-lisp
    (defconst emacs-lisp-dir   (concat emacs-dir "lisp/")
      "directory to place lisp packages from internet.")
  #+end_src

- el-get 的 recipes 路徑

  #+begin_src emacs-lisp
    (defconst emacs-recipes-dir (concat emacs-dir "recipes/")
      "directory to place local el-get recepies.")
  #+end_src

- elpa 安裝套件的路徑

  #+begin_src emacs-lisp
    (defconst emacs-elpa-dir   (concat emacs-lisp-dir "elpa/")
      "directory to place ELPA lisp packages from internet.")
  #+end_src

- yasnippet 使用的 snippet 路徑

  #+begin_src emacs-lisp
    (defconst emacs-snippets-dir (concat emacs-dir "snippets/")
      "directory to place yasnippet files.")
  #+end_src

- 放置 binary 檔案的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-bin-dir    (concat emacs-dir "bin/")
      "directory to place binary staff.")
  #+end_src

- 放置 cache 等暫存檔案的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-cache-dir  (concat emacs-dir "cache/")
      "cache file directory.")
  #+end_src

- 備份文件的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-backup-dir (concat emacs-dir "backup/")
      "directory to backup files.")
  #+end_src

- 放置紀錄的資料夾

  #+begin_src emacs-lisp
    (defconst emacs-log-dir (concat emacs-dir "log/")
      "log file directory.")
  #+end_src

- 放置 jar 等其他文件的位置

  #+begin_src emacs-lisp
    (defconst emacs-etc-dir (concat emacs-dir "etc/")
      "etc file directory.")
  #+end_src

- Dropbox 資料夾

  #+begin_src emacs-lisp
    (defconst coldnew-dropbox-dir "~/Dropbox"
      "Dropbox directory.")
  #+end_src

- Sparkleshare 資料夾

  #+begin_src emacs-lisp
    (defconst coldnew-sparkleshare-dir "~/SparkleShare"
      "Sparkleshare directory.")
  #+end_src

** 檔案相關變數設定                                               :variable:

這邊設定了各種檔案的路徑。

- emacs 個人配置的檔案，也就是這個檔案

  #+begin_src emacs-lisp
    (defconst emacs-config-file (concat emacs-dir "config.org")
      "File to place emacs configs.")
  #+end_src

- 客制化設定檔的位置

  #+begin_src emacs-lisp
    (defconst emacs-custom-file (concat emacs-dir "custom.el")
      "store customize UI config.")
  #+end_src

- 書籤文件檔案

  #+begin_src emacs-lisp
    (defconst emacs-bookmark-file (concat emacs-cache-dir "bookmarks")
      "File to save bookmarks")
  #+end_src

** 作業系統測試

放置用於測試目前 emacs 執行在何種作業系統上的變數。

- MacOS X

  #+begin_src emacs-lisp
    (defvar mac-p     (eq system-type 'darwin)
      "Return nil if OS is not Mac.")
  #+end_src

- Linux

  #+begin_src emacs-lisp
    ;; linux device
    (defvar linux-p   (and (eq system-type 'gnu/linux) (not (eq system-type 'drawin)))
      "Return nil if OS is not Linux.")

    ;; linux 32-bit
    (defvar linux-32bit-p (and (string-match
                                (rx (or bos "x86-" bos "i686-")) system-configuration) linux-p)
      "Return nil if OS is not 32-bit linux.")

    ;; linux 64-bit
    (defvar linux-64bit-p (and (string-match (rx bos "x86_64") system-configuration) linux-p)
      "Return nil if OS is not 64-bit linux.")
  #+end_src

- Cygwin

   #+begin_src emacs-lisp
     (defvar cygwin-p  (eq system-type 'cygwin)
       "Return nil if OS is not CygWin.")
   #+end_src

- Window$

   #+begin_src emacs-lisp
     (defvar windows-p (eq system-type 'windows-nt)
       "Return nil if OS is not Windows.")
   #+end_src

** 螢幕解析度測試                                               :resolution:

放置測試螢幕解析度用的變數

#+begin_src emacs-lisp
  ;; 1280x800
  (defvar display-1280x800-p   (and (= (display-pixel-width) 1280)
                                    (= (display-pixel-height) 800))
    "Return nil if current display's resolution is not 1280x800")

  ;; 1280x1024
  (defvar display-1280x1024-p  (and (= (display-pixel-width) 1280)
                                    (= (display-pixel-height) 1024))
    "Return nil if current display's resolution is not 1280x1024")

  ;; 1920x1080
  (defvar display-1920x1080-p  (and (= (display-pixel-width) 1920)
                                    (= (display-pixel-height) 1080))
    "Return nil if current display's resolution is not 1920x1080")
#+end_src

*** TODO Shell
#+begin_src emacs-lisp
  (defvar emacs-default-shell "/bin/bash"
    "Default shell for cemacs.")
  (defvar emacs-popup-shell-window-height 30
    "Window hight of popup shell.")
  (defvar emacs-popup-shell-window-position "bottom"
    "Make popup shell window at buttom by default.")
#+end_src

#+RESULTS:
: emacs-popup-shell-window-position

*** TODO Path
#+begin_src emacs-lisp
  ;; TODO: make it work on every platform, now only has Linux support
  (setenv "PATH"
          (concat
           emacs-bin-dir ":"
           "~/.lein/bin" ":"
           (getenv "PATH")
           ))

  (setq exec-path (cons emacs-bin-dir exec-path))
#+end_src

** 使用者介面設定

關閉一些 emacs 預設的 UI 設定。

*** 不啟用 startup message

啟動 emacs 時會出現的 GNU/Emacs 畫面，這裡將他關閉
#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

*** 清空 **scratch** buffer 的文字。

預設 **scratch** 裡面會有幾行文字，直接將他清空。
#+begin_src emacs-lisp
  (setq initial-scratch-message "")
#+end_src

*** 關閉蜂鳴器

使用畫面閃爍代替電腦的蜂鳴器叫聲。
#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

*** 關閉工具列

不顯示工具列。
#+begin_src emacs-lisp
  (if (featurep 'tool-bar) (tool-bar-mode -1))
#+end_src

*** 關閉滾動條

關閉左側或右側的滾動條 (scrool-bar)。
#+begin_src emacs-lisp
  (if (featurep 'scroll-bar) (scroll-bar-mode -1))
#+end_src

*** 關閉游標閃爍

不允許游標閃爍。
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

Mac OSX 下會有方塊狀的提示，關掉他
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function #'ignore)
#+END_SRC

*** 關閉選單列

不顯示選單列
#+begin_src emacs-lisp
  (if (featurep 'menu-bar) (menu-bar-mode -1))
#+end_src

*** 回答問題時，使用 *y* 和 *n* 代替 *yes/no* 。

預設要使用 *yse* 或是 *no* 來回答問題，這裡將他改成用 *y* 或 *n* 。
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** TODO Misc

#+begin_src emacs-lisp
  ;; TODO: add comment
  (setq stack-trace-on-error t)
  (setq imenu-auto-scan t)
  ;;(setq redisplay-dont-pause t)

  ;; xrelated srtting
  ;;设定剪贴板的内容格式 适应 Firefox
  (set-clipboard-coding-system 'utf-8)
  ;;允许 emacs 和外部其他程序的粘贴
  (setq x-select-enable-clipboard t)
  ;;使用鼠标中键可以粘贴
  (setq mouse-yank-at-point t)
  ;; 当光标在行尾上下移动的时候，始终保持在行尾。
  (setq track-eol t)
  ;; 当浏览 man page 时，直接跳转到 man buffer。
  (setq Man-notify-method 'pushy)
  (setq select-active-regions t)
  (setq x-gtk-use-system-tooltips nil)    ; disable gtk-tooltip

  (setq max-lisp-eval-depth '40000)
  (setq max-specpdl-size 1000)  ; default is 1000, reduce the backtrace level
  (setq debug-on-error t)    ; now you should get a backtrace
  ;;设置 sentence-end 可以识别中文标点。不用在 fill 时在句号后插入两个空格。
  (setq sentence-end "\\([。！？]\\|……\\|[.?!][]\"')}]*\\($\\|[ \t]\\)\\)[ \t\n]*")
  (setq sentence-end-double-space nil)
#+end_src

#+begin_src emacs-lisp
  ;; nice scrolling
  (setq scroll-margin                   0 )
  (setq scroll-conservatively      100000 )
  (setq scroll-preserve-screen-position 1 )
  (setq scroll-up-aggressively       0.01 )
  (setq scroll-down-aggressively     0.01 )
#+end_src

** 根據作業系統而外進行的初始化設定

*** 在 X11 下將 Caps Lock 變成 Contrl

#+BEGIN_SRC emacs-lisp
  (defun make-caps-as-ctrl ()
    "make capslock as control-key"
    (interactive)
    (shell-command "setxkbmap -option ctrl:nocaps"))

  ;; only disable capslock and make it as control
  (cond ((eq window-system 'x)
         ;; make caps lock a control key
         (make-caps-as-ctrl)))
#+END_SRC
*** 在 Mac OS X 下用 Command 案件替代 ALT

在 Mac OS X 下，我只有將 Control 榜定到 Caps lock 按鍵上面，至於原本
Mac 最常用的 Command 按鍵，在 emacs 下則將他當作是 Alt 按鍵使用，
至於 option 按鍵，則變成 super 按鍵使用。

#+BEGIN_SRC emacs-lisp
   (setq mac-option-modifier 'super)
   (setq mac-command-modifier 'meta)
#+END_SRC

** 設定 custom-file 到其他檔案

避免使用 *customize-UI* 時，會將設定寫入我的 init.el
#+begin_src emacs-lisp
  (setq custom-file emacs-custom-file)
#+end_src

** 啟動 emacs-server

當啟用 emacs 時，啟動 emacs-server，如果使用者是 root 或已啟用 server，則忽略。
#+begin_src emacs-lisp
  ;; Only start server mode if I'm not root
  (unless (string-equal "root" (getenv "USER"))
    (require 'server)
    (unless (server-running-p) (server-start)))
#+end_src

** 根據目前螢幕的解析度調整 emacs 視窗的大小。                  :resolution:

整個設定是使用 cond 來進行條件式的判斷，因此加入了 *設定起始位置* 和 *設定終止位置*
作為保護。

*** 設定起始位置
#+begin_src emacs-lisp
  (cond
#+end_src
*** 1920x1080
#+begin_src emacs-lisp
  (display-1920x1080-p
   (setq default-frame-alist
         (append (list
                  '(width  . 134)
                  '(height . 45)
                  '(top    . 90)
                  '(left   . 500))
                 default-frame-alist)))
#+end_src
*** 1280x1024
#+begin_src emacs-lisp
  (display-1280x1024-p
   (setq default-frame-alist
         (append (list
                  '(width  . 114)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 300))
                 default-frame-alist)))
#+end_src
*** 1280x800
#+begin_src emacs-lisp
  (display-1280x800-p
   (setq default-frame-alist
         (append (list
                  '(width  . 114)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 300))
                 default-frame-alist)))
#+end_src
*** 預設情況
#+begin_src emacs-lisp
  (t
   (setq default-frame-alist
         (append (list
                  '(width  . 100)
                  '(height . 40)
                  '(top    . 90)
                  '(left   . 100))
                 default-frame-alist)))
#+end_src
*** 設定終止位置
#+begin_src emacs-lisp
  )
#+end_src
* 常用的模組 / 函式庫                                               :plugin:

emacs 有一些套件本身不需要配置，或是只是函式庫，這一類的套件我設
定為預先載入，這樣在後面的設定裏面我就可以直接使用這些套件的功能。

若是設定比較簡單的獨立程式也放在這邊。

** 內建套件

有一些內建套件沒有預設載入，這邊將其載入使用。

#+begin_src emacs-lisp
  (require 'misc)
  (require 'cc-mode)
  (require 'frameset nil 'noerror)
#+end_src

iimage 是讓 emacs 可以直接顯示圖片的模式。

#+begin_src emacs-lisp
  (require 'iimage)
#+end_src

** 輸出成 html 檔案

htmlize 是 emacs 一個非常好用的模組，可以讓 emacs 輸出檔案成為
HTML 檔，org-mode 輸出成 html 時也是使用他。

#+begin_src emacs-lisp
  (require 'htmlize)
#+end_src

** 顯示 ascii 表

ascii 是一個很不錯的 ascii 表顯示工具，你可以使用 ascii-on 來啟用
, 他會告訴你目前游標所在位置的 ASCII 碼，使用 ascii-off 可以關閉
ascii-mode。

#+begin_src emacs-lisp
  (require 'ascii)
#+end_src

增加額外的 function，這樣我可以使用 ascii 或是 ascii-toggle 來切換顯示 ascii 表。

#+begin_src emacs-lisp
  (when (featurep 'ascii)
    ;; ascii-toggle
    (defun ascii-toggle ()
      (interactive)
      (if (not (ascii-off)) (ascii-on)))
    ;; alias ascii to ascii-toggle
    (defalias 'ascii 'ascii-toggle))
#+end_src

** 縮短網址

smallurl 是一個很棒的短網址工具，他會幫你到遠端的 server 取得短網址。

#+begin_src emacs-lisp
  (require 'smallurl)
#+end_src

** 快速更改相同的英文字

我們有時候會希望可以快尋尋找某個字，並用新的文字來取代他，iedit-mode
就是做這種事情的好幫手，先將游標停在要尋找取代的文字上，並輸入
M-x iedit-mode 接著就會發現到同個緩衝區裏面所有和游標底下的文字相同的
文字都被標記起來，試著更改看看，你會發現到這些文字同時被更改了。

#+begin_src emacs-lisp
  (require 'iedit)
#+end_src

** 增強 list 處理的 function

dash 提供了更多關於 list 處理用的函式，並且不需依賴 cl.

#+begin_src emacs-lisp
  (require 'dash)
#+end_src

dash 提供了主要以下幾種 list 處理功能

- -map (fn list)

  Returns a new list consisting of the result of applying fn to the items in list.

  #+begin_src emacs-lisp :tangle no
    (-map (lambda (num) (* num num)) '(1 2 3 4)) ;; => '(1 4 9 16)
    (-map 'square '(1 2 3 4)) ;; => '(1 4 9 16)
    (--map (* it it) '(1 2 3 4)) ;; => '(1 4 9 16)
  #+end_src

** 增強 字串 處理的 function

s 提供了許多關於字串處理的函式

#+begin_src emacs-lisp
  (require 's)
#+end_src

** 使用 sequential-command 來整合許多命令

#+begin_src emacs-lisp
  (require 'sequential-command)
#+end_src

sequential-command 這個套件提供了整合多個命令到一個命令的能力，透過這
個套件，你可以使用下面的方式，定義一個名為 my-end 的命令，這個命令整合
了 end-of-line 以及 end-of-buffer 兩個命令。

#+begin_src emacs-lisp :tangle no
  (define-sequential-command my-end  end-of-line end-of-buffer)
#+end_src

定義完 my-end 後，我們將他綁到 C-e 上

#+begin_src emacs-lisp :tangle no
  (global-set-key "\C-e" 'my-end)
#+end_src

當你敲下第一次 C-e 的時候，你實際上執行的是 *end-of-line* 這個命令，如
果你想要執行 end-of-buffer 這個命令的話，使用 C-e C-e 就可以辦到。

想要看更多的例子，可以見以下連結:

http://www.emacswiki.org/cgi-bin/wiki/download/sequential-command-config.el

** 使用 unicad 讓 emacs 自動識別檔案編碼

#+begin_src emacs-lisp
  (require 'unicad)
#+end_src

** 使用 doc-present 來播放 PDF 投影片                                  :pdf:

#+BEGIN_SRC emacs-lisp
  (require 'doc-present)
  (setq doc-view-resolution 300)
#+END_SRC

** 透過 Paredit 來簡化 Lisp 類語言編輯                             :paredit:

[[http://www.emacswiki.org/emacs/ParEdit][ParEdit]] 是一個非常好用的括號批配模式，特別是在寫 lisp 程式的時候，使用
paredit 可以幫助傳寫程式的速度。

這邊設定部分我會用到的 paredit 函數，完整的按鍵綁定則在 [[*%E4%BD%BF%E7%94%A8%20paredit%20%E4%BE%86%E7%B0%A1%E5%8C%96%E6%8B%AC%E8%99%9F%E7%9A%84%E6%93%8D%E4%BD%9C][使用 paredit 來簡化括號的操作]]

- 載入 paredit 套件

  #+BEGIN_SRC emacs-lisp
    (require 'paredit)
  #+END_SRC

- 關閉 paredit 預設的閃爍同級括號功能

  #+BEGIN_SRC emacs-lisp
    (defun paredit-blink-paren-match (another-line-p)
      "redefine this function, i don't like paredit to blikn math paren")
  #+END_SRC

- 將 hungry-delete 功能加入到 paredit

  #+BEGIN_SRC emacs-lisp
    (defadvice paredit-backward-delete (around paredit-backward-delete activate)
      "Intergrated paredit-backward-delete with hungry-delete."
      ad-do-it
      (when (featurep 'hungry-delete)
        (if (eq (char-before) ?\s)
            (hungry-delete-backward))))

    (defadvice paredit-forward-delete (around paredit-forward-delete activate)
      "Intergrated paredit-forward-delete with hungry-delete."
      ad-do-it
      (when (featurep 'hungry-delete)
        (if (eolp)
            (hungry-delete-forward))))
  #+END_SRC

** TODO lusty-explorer

*** 載入相關套件

#+begin_src emacs-lisp
  (require 'lusty-explorer)
#+end_src

*** 使用 <ENTER> 選擇目前的檔案

#+begin_src emacs-lisp
  (add-hook 'lusty-setup-hook
            '(lambda ()
               (define-key lusty-mode-map (kbd "RET") 'lusty-select-current-name)))
#+end_src

*** 讓 lusty-explorer 能夠使用 sudo 來打開檔案                    :command:

#+begin_src emacs-lisp
  (defun lusty-sudo-explorer ()
    "Launch the file/directory mode of LustyExplorer."
    (interactive)
    (let ((lusty--active-mode :file-explorer)
          (lusty-prompt "sudo: >>"))
      (lusty--define-mode-map)
      (let* ((lusty--ignored-extensions-regex
              (concat "\\(?:" (regexp-opt completion-ignored-extensions) "\\)$"))
             (minibuffer-local-filename-completion-map lusty-mode-map)
             (file
              (lusty--run 'read-file-name default-directory "")))
        (when file
          (switch-to-buffer
           (find-file-noselect (concat "/sudo:root@localhost:"
                                       (expand-file-name file))))))))
#+end_src

*** 讓 lusty-explorer 使用自己的補全方式，而不是 helm 的補全方式

當 helm-mode 載入完後，將和 lusty-explorer 相關的命令加入至 helm-completing-read-handlers-alist，
以避免 lusty-explorer 使用 helm-mode 提供的補全方法。
#+begin_src emacs-lisp
  (eval-after-load "helm-mode"
    '(progn
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-sudo-explorer . nil))
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-file-explorer . nil))
       (add-to-list 'helm-completing-read-handlers-alist '(lusty-buffer-explorer . nil))))
#+end_src

** TODO elscreen                                                  :elscreen:
*** 載入相關模組

#+begin_src emacs-lisp
  (require 'elscreen)
#+end_src

*** 自動啟用 elscreen

#+begin_src emacs-lisp
  (elscreen-start)
#+end_src

*** 分頁上顯示 *控制* 圖示

#+begin_src emacs-lisp
  (setq elscreen-tab-display-control t)
#+end_src

*** 分頁上不顯示 *關閉* 圖示

#+begin_src emacs-lisp
  (setq elscreen-tab-display-kill-screen nil)
#+end_src

*** 功能強化

當目前只有一個 elscreen-tab 存在時，呼叫 *elscreen-next* 、 *elscreen-previous*
或是 *elscreen-toggle* 會自動建立另外一個 elscreen-tab。
#+begin_src emacs-lisp
  (defmacro elscreen-create-automatically (ad-do-it)
    (` (if (not (elscreen-one-screen-p))
           (, ad-do-it)
         (elscreen-create)
         (elscreen-notify-screen-modification 'force-immediately)
         (elscreen-message "New screen is automatically created"))))

  (defadvice elscreen-next (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))

  (defadvice elscreen-previous (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))

  (defadvice elscreen-toggle (around elscreen-create-automatically activate)
    (elscreen-create-automatically ad-do-it))
#+end_src

** TODO 其他
#+begin_src emacs-lisp
  (require 'rainbow-mode)
  ;;(require 'smarter-compile)
  (require 'expand-region)
#+end_src

** TODO ibuffer                                                    :ibuffer:
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'ibuffer)
  (require 'ibuf-ext)
#+end_src
*** Config
#+begin_src emacs-lisp
  ;;;; Settings
  (setq ibuffer-always-compile-formats         t )
  (setq ibuffer-default-shrink-to-minimum-size t )
  (setq ibuffer-expert                         t )
  (setq ibuffer-show-empty-filter-groups     nil )
  (setq ibuffer-use-other-window             nil )
  (setq ibuffer-always-show-last-buffer      nil )
#+end_src
integrate ibuffer with git
#+begin_src emacs-lisp
  (require 'ibuffer-git)
  (setq ibuffer-formats
        '((mark modified read-only git-status-mini " "
                (name 23 23 :left :elide)
                " "
                (size-h 9 -1 :right)
                "  "
                (mode 16 16 :left :elide)
                " "
                (git-status 8 8 :left)
                "    "
                ;;              (eproject 16 16 :left :elide)
                ;;              "      "
                filename-and-process)))
#+end_src
buffer list
#+begin_src emacs-lisp
  ;;;; buffer-list
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("*Buffer*" (or
                        (name . "^TAGS\\(<[0-9]+>\\)?$")
                        (name . "^\\**Loading Log\\*$")
                        (name . "^\\*coldnew/filelist\\*$")
                        (name . "^\\*Backtrace\\*$")
                        (name . "^\\*Buffer List\\*$")
                        (name . "^\\*CEDET Global\\*$")
                        (name . "^\\*Compile-Log\\*$")
                        (name . "^\\*Completions\\*$")
                        (name . "^\\*EGG:*")
                        (name . "^\\*Kill Ring\\*$")
                        (name . "^\\*Occur\\*$")
                        (name . "^\\*Customize*")
                        (name . "^\\*Process List\\*$")
                        (name . "^\\*Shell Command Output\\*")
                        (name . "^\\*Warnings\\*$")
                        (name . "^\\*compilation\\*$")
                        (name . "^\\*el-get*")
                        (name . "^\\*grep\\*$")
                        (name . "^\\*gud\\*$")
                        (name . "^\\*ielm\\*")
                        (name . "^\\*im.bitlbee.org\\*$")
                        (name . "^\\*scratch\\*$")
                        (name . "^\\*tramp")
                        (name . "^\\*wclock\\*$")
                        (name . "^ipa*")
                        (name . "^loaddefs.el$")
                        (name . "^\\*Messages\\*$")
                        (name . "^\\*WoMan-Log\\*$")
                        ))
           ("Version Control" (or (mode . svn-status-mode)
                                  (mode . svn-log-edit-mode)
                                  (name . "^\\*svn*\\*")
                                  (name . "^\\*vc*\\*$")
                                  (name . "^\\*Annotate")
                                  (name . "^\\*git-*")
                                  (name . "^\\*cvs*")
                                  (name . "^\\*vc-*")
                                  (mode . egg-status-buffer-mode)
                                  (mode . egg-log-buffer-mode)
                                  (mode . egg-commit-buffer-mode)))
           ("Help" (or (mode . woman-mode)
                       (mode . man-mode)
                       (mode . info-mode)
                       (mode . help-mode)
                       (name . "\\*Help\\*$")
                       (name . "\\*info\\*$")))
           ("Dired" (or (mode . dired-mode)
                        (mode . nav-mode)))
           ("IRC"   (or (mode . erc-mode)
                        (mode . rcirc-mode)))
           ("Jabber" (or (mode . jabber-roster-mode)
                         (mode . jabber-chat-mode)))
           ("Terminal" (or (mode . eshell-mode)
                           (mode . term-mode)
                           (mode . inferior-python-mode)
                           (mode . eshell-mode)
                           (mode . comint-mode)
                           (name . "\\*scheme\\*$")))
           ("Config" (name . "*.conf$"))
           ("Text" (or (mode . text-mode)
                       (name . "*.txt$")))
           ("w3m"   (or (mode . w3m-mode)
                        (name . "^\\*w3m*")))
           ("Org"   (mode . org-mode))
           ("LaTEX" (or (mode . latex-mode)
                        (name . "*.tex$")))
           ("Verilog" (mode . verilog-mode))
           ("Web Develop" (or (mode . html-mode)
                              (mode . css-mode)))
           ("Shell Script" (or (mode . shell-script-mode)
                               (mode . shell-mode)
                               (mode . sh-mode)
                               (mode . ruby-mode)))
           ("Perl"  (or (mode . cperl-mode)
                        (mode . perl-mode)))
           ("Python" (or (mode . python-mode)
                         (mode . ipython-mode)))
           ("Octave" (or (mode . octave-mode)
                         (mode . inferior-octave-mode)))
           ("Scala" (or (mode . scala-mode)
                        (name . "\\*inferior-scala\\*$")))
           ("Diff" (mode . diff-mode))
           ;;      ("Project" (mode . qmake-mode))
           ("JavaScript" (or (mode . js-mode)
                             (mode . js2-mode)))
           ("C++ . C#" (or (mode . c++-mode)
                           (mode . csharpmode)))
           ("C"          (mode . c-mode))
           ("Object-C"   (mode . objc-mode))
           ("Snippet" (or (mode . snippet-mode)
                          (name . "*.yas$")))
           ("newLisp"  (mode . newlisp-mode))
           ("Common Lisp"   (mode . slime-mode))
           ("Scheme"  (or (mode . scheme-mode)
                          (mode . gambit-mode)))
           ("Clojure" (or (mode . clojure-mode)
                          (name . "\\*slime-repl clojure\\*")))
           ("Emacs recipes" (name . "*.rcp$"))
           ("Emacs" (or (mode . emacs-lisp-mode)
                        (mode . lisp-interaction-mode)
                        ))
           )))
#+end_src
Following buffer will not show in iBuffer
#+begin_src emacs-lisp
  (setq ibuffer-never-show-predicates
        (list
         "^\\*Buffer List\\*$"
         "^\\*CEDET Global\\*$"
         "^\\*MiniBuf-*"
         "^\\*Egg:Select Action\\*$"
         "^\\*Ido Completions\\*$"
         "^\\*SPEEDBAR\\*$"
         "^\\*nav\\*$"
         "^\\*swank\\*$"
         "^\\*slime-events\\*$"
         "^\\*RE-Builder\\*$"
         "^\\*pomodoro\\*$"
         "^\\*Project Buffers\\*$"
         "^eproject$"
         "\\*fsm-debug\\*$"
         ;; "^"
         "^\\*.*\\(-preprocessed\\)\\>\\*"
         "^\\*ORG.*\\*"
         "^\\*ac-mode-*"
         ".loaddefs.el$"
         "^loaddefs.el$"
         "\\*GTAGS SELECT\\**"
         "\\*Symref*"
         "\\*cscope\\*"
         "\\*helm*"
         ))
#+end_src
*** Advice
#+begin_src emacs-lisp
  ;;;; Advice
  ;; Reverse group list
  (defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups () activate)
    (setq ad-return-value (nreverse ad-return-value)))

  ;; Switching to ibuffer puts the cursor on the most recent buffer
  (defadvice ibuffer (around ibuffer-point-to-most-recent activate)
    "Open ibuffer with cursor pointed to most recent buffer name"
    (let ((recent-buffer-name (buffer-name)))
      ad-do-it
      (ibuffer-jump-to-buffer recent-buffer-name)))

  ;; Kill ibuffer after quit
  (defadvice ibuffer-quit (after kill-ibuffer activate)
    "Kill the ibuffer buffer on exit."
    (kill-buffer "*Ibuffer*"))
#+end_src
*** Keybindings
#+begin_src emacs-lisp
  (define-key ibuffer-mode-map (kbd "C-x C-f") 'lusty-file-explorer)
#+end_src
*** Functions
#+begin_src emacs-lisp
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000) (format "%7.3fK" (/ (buffer-size) 1000.0)))
     ((> (buffer-size) 1000000) (format "%7.3fM" (/ (buffer-size) 1000000.0)))
     (t (format "%8dB" (buffer-size)))))
#+end_src
*** Hooks
**** enable highlight-line
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook 'hl-line-mode)
#+end_src
**** setting default group
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook '(lambda () (ibuffer-switch-to-saved-filter-groups "default")))
#+end_src
**** sort filename automatically
#+begin_src emacs-lisp
  (add-hook 'ibuffer-mode-hook 'ibuffer-do-sort-by-filename/process)
#+end_src
** TODO speedbar
#+begin_src emacs-lisp
  (require 'speedbar)
  (setq speedbar-use-images nil)
  (require 'sr-speedbar)
  (setq sr-speedbar-right-side nil)
  (setq sr-speedbar-refresh-turn-on t)
#+end_src
** TODO cua                                                            :cua:
#+begin_src emacs-lisp
  (require 'cua-base)
  (require 'cua-rect)
  ;; don't add C-x, C-c, C-v
  (setq cua-enable-cua-keys nil)
  (setq cua-rectangle-mark-key (kbd "C-c RET"))
  ;; Enable cua-mode
  (cua-mode t)

  (cua--init-rectangles)
  (cua--rect-M/H-key ?n   'cua-scroll-up)
  (cua--rect-M/H-key ?N   'cua-sequence-rectangle)
  (cua--rect-M/H-key ?p   'cua-scroll-down)
#+end_src
** TODO slime
#+begin_src emacs-lisp
  (require 'slime)
  (require 'ac-slime)
  ;; Save REPL history to emacs-cache-dir
  (setq slime-repl-history-file (concat emacs-cache-dir "slime-hist.dat"))

  ;; REPL history size set to 300
  (setq slime-repl-history-size 300)

  ;; Use global programming mode
  (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
#+end_src
** TODO uniquify

#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'reverse)
  (setq uniquify-separator "|")
  (setq uniquify-after-kill-buffer-p 1)
  (setq uniquify-ignore-buffers-re "^\\*")
#+end_src
* 自定義函式 / 方法                                                :function:

我所自定義或是我的 emacs 設定檔需要用到的 function。

** 排序
*** 使用正規表達式排序行

#+begin_src emacs-lisp
  (defun sort-lines-regex (reg)
    "This is a function to sort lines by regex,
  which are placing near by each other."
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (re-search-forward reg)
      (let ((point (point-to-beginnnig-line)))
        (while (re-search-forward reg nil t))
        (sort-lines nil point (point)))))
#+end_src

*** 快速排序

#+begin_src emacs-lisp
  (defun quicksort (lst)
    "Implement the quicksort algorithm."
    (if (null lst) nil
      (let* ((spl (car lst))
             (rst (cdr lst))
             (smalp (lambda (x)
                      (< x spl))))
        (append (quicksort (remove-if-not smalp rst))
                (list spl)
                (quicksort (remove-if smalp rst))))))
#+end_src

** 測試檔案、變數值

測試用的 function，和測試用的變數很像，但是他允許參數的輸入。

*** 測試這個字體在系統內是否存在。

#+begin_src emacs-lisp
  (defun font-exist-p (fontname)
    "test if this font is exist or not."
    (if (or (not fontname) (string= fontname ""))
        nil
    (if (not (x-list-fonts fontname))
          nil t)))
#+end_src

** 檔案相關

*** 查詢檔案大小

#+begin_src emacs-lisp
  (defun file-size (filename)
    "Return the size in bytes of file named FILENAME, as in integer.
  Returns nil if no such file."
    (nth 7 (file-attributes filename)))
#+end_src

*** 大量打開檔案

#+begin_src emacs-lisp
  (defun find-files (files)
    "Open the given files"
    (foreach (f files) (find-file f)))
#+end_src

*** 遞迴尋找檔案

若在當前目錄找不到此檔案，則去其父目錄進行尋找。
如果該檔案或是目錄不存在，則回傳 nil.

#+begin_src emacs-lisp
  (defun recursive-find-file (file &optional directory)
    "Find the first FILE in DIRECTORY or it's parents.
  If file does not exist return nil."
    (let ((directory (or directory
                         (file-name-directory (buffer-file-name))
                         (pwd))))
      (if (file-exists-p (expand-file-name file directory))
          (expand-file-name file directory)
        (unless (string= "/" directory)
          (recursive-find-file file (expand-file-name ".." directory))))))
#+end_src

** 系統相關

和系統相關的 function。

*** 取得目前的 IP 位址

取得目前的 IP 位置，預設為 eth0。（此 function 不能用於 windows 上）

#+begin_src emacs-lisp
  (defun get-ip-address (&optional dev)
    "get the IP-address for device DEV (default: eth0)"
    (let ((dev (if dev dev "eth0")))
      (format-network-address (car (network-interface-info dev)) t)))
#+end_src

** 檔案/字串/數值轉換

進行轉換用的 function。

*** 將輸入的 buffer (DOS 格式)　轉換成 UNIX 格式。　

#+begin_src emacs-lisp
  (defun dos->unix (buf)
    "Convert buffer file from dos file to unix file."
    (let* (current-buf (current-buffer))
      (if (not (eq current-buf buf))
          (switch-to-buffer buf))
      (goto-char(point-min))
      (while (search-forward "\r" nil t) (replace-match ""))))
#+end_src

*** 將輸入的 buffer (UNIX 格式)　轉換成 DOS 格式。　

#+begin_src emacs-lisp
  (defun unix->dos (buf)
    "Convert buffer file from unix file to dos file."
    (let* (current-buf (current-buffer))
      (if (not (eq current-buf buf))
          (switch-to-buffer buf))
      (goto-char(point-min))
      (while (search-forward "\n" nil t) (replace-match "\r\n"))))
#+end_src

*** 將檔案變成字串

此 function 比較適用於該檔案只有一行（或少數幾行）的情況。
#+begin_src emacs-lisp
  (defun file->string (file)
    "Convert file to string in buffer with quote."
    (when (file-readable-p file)
      (with-temp-buffer
        (insert-file-contents file)
        (buffer-string))))
#+end_src

*** 十進位轉換成十六進位

#+begin_src emacs-lisp
  (defun dec->hex (decimal)
    "Convert decimal to hexdecimal number."
    (let ((hexstr))
      (if (stringp decimal)
          (setq decimal (string-to-number decimal 16)))
      (cond
       ;; Use #x as hex prefix (elisp, ....)
       ((or (eq major-mode 'emacs-lisp-mode)
            (eq major-mode 'lisp-interaction-mode)) (setq hexstr "#x"))
       ;; Use # as hex prefix (CSS, ....)
       ((eq major-mode 'css-mode) (setq hexstr "#"))
       ;; otherwise use 0x as hexprefix (C, Perl...)
       (t (setq hexstr "0x")))
      (format "%s%02X" hexstr decimal)))
#+end_src

*** 十六進位轉換成十進位

#+begin_src emacs-lisp
  (defun hex->dec (hex)
    "Convert hexdecimal number or string to digit-number."
    (let ((case-fold-search nil)
          (hex-regexp (rx (or
                           ;; elisp
                           (group bol "#x")
                           ;; C perl
                           (group bol "0x")
                           ;; CSS
                           (group bol "#")))))
      (if (not (stringp hex))
          (setq hex (symbol-name hex)))
      (string-to-number
       (replace-regexp-in-string hex-regexp "" hex)
       16)))
#+end_src

** 鏈表 (list) 處理

處理 List 所用的 function，有些功能 dash.el 也有提供。

*** 將一個 list 變成字串回傳

#+begin_src emacs-lisp
  (defun list->string (char-list)
    "RETURN: A new string containing the characters in char-list."
    (let ((result (make-string (length char-list) 0))
          (i 0))
      (dolist (char char-list)
        (aset result i char)
        (setq i (1+ i)))
      result))
#+end_src

** 緩衝區相關

*** 取得 major-mode 和要求符合的所有 buffer

假如我們希望可以列出所有為 emacs-lisp-mode 的 buffer，可以這樣做

#+begin_src emacs-lisp :tangle no
  (get-buffers-matching-mode 'emacs-lisp-mode)
#+end_src

#+begin_src emacs-lisp
  (defun get-buffers-matching-mode (mode)
    "Returns a list of buffers where their major-mode is equal to MODE"
    (let ((buffer-mode-matches '()))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (if (eq mode major-mode)
              (add-to-list 'buffer-mode-matches buf))))
      buffer-mode-matches))
#+end_src

*** 顯示 buffer 目前所處於的 major-mode

#+begin_src emacs-lisp :tangle no
  (show-buffer-major-mode "*scratch*")
#+end_src

#+begin_src emacs-lisp
  (defun show-buffer-major-mode (buffer-or-string)
    "Returns the major mode associated with a buffer."
    (with-current-buffer buffer-or-string major-mode))
#+end_src

** 尋找、取代

*** 向後搜尋一個字元

#+begin_src emacs-lisp
  (defun search-backward-to-char (chr)
    "Search backwards to a character"
    (while (not (= (char-after) chr))
      (backward-char 1)))
#+end_src

*** 向前搜尋一個字元

#+begin_src emacs-lisp
  (defun search-forward-to-char (chr)
    "Search forwards to a character"
    (while (not (= (char-before) chr))
      (forward-char 1)))
#+end_src

** TODO 需整理
*** List Processing
**** flatten a list

flatten a list 是一種方法，可以用來將巢狀的 list 變成單一個 list。
舉例來說，假如目前有這樣一個 list:

#+begin_example
(1 (2 3) (4 (5 6 (7))) 8 9)
#+end_example

則使用 flatten 這個 function 可以將上面的巢狀 list 變成:

#+begin_example
(1 2 3 4 5 6 7 8 9)
#+end_example

#+begin_src emacs-lisp
  (defun flatten (structure)
    "Flatten the nesting in an arbitrary list of values."
    (cond ((null structure) nil)
          ((atom structure) `(,structure))
          (t (mapcan #'flatten structure))))
#+end_src

*** Date
#+begin_src emacs-lisp
  (defun current-date-time ()
    "return current date in `%Y-%m-%d' format, ex:`2012-04-25'."
    (let ((system-time-locale "en_US")
          (format "%Y-%m-%d"))
      (format-time-string "%Y-%m-%d")))

  (defun day-of-week (year month day)
    "Returns the day of the week as an integer.
     Monday is 1."
    (nth 6 (decode-time (encode-time 0 0 0 day month year))))

  (defun day-of-week-in-string (year month day)
    "Return the day of the week as day name."
    (let* ((day-names '("Sunday" "Monday" "Tuesday" "Wednesday"
                        "Thursday" "Friday" "Saturday"))
           (day-index (nth 6 (decode-time (encode-time 0 0 0 day month year)))))
      (nth day-index day-names)))
#+end_src
*** other
#+begin_src emacs-lisp
  (defun map-define-key (mode-map keylist fname)
    "Like define-key but the key arg is a list that should be mapped over.
     For example: (map-define-key '(a b c d) 'function-name)."
    (mapc (lambda (k) (define-key mode-map k fname))
          keylist))

  ;;;; ---------------------------------------------------------------------------
  ;;;; Region
  ;;;; ---------------------------------------------------------------------------
  (defun select-region-to-before-match (match &optional dir)
    "Selects from point to the just before the first match of
  'match'.  The 'dir' controls direction, if nil or 'forwards then
  go forwards, if 'backwards go backwards."
    (let ((start (point))
          (end nil))

      (transient-mark-mode 1)    ;; Transient mark
      (push-mark)                ;; Mark the start, where point is now

      (if (or (null dir)
              (equalp 'forwards dir))

          ;; Move forwards to the next match then back off
          (progn
            (search-forward match)
            (backward-char))

        ;; Or search backwards and move forwards
        (progn
          (search-backward match)
          (forward-char)))

      ;; Store, then hilight
      (setq end (point))
      (exchange-point-and-mark)

      ;; And return, swap the start/end depending on direction we're going
      (if (or (null dir)
              (equalp 'forwards dir))
          (list start end)
        (list end start))))
#+end_src
* 字體設置                                                             :font:

** 英文字體與中文字體設置

- 英文字體

  #+begin_src emacs-lisp
    (defvar emacs-english-font "Monaco"
      "The font name of English.")
  #+end_src

- 中文字體

  #+begin_src emacs-lisp
    (defvar emacs-cjk-font "Hiragino Sans GB W3"
      "The font name for CJK.")
  #+end_src

** 預設字體大小設定

為了可以在 org-mode 的表格中縮放字體也不會有中英文排版亂掉的情況，我的
字體設定是以 pair 的形式來進行設定，*emacs-font-size-pair* 存放預設的
字體，若有使用我自訂的字體放大/縮小命令，則這個變數也會更著被修改。

#+BEGIN_SRC emacs-lisp
  (defvar emacs-font-size-pair '(15 . 18)
    "Default font size pair for (english . chinese)")
#+END_SRC

** 在圖形介面下使用我所設定的字體

這邊主要定義 *set-font* 這個函式，他會根據傳送給他的字體資訊，即時設定
整個 emacs 的字體大小，這樣也不會有切換 buffer，但是字體確沒有跟著之前的
設定而變大/變小。

#+BEGIN_SRC emacs-lisp
  (defun set-font (english chinese size-pair)
    "Setup emacs English and Chinese font on x window-system."

    (if (font-exist-p english)
        (set-frame-font (format "%s:pixelsize=%d" english (car size-pair)) t))

    (if (font-exist-p chinese)
        (dolist (charset '(kana han cjk-misc bopomofo))
          (set-fontset-font (frame-parameter nil 'font) charset
                            (font-spec :family chinese :size (cdr size-pair))))))

  ;; Setup font size based on emacs-font-size-pair
  (set-font emacs-english-font emacs-cjk-font emacs-font-size-pair)
#+END_SRC

** 使用 C-= 或是 C-- 來調整字體大小

這邊設定了一個 *emacs-font-size-pair-list* 變數，這個變數存放了即使使
用這一對字體大小，org-mode 的表格也不會走樣的中英字體設定。

#+BEGIN_SRC emacs-lisp
  (defvar emacs-font-size-pair-list
    '(( 5 .  6) (10 . 12)
      (13 . 16) (15 . 18) (17 . 20)
      (19 . 22) (20 . 24) (21 . 26)
      (24 . 28) (26 . 32) (28 . 34)
      (30 . 36) (34 . 40) (36 . 44))
    "This list is used to store matching (englis . chinese) font-size.")

  (defun emacs-step-font-size (step)
    "Increase/Decrease emacs's font size."
    (let ((scale-steps emacs-font-size-pair-list))
      (if (< step 0) (setq scale-steps (reverse scale-steps)))
      (setq emacs-font-size-pair
            (or (cadr (member emacs-font-size-pair scale-steps))
                emacs-font-size-pair))
      (when emacs-font-size-pair
        (message "emacs font size set to %.1f" (car emacs-font-size-pair))
        (set-font emacs-english-font emacs-cjk-font emacs-font-size-pair))))

  (defun increase-emacs-font-size ()
    "Decrease emacs's font-size acording emacs-font-size-pair-list."
    (interactive) (emacs-step-font-size 1))

  (defun decrease-emacs-font-size ()
    "Increase emacs's font-size acording emacs-font-size-pair-list."
    (interactive) (emacs-step-font-size -1))

  (global-set-key (kbd "C-=") 'increase-emacs-font-size)
  (global-set-key (kbd "C--") 'decrease-emacs-font-size)
#+END_SRC

** 設定顯示字體時的格式

使用 *list-face-display* 可以看到所有的 face 顏色與字體。

#+begin_src emacs-lisp
  (setq list-faces-sample-text
        (concat
         "ABCDEFTHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz\n"
         "11223344556677889900       壹貳參肆伍陸柒捌玖零"))
#+end_src

* 佈景主題                                                            :theme:

佈景主題的設置，包含我自訂的佈景主題以及路徑。
** 設定佈景主題的位置。

佈景主題的路徑設定在 emacs-themes-dir 裡面。
#+begin_src emacs-lisp
  (setq custom-theme-directory emacs-themes-dir)
#+end_src

** 設定額外的佈景主題變數

#+begin_src emacs-lisp
  (defface evil-state-normal-face
    '((t (:inherit font-lock-function-name-face)))
    "face for vim-string in normal-map on mode-line."
    :group 'mode-line)

  (defface evil-state-insert-face
    '((t (:inherit font-lock-constant-face)))
    "face for vim-string in insert-map on mode-line."
    :group 'mode-line)

  (defface evil-state-visual-face
    '((t (:inherit font-lock-variable-name-face)))
    "face for vim-string in visual-map on mode-line."
    :group 'mode-line)

  (defface evil-state-emacs-face
    '((t (:inherit font-lock-string-face)))
    "face for vim-string in emacs-map on mode-line."
    :group 'mode-line)

  (defface mode-line-read-only-face
    '((t (:foreground "#C82829" :bold t)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface mode-line-modified-face
    '((t (:inherit 'font-lock-function-name-face :bolt t)))
    "face for mode-name-string in modeline."
    :group'mode-lin)

  (defface mode-line-mode-name-face
    '((t (:inherit font-lock-keyword-face)))
    "face for mode-name-string in modeline."
    :group 'mode-line)

  (defface font-lock-escape-char-face
    '((((class color)) (:foreground "seagreen2")))
    "highlight c escapes char like vim"
    :group 'font-lock-faces)
#+end_src

** 設定預設讀取的佈景主題。

這邊載入我新設計的佈景主題。

#+begin_src emacs-lisp
  (require 'coldnew-theme)
  ;; TODO: use following to read theme
  ;;(load-theme 'coldnew-theme-night t)
  (coldnew-theme--define-theme night)
#+end_src

* Vim 摹擬                                                              :vim:

實在不能不佩服 vi 系列按鍵使用的高效率，將許多常用的巨集綁到一個按鍵上，
只要一個按鍵就可以呼叫，為了提升編輯效率，套用一些 Vim 的按鍵也是再所難免。

好用的 vim 快速鍵組合[fn:1]：

- d/foo[RET] 從目前的游標位置刪除到字串 foo
- dfa        從目前的游標位置刪除到字元 a，包含 a 本身
- cta        從目前的游標位置刪除到字元 a，不包含 a 本身
- viw        將目前游標所在的 "字" 選擇起來
- vfa        從目前的游標位置選擇到字元 a，包含 a 本身
- yi)        複製括號內的東西，不包含括號本身
- di"        刪除雙引號內的文字

[fn:1] [[http://dnquark.com/blog/2012/02/emacs-evil-ecumenicalism/][Emacs + Evil = ecumenicalism]]

** 載入相關套件

Evil 是 emacs 上最好用的 vim 摹擬程式。

#+begin_src emacs-lisp
  (require 'evil)
#+end_src

** 基本設置

- 讓游標使用佈景主題的顏色

  evil-mdoe 預設會讓游標變成黑色，這對於習慣使用暗色系佈景主題的
  使用者而言是一件很討厭的事情，設定 evil-default-cursor 為 true
  後就可以使用使用者自訂的佈景主題來改變滑鼠了。

  #+begin_src emacs-lisp
     (setq evil-default-cursor t)
  #+end_src

** 預設使用 Insert state

為什麼要預設使用 Insert 模式？我記得曾經我放棄過一次 evil-mode，因為切換到不同模式時，
他會跑到我不喜歡的 state，比如 Normal-state，這樣讓我感到很煩，每次到新的 mode 就要加他加入到
evil-mode 的變數，讓他知道這個 mode 預設是用什麼 state，煩死了。

直接統一用 insert 模式比較快 :)

準備移植到 evil normal state

#+begin_src emacs-lisp
  (setq evil-default-state 'insert)
;;  (setq evil-default-state 'normal)
#+end_src

#+begin_src emacs-lisp
    (setq evil-motion-state nil)
  (setq evil-emacs-state-modes nil)

  ;;evil-motion-state-modes
#+end_src

** 將 Emacs 按鍵綁到 Insert 模式上

對我而言，Vim 的 Insert 模式是趨近於無用的，這邊將我的 Emacs 模式下的按鍵綁到
Insert 模式上，之後再來做其他設置。

#+begin_src emacs-lisp
  (setcdr evil-insert-state-map nil)
  (define-key evil-insert-state-map
    (read-kbd-macro evil-toggle-key) 'evil-emacs-state)
#+end_src

將 ESC 綁定成切換為 normal-state-map，因為我用自己的 emacs 按鍵綁定蓋掉了 evil-mode
裡面的 insert-state 按鍵綁定，所以這邊要先加入這個設定，才能夠用 ESC 來切換到
normal-state。

注意到除了 ESC 按鍵本身，使用 C-[ 也具有 ESC 按鍵的效果。

#+begin_src emacs-lisp
  (define-key evil-insert-state-map [escape] 'evil-normal-state)
#+end_src

** 全域性啟用 evil-mode

#+begin_src emacs-lisp
  (evil-mode t)
#+end_src

** 讓 evil-mode 的區域選擇方式和 Vim 相同

在 emacs 中，最後一個被選擇的字元是游標的前一個字元，但是在 vim 中，卻是在游標
下的那個字元。

若要使用和 vim 相同的方式，則要進行下面的設定:

#+begin_src emacs-lisp
  (setq evil-want-visual-char-semi-exclusive t)
#+end_src

** 綁定按鍵好用的巨集

我很喜歡以前用 vim-mode 時的按鍵定義方式，所以我定義了以下巨集來簡化
綁定按鍵的方法。

全域性的按鍵設置

- vim:nmap 綁定按鍵到 Normal 狀態下
- vim:imap 綁定按鍵到 Insert 狀態下
- vim:vmap 綁定按鍵到 Visual 狀態下
- vim:wmap 綁定按鍵到窗口切換的按鍵
- vim:map  綁定按鍵到 Normal, Insert 狀態下

使用方式：

: (vim:nmap (kbd "g") 'linum-ace-jump)

這樣在 Normal-state 時，按下 g 就可以呼叫 linum-ace-jump 這個命令。

#+begin_src emacs-lisp
  (defmacro vim:nmap (key cmd)
    "Binding keymap to evil-normal-state."
    `(define-key evil-normal-state-map ,key ,cmd))
  (defmacro vim:imap (key cmd)
    "Binding keymap to evil-insert-state."
    `(define-key evil-insert-state-map ,key ,cmd))
  (defmacro vim:vmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-visual-state-map ,key ,cmd))
  (defmacro vim:wmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-window-map ,key ,cmd))

  (defmacro vim:map (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-normal-state-map ,key ,cmd)
    `(define-key evil-insert-state-map ,key ,cmd))
#+end_src

區域性的按鍵設置

- vim:local-nmap 綁定按鍵到 Normal 狀態下，只作用於該緩衝區
- vim:local-imap 綁定按鍵到 Insert 狀態下，只作用於該緩衝區
- vim:local-vmap 綁定按鍵到 Visual 狀態下，只作用於該緩衝區

使用方式：

: (vim:local-nmap (kbd "g") 'linum-ace-jump)

這樣在目前的緩衝區時時， 切到 Normal-state，按下 g 就可以呼叫 linum-ace-jump 這個命令。

注意到這個是屬於 buffer-local 的設定方式，只會影響到該緩衝區，而不是影響整個 mode。

#+begin_src emacs-lisp
  (defmacro vim:local-nmap (key cmd)
    "Binding keymap to evil-normal-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
  (defmacro vim:local-imap (key cmd)
    "Binding keymap to evil-insert-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
  (defmacro vim:local-vmap (key cmd)
    "Binding keymap to evil-visual-state."
    `(define-key evil-visual-state-local-map ,key ,cmd))
#+end_src

根據模式進行按鍵設置

- vim:mode-nmap 綁定按鍵到 Normal 狀態下，只作用於特定模式
- vim:mode-imap 綁定按鍵到 Insert 狀態下，只作用於特定模式
- vim:mode-vmap 綁定按鍵到 Visual 狀態下，只作用於特定模式
- vim:mode-map  綁定按鍵到 Normal, Insert 狀態下

使用方式：

: (vim:mode-nmap emacs-lisp-mode-map (kbd "g") 'linum-ace-jump)

這樣在 emacs-lisp-mode 時， 切到 Normal-state，按下 g 就可以呼叫 linum-ace-jump 這個命令。

#+begin_src emacs-lisp
  (defmacro vim:mode-nmap (map key cmd)
    "Binding keymap to evil-normal-state."
    `(evil-define-key 'normal ,map ,key ,cmd))
  (defmacro vim:mode-imap (map key cmd)
    "Binding keymap to evil-insert-state."
    `(evil-define-key 'insert ,map ,key ,cmd))
  (defmacro vim:mode-vmap (map key cmd)
    "Binding keymap to evil-visual-state."
    `(evil-define-key 'visual ,map ,key ,cmd))

  (defmacro vim:mode-map (map key cmd)
    "Binding keymap to evil-visual-state."
    `(evil-define-key 'normal ,map ,key ,cmd)
    `(evil-define-key 'insert ,map ,key ,cmd))
#+end_src

** 綁定 ex 命令的巨集

Vim 另外一個好用的東西是 ex 命令，這邊另外綁定 evil-ex-define-cmd。

#+begin_src emacs-lisp
  (defmacro vim:ex-cmd (cmd func)
    "Binding to evil-ex-define-cmd."
    `(evil-ex-define-cmd ,cmd ,func))
#+end_src

** Normal-state 按鍵設定

將一些非常慣用的 emacs 按鍵綁到 Normal-state 上面。

#+begin_src emacs-lisp
  (vim:nmap (kbd "C-n") 'evil-next-line)
  (vim:nmap (kbd "C-p") 'evil-previous-line)
#+end_src

| 按鍵 | 命令            | 用途             |
|------+-----------------+------------------|
| M-u  | upcase-word     | 將整個英文字大寫 |
| M-l  | downcase-word   | 將整個英文字小寫 |
| M-c  | capitalize-word | 將英文字字首大寫 |

#+begin_src emacs-lisp
  (vim:nmap (kbd "M-u") 'upcase-word)
  (vim:nmap (kbd "M-l") 'downcase-word)
  (vim:nmap (kbd "M-c") 'capitalize-word)
  (vim:nmap (kbd "<SPC>") 'ace-jump-mode)
#+end_src

** Insert-state 按鍵設定

這邊設定我的 Insert-state 的按鍵，部份會和我原本的 emacs 按鍵設置不太一樣。

#+begin_src emacs-lisp
  ;;  (vim:imap (kbd "C-o") 'evil-execute-in-normal-state)
  (vim:imap (kbd "C-o") 'evil-normal-state)
  (vim:imap (kbd "C-l") 'backward-delete-char)
  (vim:imap (kbd "C-w") 'evil-window-map)
  (vim:imap (kbd "M-w") 'kill-ring-save)
  (vim:imap (kbd "M-k") 'kill-region)
  (vim:imap (kbd "C-x C-n") 'evil-complete-previous)
  (vim:imap (kbd "C-x C-n") 'evil-complete-next)

#+end_src

** Window-sate 按鍵設定

#+begin_src emacs-lisp
  (vim:wmap "n" 'evil-window-down)
  (vim:wmap "p" 'evil-window-up)
  (vim:wmap "f" 'evil-window-right)
  (vim:wmap "b" 'evil-window-left)
#+end_src

* Vim 模擬擴充

** 使用 evil-nerd-commenter 更簡單去將程式註解掉

[[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] 是一個用於 evil-mode 上面的註解輔助工具，使用他以
後，可以在 Normal-state 下面使用 =﻿,ci= 將當前行註解/反註解。

常用用法:

- =﻿,,,﻿= 註解/反註解當前行
- =﻿,,9j= 註解/反註解之後 9 行
- =﻿,,99G= 從當前行開始到 99 行進行註解/反註解
- =﻿,,a(= 對目前的 s-exp 進行註解
- =﻿,,ai= 僅註解當前的 s-exp 內容
- =﻿,,ao= 註解/反註解當前的符號
- =﻿,,aW= 註解/反註解當前的詞

#+BEGIN_SRC emacs-lisp
  (require 'evil-nerd-commenter)
  (evilnc-default-hotkeys)
#+END_SRC

* 自動補全                                                         :complete:
** 載入相關套件

#+begin_src emacs-lisp
  (require 'auto-complete)
  (require 'auto-complete-config)
  (require 'auto-complete-clang)
#+end_src

** 使用預設的設定。

#+begin_src emacs-lisp
  (ac-config-default)
#+end_src

** 不使用 fuzzy-match

#+begin_src emacs-lisp
  (setq ac-use-fuzzy nil)
#+end_src

** 不自動啟用自動補全

#+begin_src emacs-lisp
  (setq ac-auto-start nil)
#+end_src

** 加入我自定義的補全字典

#+begin_src emacs-lisp
  (add-to-list 'ac-dictionary-directories (concat emacs-dir "ac-dict"))
#+end_src

** 全域性使用自動補全

global-auto-complete-mode 這個 function 只具有切換全部 buffer 的自動補全功能，
若想要一開始就全部的 mode 都具有自動補全能力，則必須用個 dirty hack 才行。

#+begin_src emacs-lisp
  (define-globalized-minor-mode real-global-auto-complete-mode
    auto-complete-mode (lambda ()
                         (if (not (minibufferp (current-buffer)))
                             (auto-complete-mode 1))
                         ))
  (real-global-auto-complete-mode t)
  (global-auto-complete-mode t)
#+end_src

** TODO 位分類
#+begin_src emacs-lisp
  ;; Ignore case if completion target string doesn't include upper characters
  (setq ac-ignore-case nil)

  ;; Enable auto-complete quick help
  (setq ac-use-quick-help t)

  ;; After 0.01 sec, show help window
  (setq ac-quick-help-delay 0.5)

  ;; Enable ac-comphist
  (setq ac-use-comphist t)

  ;; Setting ac-comphist data
  (setq ac-comphist-file (concat emacs-cache-dir "auto-complete.dat"))

  ;; Show menu
  (setq ac-auto-show-menu t)
  ;; Enable ac-menu-map
  (setq ac-use-menu-map t)
#+end_src
** 按鍵設定
auto-complete-mode 的按鍵設定。
#+begin_src emacs-lisp
  (define-key ac-menu-map (kbd "C-n") 'ac-next)
  (define-key ac-menu-map (kbd "C-p") 'ac-previous)
  (define-key ac-completing-map "\t" 'ac-complete)
  (define-key ac-complete-mode-map[tab] 'ac-expand)
#+end_src
* 終端機                                                               :term:

** 基本設定

term-mode 是 emacs 終端機最基本的 mode (自 emacs 24 之後開始可用 shell-mode
來替代 term-mode)，但是我用於串口通訊的 serial-term 仍舊是以 term-mode
為基礎，基於習慣，這邊會設置基本的 term-mode 配置。

- 載入相依套件

  #+begin_src emacs-lisp
    (require 'term)
    (require 'ansi-color)
  #+end_src

- 色彩配置

  移除 term-mode 預設的前景與背景顏色。

  #+begin_src emacs-lisp
    (setq term-default-bg-color nil)
    (setq term-default-fg-color nil)
  #+end_src

- 修正與 yasnippet 相衝的問題

  term-mode 似乎會和 yasnippet 的 tab 相衝，使用這個設定讓 yasnippet 不
  執行在 term-mode。

  #+begin_src emacs-lisp
    (eval-after-load 'yasnippet
      (add-hook 'term-mode-hook (lambda() (yas-minor-mode -1))))
  #+end_src

- 讓一些習慣的按鍵在 term-mode 下也有作用

  這邊重新設定一下 term-mode 下的按鍵設定，不這樣做的話，很多按鍵不能用
  很麻煩，比如說，在 emacs 下 M-x 不能用像話嘛....

  #+begin_src emacs-lisp
    (define-key term-raw-map (kbd "M-x") 'nil)
    (define-key term-raw-map (kbd "C-h") 'nil)
  #+end_src

** shell-pop
*** 載入相依套件
#+begin_src emacs-lisp
  (require 'shell-pop)
#+end_src
*** Config
#+begin_src emacs-lisp
  (shell-pop-set-internal-mode "eshell")
  (shell-pop-set-internal-mode-shell emacs-default-shell)
  (shell-pop-set-window-height emacs-popup-shell-window-height)
  (shell-pop-set-window-position emacs-popup-shell-window-position)

  (defadvice shell-pop (before kill-dead-term activate)
    "If there is a stopped ansi-term, kill it and create a new one."
    (let ((running-p (term-check-proc (buffer-name)))
          (term-p (string= "term-mode" major-mode)))
      (if term-p
          (when (not running-p)
            (kill-buffer (buffer-name))
            (shell-pop-out)))))
#+end_src

** multi-term
#+begin_src emacs-lisp
  (require 'multi-term)
  (setq multi-term-program emacs-default-shell)
#+end_src

** shell mode

#+begin_src emacs-lisp
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src
* 文件加密                                                          :encrypt:

對於一些和隱私比較相關的文件，總是希望可以加密起來，讓自己可以更加放心。

在 emacs 中，提供了 [[http://www.emacswiki.org/emacs/EasyPG][Easy PG]] 來協助你加密存文字檔案，你只要很簡單的將你的
檔案副檔名再加上 *.gpg* ，這樣 emacs 就會向你詢問加密用的密碼。

** 載入相依套件

#+begin_src emacs-lisp
  (require 'epa-file)
#+end_src

** 其他設置

#+begin_src emacs-lisp
  ;; use local gpg program instaed of system one
  ;; only work under linux

  (cond
   (linux-64bit-p (setq epg-gpg-program (concat emacs-bin-dir "gpg")))
   (linux-32bit-p (setq epg-gpg-program (concat emacs-bin-dir "gpg-x86")))
   (mac-p (setq epg-gpg-program "/usr/local/bin/gpg")))

  (setenv "GPG_AGENT_INFO" nil)

  (epa-file-enable)

  ;; Control whether or not to pop up the key selection dialog.
  (setq epa-file-select-keys 0)

  ;; Cache passphrase for symmetric encryption.
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)

#+end_src

* 命令欄                                                         :minibuffer:

** 設定視窗高度最多為 4 行高

#+begin_src emacs-lisp
  (setq max-mini-window-height 4)
#+end_src

** 使用 smex 來替代原本的緩衝區功能                            :smex:

#+begin_src emacs-lisp
  (require 'smex)
#+end_src

啟動 smex
#+begin_src emacs-lisp
  (smex-initialize)
#+end_src

#+begin_src emacs-lisp
  (setq smex-save-file (concat emacs-cache-dir "smex.dat"))
#+end_src

** 其他
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers     t )
  (setq minibuffer-electric-default-mode t )

  ;; Abort the minibuffer when using the mouse
  (add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)

  (defun stop-using-minibuffer ()
    "kill the minibuffer"
    (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
      (abort-recursive-edit)))
#+end_src

** 游標改成 bar 的形狀                                             :cursor:

我討厭在 minibuffer 時還是使用方塊狀的游標，這裡將他改變成 Bar 的形狀。

#+begin_src emacs-lisp
  (add-hook 'minibuffer-setup-hook '(lambda () (setq cursor-type 'bar)))
#+end_src

** ido
*** Depends
#+begin_src emacs-lisp
  (require 'ido)
#+end_src
*** Keybindings
#+begin_src emacs-lisp
  (add-hook 'ido-setup-hook
            '(lambda ()
               (define-key ido-completion-map (kbd "C-f") 'ido-next-match)
               (define-key ido-completion-map (kbd "C-b") 'ido-prev-match)
               ))
#+end_src
** 紀錄 Minibuffer 使用過的命令

透過 savehist 套件，我們可以將 Minibuffer 使用過的命令紀錄起來，
下次打開 emacs 仍可以知道之前呼叫過哪些 Minubuffer 的命令。

#+begin_src emacs-lisp
  (require 'savehist)
  ;; keep minibuffer history between session
  (setq savehist-file (concat emacs-cache-dir "savehist.dat"))
  ;; enable savehist
  (savehist-mode 1)
#+end_src

** 按鍵設定

| 按鍵 | 命令                     | 用途               |
|------+--------------------------+--------------------|
| M-l  | backward-kill-word       | 刪除前一個詞       |
| M-p  | previous-history-element | 前一個歷史紀錄     |
| M-n  | next-history-element     | 後一個歷史紀錄     |
| C-g  | minibuffer-keyboard-quit | 離開 minibuffer    |
| C-u  |                          | 清除游標前的文字   |
| C-t  |                          | 切換到 /tmp 資料夾 |
| C-h  |                          | 切換到家目錄       |

#+begin_src emacs-lisp
  (define-key minibuffer-local-map (kbd "M-l") 'backward-kill-word)
  (define-key minibuffer-local-map (kbd "M-p") 'previous-history-element)
  (define-key minibuffer-local-map (kbd "M-n") 'next-history-element)
  (define-key minibuffer-local-map (kbd "C-g") 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-map (kbd "C-u") (lambda () (interactive) (kill-line 0)))
#+end_src


| 按鍵 | 命令 | 用途               |
|------+------+--------------------|
| M-t  |      | 切換到 /tmp 資料夾 |
| M-h  |      | 切換到家目錄       |

#+begin_src emacs-lisp
  (define-key minibuffer-local-map (kbd "M-t") (lambda () (interactive) (kill-line 0) (insert "/tmp/")))
  (define-key minibuffer-local-map (kbd "M-h") (lambda () (interactive) (kill-line 0) (insert "~/")))
  (define-key minibuffer-local-map (kbd "M-w") (lambda () (interactive) (kill-line 0) (insert "~/Workspace/")))
  (define-key minibuffer-local-map (kbd "M-s") (lambda () (interactive) (kill-line 0) (insert "~/SparkleShare/")))
#+end_src

* EShell                                                              :eshell:

** 基本設置

- 載入相關套件

  #+begin_src emacs-lisp
    (require 'eshell)
    (require 'em-dirs)
    (require 'em-hist)
    (require 'em-prompt)
    (require 'em-term)
    (require 'em-cmpl)
  #+end_src

- 設定預設的 eshell 資料夾位置

  eshell-directory-name 設定了 eshell 的資料夾，裡面可能存放一些和
  eshell 相關的資訊。

  #+BEGIN_SRC emacs-lisp
    (setq eshell-directory-name (concat emacs-cache-dir "eshell"))
  #+END_SRC

- 當離開 eshell 時自動儲存歷史紀錄

  設定 eshell 的歷史紀錄檔案大小等資訊

  #+begin_src emacs-lisp
    (setq eshell-history-size 512)
    (setq eshell-save-history-on-exit t)
  #+end_src

** 將 eshell 的 prompt 設定成和 bash 一樣

#+begin_src emacs-lisp
  (setq eshell-prompt-function
        '(lambda ()
           (concat
            user-login-name "@" system-name " "
            (if (search (directory-file-name (expand-file-name (getenv "HOME"))) (eshell/pwd))
                (replace-regexp-in-string (expand-file-name (getenv "HOME")) "~" (eshell/pwd))
              (eshell/pwd))
            (if (= (user-uid) 0) " # " " $ "))))
#+end_src

** 替 eshell 的 prompt 上色

我不喜歡原本 eshell 那樣單一的顏色，用 Gentoo 系統預設的上色方式還比較好看 :)

#+begin_src emacs-lisp
  (defun coldnew/colorfy-eshell-prompt ()
    (let* ((mpoint)
           (user-string-regexp (concat "^" user-login-name "@" system-name)))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward (concat user-string-regexp ".*[$#]") (point-max) t)
          (setq mpoint (point))
          (overlay-put (make-overlay (point-at-bol) mpoint) 'face '(:foreground "dodger blue")))
        (goto-char (point-min))
        (while (re-search-forward user-string-regexp (point-max) t)
          (setq mpoint (point))
          (overlay-put (make-overlay (point-at-bol) mpoint) 'face '(:foreground "green3"))
          ))))

  ;; Make eshell prompt more colorful
  (add-to-list 'eshell-output-filter-functions 'coldnew/colorfy-eshell-prompt)
  #+end_src

** TODO 其他設定

#+begin_src emacs-lisp
  ;; other setting
  (setq eshell-ask-to-save-last-dir 'always)
  (setq eshell-hist-ignoredups t)
  (setq eshell-cmpl-cycle-completions nil)
  (setq eshell-scroll-to-bottom-on-output t)
  (setq eshell-show-maximum-output t)

  ;; use helm to complete esehll
  (when (featurep 'helm)
    (add-hook 'eshell-mode-hook
              #'(lambda ()
                  (define-key eshell-mode-map
                    [remap pcomplete]
                    'helm-esh-pcomplete))))


#+end_src

** TODO Command
#+begin_src emacs-lisp
  ;; find-file
  (defun eshell/ef (&rest args) (eshell/emacs args))

  ;; ediff
  (defun eshell/ed (file1 file2) (ediff file1 file2))

  (defun eshell/info (subject)
    "Read the Info manual on SUBJECT."
    (let ((buf (current-buffer)))
      (Info-directory)
      (let ((node-exists (ignore-errors (Info-menu subject))))
        (if node-exists
            0
          ;; We want to switch back to *eshell* if the requested
          ;; Info manual doesn't exist.
          (switch-to-buffer buf)
          (eshell-print (format "There is no Info manual on %s.\n"
                                subject))
          1))))
#+end_src
** 使用 auto-complete 來補全 eshell 命令

#+begin_src emacs-lisp
  ;; define ac-source for eshell-pcomplete
  (ac-define-source eshell-pcomplete
    '((candidates . pcomplete-completions)
      (cache)
      (symbol . "f")))

  (defun ac-eshell-mode-setup ()
    "auto-complete settings for eshell-mode"
    (setq ac-sources '(ac-source-eshell-pcomplete)))

  ;; Add to eshell-mode
  (add-hook 'eshell-mode-hook 'auto-complete-mode)
  (add-hook 'eshell-mode-hook 'ac-eshell-mode-setup)
#+end_src
** 使用 multi-eshell 快速切換不同的 eshell

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'eshell
    '(when (require 'multi-eshell nil 'noerror)
       ;; setup to eshell
       (setq multi-eshell-shell-function '(eshell))
       (setq multi-eshell-name "*eshell*")))
#+END_SRC

** 使用 eshell-autojump 快速跳轉資料夾

[[http://www.emacswiki.org/emacs/EshellAutojump][Eshell Autojump]] 提供了一個 *j* 的 eshell 命令，他會根據你之前使用 cd 切
換資料夾的紀錄，透過 regexp 的方式來批配你要切換的資料夾，舉例來說，
若我曾經在 eshell 裡面切換到 ~/.emacs.d 過，則只要使用

: j emacs

就可以在 emacs 中切換到 ~/.emacs.d 中了。

你可以使用

: cd =

來查看目前在列表中的資料夾有哪些

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'eshell
    '(require 'eshell-autojump nil 'noerror))
#+END_SRC

** eshell 命令

*** 在 eshell 中用 emacs 打開檔案

如果在 eshell 中呼叫 emacs 命令，實際上還是會打開另外一個 emacs 程式，
因此在這邊重弄 emacs 命令，這樣就可以很安心的在 eshell 中用 emacs 打開
檔案到緩衝區裏面。

#+begin_src emacs-lisp
  (defun eshell/emacs (&rest args)
    "Open a file in emacs. Some habits die hard."
    (if (null args)
        ;; If I just ran "emacs", I probably expect to be launching
        ;; Emacs, which is rather silly since I'm already in Emacs.
        ;; So just pretend to do what I ask.
        (bury-buffer)
      ;; We have to expand the file names or else naming a directory in an
      ;; argument causes later arguments to be looked for in that directory,
      ;; not the starting directory
      (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))

  (defalias 'eshell/e 'eshell/emacs)
#+end_src

*** 清空 eshell 緩衝區

這個命令的作用和 Unix 下的 clear 功用相同，都是用來清空 shell 的內容。

#+begin_src emacs-lisp
  (defun eshell/clear ()
    "Clears the shell buffer ala Unix's clear or DOS' cls"
    ;; the shell prompts are read-only, so clear that for the duration
    (let ((inhibit-read-only t))
      ;; simply delete the region
      (delete-region (point-min) (point-max))))
#+end_src

* Helm                                                                 :helm:

Helm (領航員) 是 emacs 下非常強大的檔案尋找工具，可以用他快速的找尋已經
打開的緩衝區、檔案，或是透過 locate 命令來找尋檔案，此外 helm 也提供了
oscurr 功能，可以直接在目前的檔案裡找相同的字串。

** 載入相關套件

#+begin_src emacs-lisp
  (require 'helm)
  (require 'helm-etags+)
  (require 'helm-ls-git)
#+end_src

** 使用預先定義好的 helm 設定

#+begin_src emacs-lisp
  (require 'helm-config)
  (setq helm-config t)
#+end_src

** 全域性啟用 helm-mode

#+begin_src emacs-lisp
  (helm-mode 1)
#+end_src

** Function

#+BEGIN_SRC emacs-lisp
  (defun helm-create-locatedb ()
    (interactive)
    (helm-locate -1))
  #+END_SRC

** 尋找目前緩衝區所有符合查詢規則的文字、字串                      :command:

#+begin_src emacs-lisp
  (defun coldnew/helm-occur ()
    "I don't like highlight when goto lines."
    (interactive)
    ;; FIXME: is there more elegent way to make temp face?
    (set (make-local-variable 'face-remapping-alist) '((helm-selection-line nil)))
    (helm-occur))
#+end_src

#+begin_src emacs-lisp
  (defun helm-c-occur-get-line (s e)
    "rewrite `helm-c-occur-get-line' to make it color on line-number."
    (concat (propertize (format "%7d" (line-number-at-pos (1- s))) 'face '((:foreground "red")))
            (format ": %s" (buffer-substring s e))))
#+end_src


** 按鍵設定

#+begin_src emacs-lisp
    (defun coldnew/helm-mini ()
      (interactive)
      (helm-other-buffer '(helm-source-ls-git
                           helm-source-locate
                           helm-c-source-buffers-list
                           helm-c-source-recentf
                           helm-c-source-buffer-not-found)
                         "*coldnew helm mini*"))
    (vim:imap (kbd "C-x p") 'coldnew/helm-mini)
#+end_src

* 文檔幫助                                                             :info:

這邊放置 manpage、womanpage、info 等幫助文檔模式的設定。

** WoMan                                                              :woman:

woman 是 emacs 下顯示 manpage 最好的方式。

*** WoMan 快取儲存位置設定

#+begin_src emacs-lisp
  (setq woman-cache-filename (concat emacs-cache-dir "woman.cache"))
#+end_src

*** 對 woMan 緩衝區上色

#+begin_src emacs-lisp
  (setq woman-fontify t)
#+end_src

*** TODO 其他
#+begin_src emacs-lisp
  (setq woman-use-topic-at-point nil)
  ;; Colorful fonts
  (setq woman-fill-column 100)
#+end_src
* org-mode                                                              :org:

因為 org-mode 在這個設定檔裡佔有非常重要的比例，所以獨立出來。

** 基本設定

- 載入相關套件

  #+begin_src emacs-lisp
    (require 'org-install)
    (require 'org-table)
    (require 'ob-ditaa)
    (require 'org-latex)
  #+end_src

- 設定 org-mode 檔案的副檔名與對應的模式

  #+begin_src emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
    (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
    (add-to-list 'auto-mode-alist '("\\.org_archive$" . org-mode))
  #+end_src

- 預設讓 org-mode 使用自動縮排模式

  #+begin_src emacs-lisp
    (setq org-startup-indented t)
  #+end_src

- 預設將所有項目都隱藏，只保留最上層的父目錄

  #+begin_src emacs-lisp
    (setq org-startup-folded t)
  #+end_src

- 將前面的 *星號* 隱藏，只顯示最後一個

  #+begin_src emacs-lisp
    (setq org-hide-leading-stars t)
  #+end_src

- 直接在程式碼欄位上為程式碼上色

  #+begin_src emacs-lisp
    (setq org-src-fontify-natively t)
  #+end_src

- 切換成程式碼欄位時使用目前的視窗

  #+begin_src emacs-lisp
    (setq org-src-window-setup 'current-window)
  #+end_src

** 加強 org-mode 強調文句的正規表達式

org-mode 裏面的用來強調 (emphasize) 字體的正規表達式有一些缺點，
比如你想使用下面的表達方式就會出現問題。

: ~target="_self"~   =>  <code>target="_self"</code>

解決的方式有兩個

1. 如果你確定這個文句是要輸出成為 HTML 的話，你可以使用下面的方式強制
   將他轉換。

   :  @@html:<code> target="_self" </code>@@

   關於更多 @@html: ... @@ 區塊的資訊，請參考 [[http://orgmode.org/manual/Quoting-HTML-tags.html#Quoting-HTML-tags][Quoting-HTML-tags]]

2. 你也可以輸入特別的 Unicode 字元

   : <U200B> /xe2/x80/x8b ZERO WIDTH SPACE

   這個特殊的 Unicode 字元顯示出一個很微小的的空白，基本上你是看不出來
   的，插入的方式是使用 *C-x 8 RET 200b RET* 來輸入這個 Unicode 字元。

   此外，你也要修改 *org-emphasis-regexp-components* 的規則。

原始的規則如下

#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom org-emphasis-regexp-components
   '(" ​\t('\"{" "- ​\t.,:!?;'\")}\\" " \t\r\n,\"'" "." 1))
#+END_SRC

修改成如下 (其中的 *#* 代表剛剛所提及的 <U200B> 字元 )

#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom org-emphasis-regexp-components
   '(" #​\t('\"{" "- ​\t.,:!?;'\")}\\" " \t\r\n,\"'" "." 1))
#+END_SRC

因此以下就是我實際上修改過後的 *org-emphasis-regexp-components* 。

#+BEGIN_SRC emacs-lisp
  (setq org-emphasis-regexp-components '(" ​\t('\"{" "- \t.,:!?;'\")}\\" " \t\r\n,\"'" "." 1))
#+END_SRC

** 使用 org-mode 記事                                              :capture:

org-mode 也是非常強大的記事工具，我在這邊先設定我擺放 org-mdoe 檔案的資料
夾

#+BEGIN_SRC emacs-lisp
  (setq org-directory (concat coldnew-sparkleshare-dir "/org/"))
#+END_SRC

而 agenda 的檔案則直接從 org-mode 檔案所在的資料夾去尋找

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-directory))
#+END_SRC

*** 當從 TODO 轉變成 DONE 的時候，加上時間標記 (logdone)

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

*** 設定預設的筆記檔案

我使用 TODO.org 當作預設的記事檔案。

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (concat org-directory "TODO.org"))
#+END_SRC

*** TODO 加上去

#+begin_src emacs-lisp
  (setq org-capture-templates '(("t" "TODO" entry (file+headline "" "Tasks")
                                 "* TODO %?\n %i\n")
                                ("f" "FIXME" entry (file+headline "" "Tasks")
                                 "* FIXME %?\n %i\n %a")
                                ("w" "Weintek" entry (file+headline "" "Weintek")
                                 "* TODO %?\n %i\n %a")
                                ))

#+end_src

*** TODO Keybinding
#+begin_src emacs-lisp
  (add-hook 'org-capture-mode-hook
            '(lambda ()
               ;;(define-key coldnew/command-mode-map "c" 'org-capture-finalize)
               (local-set-key (kbd "C-g") 'org-capture-kill)
               ))

#+end_src

** 擴充 org-mode 功能
*** 將 plantuml 加入 org-mode

plantuml 是一個用語言寫出 UML 架構圖的程式，使用他前必須將 Garphviz 裝上。

#+begin_src emacs-lisp
  (setq org-plantuml-jar-path (concat emacs-etc-dir "plantuml.jar"))
#+end_src

*** 將 ditaa 加入 org-mode

#+begin_src emacs-lisp
  (setq org-ditaa-jar-path (concat emacs-etc-dir "ditaa.jar"))
#+end_src

** 讓 org-mode 與 cua-mode 相容

#+begin_src emacs-lisp
  (setq org-CUA-compatible t)
#+end_src

** 預設不要讓 org-mode 顯示 Latex 形式的下標與上標

org-mode 預設會把 A_2 變成下標形式，這邊設置這個變數全域性取消這個功能。

#+begin_src emacs-lisp
  (setq org-export-with-sub-superscripts nil)
#+end_src

** 增加快速模版

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
               (add-to-list 'org-structure-template-alist
               '("S" "#+BEGIN_SRC sh\n?\n#+END_SRC"))
               (add-to-list 'org-structure-template-alist
               '("p" "#+BEGIN_SRC plantuml :file uml.png \n?\n#+END_SRC"))
#+end_src

** TODO Config

#+begin_src emacs-lisp
  (setq org-pretty-entities t)
  (setq org-use-speed-commands t)
#+end_src

** 設定 Agenda 顯示在目前的 window 上。

#+begin_src emacs-lisp
  (setq org-agenda-window-setup 'current-window)
#+end_src

** 在 Agenda mode 時啟用 hl-line

#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+end_src

** 使用 C-g 離開 Agenda

#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook
            '(lambda ()
               (local-set-key (kbd "C-g") 'org-agenda-exit)))
#+end_src

** 讓 org-mode 裡面可以加密文章                                      :crypt:

用於加密 org-mode 裡面具有 :secret: 這個 TAG 的區塊。
注意到這需啟用 [[*Easy%20PG][Easy PG]] 才能夠使用。

*** 載入相關模組

#+begin_src emacs-lisp
  (require 'org-crypt)
#+end_src

*** 設定要加密的 tag 標籤為 *secret*

#+begin_src emacs-lisp
  (setq org-crypt-tag-matcher "secret")
#+end_src

*** 當被加密的部份要存入硬碟時，自動加密回去

如果 emacs 有打開檔案備份，在存回硬碟前必須要先加密在儲存，
否則加密的部份也會被備份起來。

#+begin_src emacs-lisp
  (org-crypt-use-before-save-magic)
#+end_src

*** 避免 encrypt 這個 tag 被子項目繼承

避免 secret 這個 tag 被子項目繼承 造成重複加密
(但是子項目還是會被加密喔)

#+begin_src emacs-lisp
  (setq org-tags-exclude-from-inheritance (quote ("secret")))
#+end_src

*** 設定 org-crypt-disable-auto-save 成 encrypt 模式。

此模式並不會停用 auto-save-mode，反之，當自動儲存時，解密過的區域將會加密回去。

#+begin_src emacs-lisp
  (setq org-crypt-disable-auto-save 'encrypt)
#+end_src

*** 設定用於加密的 GPG 金鑰

可以設定任何 ID 或是設成 nil 來使用對稱式加密 (symmetric encryption)

#+BEGIN_SRC emacs-lisp
  (setq org-crypt-key nil)
#+END_SRC

** 在 org-mode 裏面使用 C-c I 切換顯示圖片                          :keymap:

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-c I") 'org-toggle-inline-images)))
#+end_src
** 設定圖片的寬度

#+BEGIN_SRC emacs-lisp
  (setq org-image-actual-width nil)
#+END_SRC

** Keybinding
*** org-mode
設定自定義的按鍵。
#+begin_src emacs-lisp
    (add-hook 'org-mode-hook
              '(lambda ()
                 (define-key org-mode-map (kbd "C-c C-p") 'org-backward-same-level)
                 (define-key org-mode-map (kbd "C-c C-n") 'org-forward-same-level)
                 (define-key org-mode-map (kbd "C-c C-b") 'coldnew/org-up-parent)
                 (define-key org-mode-map (kbd "C-c C-f") 'coldnew/org-down-children)
                 (define-key org-mode-map (kbd "C-c i") 'org-insert-link)
                 ;;(define-key coldnew/command-mode-map "c" 'org-edit-special)
                 ))

  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-\'") nil)
               (define-key org-mode-map (kbd "C-,") nil)
               ;;(define-key org-mode-map (kbd "C-c C-e") nil)
               ))
#+end_src


#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map (kbd "C-c b") 'org-metaleft)
               (define-key org-mode-map (kbd "C-c f") 'org-metaright)
               (define-key org-mode-map (kbd "C-c p") 'org-metaup)
               (define-key org-mode-map (kbd "C-c n") 'org-metadown)))
#+end_src
*** org-src-mode
#+begin_src emacs-lisp
  (add-hook 'org-src-mode-hook
            '(lambda ()
               ;;(local-set-key (kbd "C-c C-c") 'org-edit-src-exit)
               ;;(define-key coldnew/command-mode-map "c" 'org-edit-src-exit)
               ))
#+end_src
** Conflict Fix
some packages conflict with org-mode
*** windmove
#+begin_src emacs-lisp
  ;; Make windmove work in org-mode:
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src
** Commands
*** org-archive-done-tasks
將標記為 *DONE* 的結點收錄到 archive 裡。
#+begin_src emacs-lisp
  (defun org-archive-done-tasks ()
    "Make all DONE subtree to archive."
    (interactive)
    (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+end_src
*** coldnew/org-up-parent
跑到目前節點的父節點，並收起目前的結點。
#+begin_src emacs-lisp
  (defun coldnew/org-up-parent ()
    "Move to the parent of current point. If current is the parent heading,
            move to the previous parent heading."
    (interactive)
    (if (not (org-on-heading-p))
        (outline-back-to-heading)
      (let* ((level (funcall outline-level))
             (point-to-move-to
              (save-excursion
                (outline-previous-visible-heading 1)
                (while (>= (funcall outline-level) level)
                  (outline-previous-visible-heading 1))
                (point))))
        (if point-to-move-to
            (goto-char point-to-move-to))))
    (org-cycle))
#+end_src
*** coldnew/org-down-children
跑到目前節點的子節點，並展開子節點。
#+begin_src emacs-lisp
  (defun coldnew/org-down-children ()
    "Move to children of current heading. If current heading only has subtree,
          expand the subtree."
    (interactive)
    (outline-back-to-heading)
    (show-children)
    (let* ((level (funcall outline-level))
           (point-to-move-to
            (save-excursion
              (outline-next-visible-heading 1)
              (if (<= (funcall outline-level) level)
                  nil
                        (point)))))
              (if point-to-move-to
                  (goto-char point-to-move-to)
                (show-subtree))))
#+end_src
** Babel 支援的語言

org-mode 的 Babel 功能可以實現所謂的 Literacture Programming

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (ditaa . t)
     (dot . t)
     (js . t)
     (latex . t)
     (perl . t)
     (python . t)
     (ruby . t)
     (sh . t)
     (plantuml . t)
     (clojure .t)
     ))
#+end_src
** 對程式碼區塊進行 eval 時不再詢問

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

** 輸出成 PDF 檔案設定

#+BEGIN_SRC emacs-lisp
  (require 'ox-latex)
#+END_SRC

*** 使用 minted 將程式碼加上色彩

#+begin_src emacs-lisp :tangle no
  (require 'org-latex)
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-export-latex-listings 'minted)
  (setq org-export-latex-minted-options
        '(("frame" "lines")
          ("fontsize" "\\scriptsize")))
#+end_src

*** 使用 xelatex 產生 PDF 檔案

當系統有安裝 latexmk 時，使用 latexmk 呼叫 xelatex 進行編譯，
反之則直接呼叫 xelatex 進行二次編譯。
#+begin_src emacs-lisp
  (setq org-latex-pdf-process
        (if (executable-find "latexmk")
            '("latexmk -pdflatex=xelatex -pdf -silent --shell-escape -f %f")
          '("xelatex -interaction nonstopmode --shell-escape %f"
            "xelatex -interaction nonstopmode --shell-escape %f")))
#+end_src

*** 一般文章所使用的 latex 配置

#+begin_src emacs-lisp :tangle no
  (add-to-list 'org-latex-classes
               '("coldnew-article"
                 "\\documentclass[12pt,a4paper]{article}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{fontspec}
                  \\usepackage{xeCJK}
                  \\setCJKmainfont{Hiragino Sans GB W3}
                  \\XeTeXlinebreaklocale \"zh\"
                  \\XeTeXlinebreakskip = 0pt plus 1pt
                  \\xeCJKsetup{CJKglue=\hspace{0pt plus .08 \baselineskip }}
                  \\usepackage{graphicx}
                  \\usepackage{tikz}
                  \\usepackage[bookmarks=true,colorlinks,urlcolor=blue]{hyperref}
                  \\defaultfontfeatures{Mapping=tex-text}
                  \\setmonofont[Scale=0.8]{DejaVu Sans Mono}
                  \\usepackage{geometry}
                  \\usepackage{minted}
                  \\usemintedstyle{emacs}
                  \\geometry{a4paper, textwidth=6.5in, textheight=8in,
                              marginparsep=10pt, marginparwidth=.6in}
                  \\pagestyle{plain}
                  \\linespread{1.5}
                  \\title{}
                        [NO-DEFAULT-PACKAGES]
                        [NO-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))
#+end_src

*** 投影片所使用的 latex 配置

#+begin_src emacs-lisp
;;\\xeCJKsetup{CJKglue=\hspace{0pt plus .08 baselineskip }}
  (add-to-list 'org-latex-classes
               ;; beamer class, for presentations
               '("beamer"
                 "\\documentclass\[presentation\]\{beamer\}
                  \\usepackage[utf8]{inputenc}
                  \\usepackage[T1]{fontenc}
                  \\usepackage{xeCJK}
                  \\setCJKmainfont{Hiragino Sans GB W3}
                  \\XeTeXlinebreaklocale \"zh\"
                  \\XeTeXlinebreakskip = 0pt plus 1pt
                  \\usepackage{minted}
                  \\usemintedstyle{emacs}
                  \\setmainfont{Monaco}
                  \\usepackage{hyperref}
                  \\usepackage{color}
                  \\usepackage{verbatim}
                  \\usepackage{upquote}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\begin{frame}[fragile]\\frametitle{%s}"
                  "\\end{frame}"
                  "\\begin{frame}[fragile]\\frametitle{%s}"
                  "\\end{frame}")))
#+end_src

** 網頁輸出設定

*** 不要在輸出的網頁上面加上 Validate 字樣

預設的 org-mode 會在輸出的網頁尾巴加上 Validate 字樣，看起來很討厭，
這裡將他移除。

#+BEGIN_SRC emacs-lisp
  (setq org-html-validation-link nil)
#+END_SRC

** major-mode-expand

#+BEGIN_SRC emacs-lisp
  (setq org-mode-expand-alist
        '(("t" . org-insert-export-options-template)
          ))
#+END_SRC

* 書籤與暫存器                                                     :bookmark:
** Bookmark 說明

| 快捷鍵  | 命令                | 用途                                        |
|---------+---------------------+---------------------------------------------|
| C-x r m | bookmark-set        | 設置新的書籤                                |
| C-x r l | bookmark-bmenu-list | 列出所有已設置的書籤                        |
| C-x r b | bookmarj-jump       | 跳轉到書籤                                  |
|         | bookmark-delete     | 刪除書籤                                    |
|         | bookmark-load       | 讀取已儲存的書籤檔案                        |
|         | bookmark-save       | 儲存書籤至 bookmark-default-file 指定的地方 |

** Config
#+begin_src emacs-lisp
  (setq bookmark-default-file emacs-bookmark-file)
#+end_src

#+begin_src emacs-lisp
  (require 'bm)
#+end_src

** 快速跳轉到檔案                                                 :register:

使用 Ctrl-x r j <char> 就可以進行快速跳轉至檔案，其中 <char> 為以下所設定。

#+begin_src emacs-lisp
  (dolist
      (r `(
           ;; emacs's config.org
           (?e (file . ,(expand-file-name emacs-config-file)))
           ;; TODO.org
           (?t (file . "~/SparkleShare/org/TODO.org"))
           ;; Offilce
           (?w (file . "~/SparkleShare/org/Weintek.org"))
           ;; Note.org
           (?n (file . "~/SparkleShare/org/Note.org"))
           ;; blog.org
           (?b (file . "~/SparkleShare/coldnew.github.io/blog-src/blog.org"))
           ))
    (set-register (car r) (cadr r)))
#+end_src

* 專案管理                                                          :project:

emacs 下有太多太多跟專案管理相關的套件了，目前先一一試用，再來
決定我要用什麼

** projectile

#+begin_src emacs-lisp
  (require 'projectile)
#+end_src

* TAGS                                                                 :tags:

這邊放置和 tags 相關的功能

** 自動更新 TAGS

ctags-update 這個擴展會自動幫你更新目前的 TAGS, 這邊我打開 ctags-update-minor-mode,
這樣任何模式下，若我有 TAGS 檔案的話，他都會自動幫我更新。

我並沒有為他增加其他配置，因此預設為 5 分鐘更新一次 TAGS。

#+begin_src emacs-lisp
  (require 'ctags-update)
#+end_src

很令人討厭的一件事情是, helm-etags-plus 的作者有包了另外一個
ctags-update.el 檔案，所以如果載入順序出錯的話，會和另外一個同名的
ctags-update.el 衝突到，我這邊使用獨立的 ctags-update.el，當他不存在在使
用 helm-etags-plus 裡面附贈的 ctags-update.el。

#+BEGIN_SRC emacs-lisp
  ;; Use ctags-update function in ctags-update.el
  (if (fboundp 'ctags-auto-update-mode)
      (ctags-auto-update-mode 1)
    ;; if the function does not exist, use the ctags-update
    ;; in helm-etags-plus packages.
    (if (fboundp 'ctags-update-minor-mode)
        (ctags-update-minor-mode 1)))
#+END_SRC

** 用來產生 TAGS 的命令                                            :command:

我使用 TAGS 最多的地方應該就是 kernel code 以及 Linux 下的 C code 了，
由於 kernel code 可以用

: make TAGS

來產生 TAGS 檔案，因此此命令只是添加在這邊，若我有需要的話直接呼叫就可以很方便
的做出一個新的 TAGS 檔案。

#+begin_src emacs-lisp
  (defun create-tags ()
    "Create TAGS file in current directory."
    (interactive)
    (let ((dir (read-from-minibuffer "generate tags in: "
                                     (file-name-directory (or (buffer-file-name)
                                         default-directory))))
            (exp (read-from-minibuffer "suffix: ")))
      ;; if suffix is null, take it as c language
      (if (string-equal "" exp) (setq exp "*.[ch]"))
      (with-temp-buffer
        (shell-command
         (concat "find " dir " -name \"" exp "\" | xargs etags ")
         (buffer-name)))))
#+end_src

** 用來產生 GTAGS 的命令                                           :command:

#+begin_src emacs-lisp
  (defun create-gtags ()
    "create or update the gnu global tag file"
    (interactive)
    (if (not (= 0 (call-process "global" nil nil nil " -p")))
        ;; tagfile doesn't exist?
        (let ((olddir default-directory)
              (topdir (read-directory-name
                       "gtags: top of source tree:" default-directory)))
          (cd topdir)
          (message "Creating tags table...")
          (shell-command "gtags")
          (message "Creating tags table... Done")
          (cd olddir)) ;; restore
      ;; tagfile already exists; update it
      (message "Updating tags table...")
      (shell-command "global -u")
      (message "Updating tags table... Done")))
#+end_src

* 編輯器                                                             :editor:

** 基本編輯器設定

- 設定 TAB 的寬度為 8

  #+begin_src emacs-lisp
    (setq tab-width 8)
  #+end_src

- 不使用 TAB 進行縮排

  #+begin_src emacs-lisp
     (setq indent-tabs-mode nil)
  #+end_src
- 設定每行之間的間格為 4

  #+begin_src emacs-lisp
    (setq line-spacing 4)
  #+end_src

- 在檔案的最後一行加入一空白行

  #+begin_src emacs-lisp
    (setq require-final-newline t)
  #+end_src

- 全域使用色彩上色

  #+begin_src emacs-lisp
    (global-font-lock-mode t)
  #+end_src

- 高亮匹配的括號

  #+begin_src emacs-lisp
    (show-paren-mode t)
  #+end_src

** 建立編輯器的全域性 minor-mode

我希望能夠全域性的使用我所定義的編輯器，因此宣告一個 minor-mode，
並讓他可以直接啟用。

#+begin_src emacs-lisp
  (defvar coldnew-editor-map (make-keymap))

  (define-minor-mode coldnew-editor-mode
    "coldnew's editor minor mode."
    :init-value t
    :keymap coldnew-editor-map)

  (define-globalized-minor-mode global-coldnew-editor-mode
    coldnew-editor-mode (lambda ()
                          (if (not (minibufferp (current-buffer)))
                              (coldnew-editor-mode 1))))

  ;; Gloabal enable
  (global-coldnew-editor-mode t)
#+end_src

** 在存檔前清除多餘的空白

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** 宣告寫程式、文學用的 mode list

- 定義寫程式用的 mode

  emacs 有一些 major 無法和 font-lock-add-keywords 相處融洽，
  會倒置整個緩衝區的顏色不見，因此最好的方式是定義要加入新的
  關鍵字上色用的 major-mode，或者說，這些 mode 是要用來寫程式的。

  #+begin_src emacs-lisp
    (defvar coldnew/programming-mode
      '(emacs-lisp-mode

        ;; lisp
        lisp-interaction-mode lisp-mode
        clojure-mode clojurescript-mode scheme-mode
        common-lisp-mode newlisp-mode

        ;; C/C++ like
        c-mode c++-mode objc-mode
        csharp-mode  d-mode
        java-mode jde-mode

        ;; Web
        html-mode javascript-mode js2-mode

        ;; script
        sh-mode python-mode ruby-mode cperl-mode

        ;; others
        erlang-mode sgml-mode qml-mode
        slime-mode haskell-mode tuareg-mode lua-mode
        pascal-mode fortran-mode prolog-mode asm-mode
        sml-mode
        )
      "Major mode for programming languages")
  #+end_src

- 定義寫文章的 mode

  #+begin_src emacs-lisp
    (defvar coldnew/literacture-mode
      '(org-mode text-mode latex-mode)
      "Major mode that i will use for writting")
  #+end_src

** 替 FIXME 等關鍵字上色

很多時候我們會再程式碼裏面加上了 FIXME: 等字樣，這邊額外定義我需要高亮的文字。

我設定了對以下關鍵字上色

FIXME: BUG: HACK:
NOTE: TODO: DONE:

#+begin_src emacs-lisp
  (dolist (mode coldnew/programming-mode)
    (font-lock-add-keywords mode
     '(("\\<\\(FIXME\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)
       ("\\<\\(NOTE\\):" 1 'org-level-2 t)
       ("\\<\\(TODO\\):" 1 'org-todo t)
       ("\\<\\(DONE\\):" 1 'org-done t))
     ))
#+end_src

** TODO 替數字額外上色

vim 預設也會對數字進行別的上色動作。
ref: https://github.com/patriciogonzalezvivo/dot-emacs/blob/master/live-fontify-hex.el

#+begin_src emacs-lisp
  (dolist (mode coldnew/programming-mode)
    (font-lock-add-keywords mode
     '(
       ;; hexadecimal
       ("\\b\\(0[00-9a-fA-F]+\\)" 1 font-lock-constant-face)
       ;; float
       ("\\b\\([+-]?[0-9]+\\.[0-9]+\\)" 1 font-lock-constant-face)
       ;; int
       ("[\`^(\{\[,\+\-\*/\%=\s-]\\(-?[0-9]+U?L?L?\\)" 1 font-lock-constant-face)
       )))
#+end_src

** 替逸脫字元上色 (escape char)

很多語言都有逸脫字元(escape char), 並且語法都是類似 c 語言那樣，這邊也將
這些字元進行上色。

#+begin_src emacs-lisp
  (dolist (mode coldnew/programming-mode)
    (font-lock-add-keywords mode
     '(("\\\\\\(?:[abfnrtv'\"?\\0]\\|x[a-fA-F]\\{2\\}\\|[0-7]\\{3\\}\\)"
        0 '(:foreground "seagreen2") prepend))))
#+end_src

** 在寫文件或是程式註解時自動填滿行寬

- 在寫文章的時候啟用 auto-fill-mode

  #+begin_src emacs-lisp
    (dolist (mode coldnew/literacture-mode)
      (let ((hook (intern (concat (symbol-name mode) "-hook"))))
        (add-hook hook
                  (lambda ()
                    (auto-fill-mode 1)))))
  #+end_src


- 在寫程式時只在註解啟用 auto-fill-mode

  #+begin_src emacs-lisp
    (dolist (mode coldnew/programming-mode)
      (let ((hook (intern (concat (symbol-name mode) "-hook"))))
        (add-hook hook
                  (lambda ()
                    (auto-fill-mode 1)
                    (set (make-local-variable 'fill-nobreak-predicate)
                         (lambda ()
                           (not (eq (get-text-property (point) 'face)
                                    'font-lock-comment-face))))))))
  #+end_src

** 存檔後自動建立資料夾

當存檔的時候，如果這個緩衝區的父資料夾不存在，自動建立他。
#+begin_src emacs-lisp
(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (and (not (file-exists-p dir))
                           (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                  (make-directory dir t))))))
#+end_src

** 自動回復檔案

當檔案被別的編輯器修改的時候，自動套用新的檔案到緩衝區上。

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq revert-without-query '(".*")) ;; disable revert query
#+end_src

** 行號顯示設定

- 預設顯示行號

  #+begin_src emacs-lisp
    (global-linum-mode 1)
  #+end_src

- 設定某些 Mode 不顯示行號，這邊先設定不顯示行號的 mode-list

  #+begin_src emacs-lisp
    (setq inhibit-linum-mode-alist
          '(eshell-mode
            shell-mode
            term-mode
            erc-mode
            compilation-mode
            woman-mode
            w3m-mode
            calendar-mode
            org-mode
            ))
  #+end_src

- 修正 linum-on 的功能，讓他遇到我們設定不顯示行號的模式時，不啟用 linum-mode

  #+begin_src emacs-lisp
    (defadvice linum-on (around inhibit-for-modes activate)
      "Stop turing linum-mode if it is in the inhibit-linum-mode-alist."
      (unless (member major-mode inhibit-linum-mode-alist)
        ad-do-it))
  #+end_src

** 加入 Doxygen 支援

Doxygen 是一套非常棒的註解產生文件的程式，emacs 底下有 doxymacs, 可以
將 doxygen 的語法進行上色的動作。

#+begin_src emacs-lisp
  (add-hook 'coldnew-editor-mode-hook
            '(lambda ()
               (when (require 'doxymacs nil 'noerror)
                 (doxymacs-mode))))
#+end_src

** 加上貪婪刪除功能                                               :hungry@delete:

一般使用 backspace 都只刪除一個字元，hungry-delete 這個套件
加入了貪婪刪除功能，可以刪除前面一堆的空白字元。

#+begin_src emacs-lisp
  (add-hook 'coldnew-editor-mode-hook
            '(lambda ()
               (when (require 'hungry-delete nil 'noerror)
                 (turn-on-hungry-delete-mode))))
#+end_src

** 使用 yasnippet 加強樣板處理                                    :yasnippet:

yasnippet 是一個非常強大的樣板 (template) 系統，在現在的 emacs 下，他
已經是必備的套件了。

*** 基本設置

- 載入相關套件

  #+begin_src emacs-lisp
    (require 'yasnippet)
  #+end_src

- 全域性啟用 yasnippet

  #+begin_src emacs-lisp
    (yas-global-mode 1)
  #+end_src

- 設定 snippet 所在的資料夾

  我不想要使用 yasnippet 預設的 snippet, 這邊將他改成我自己定義的
  snippet 位置。

  #+begin_src emacs-lisp
;;    (setq yas/snippet-dirs '(emacs-snippets-dir))
  #+end_src

*** 使用 yasnippet 達到 org-mode 的 easy-template 功能

org-mode 的 easy-template 提供使用者輸入 <e 再按下 TAB 就可以進行自動補全的功能,
為了在任意模式下都可以辦到如同 org-mode 的 easy template 的功能，我
設計了以下的程式碼。

#+begin_src emacs-lisp
  (defadvice yas-expand (around coldnew/major-mode-expand activate)
    "Try to complete a structure template before point like org-mode does.
    This looks for strings like \"<e\" on an otherwise empty line and
    expands them.
    Before use this function, you must setup `major-mode-name'-expand-alist variable.

    Take emacs-lisp-mode as example, if you wand to use <r to expand your snippet `require'
    in yasnippet, you muse setup the emacs-lisp-mode-expand-alist variable.

     (setq emacs-lisp-expand-alist '((\"r\" . \"require\")))"
    (let* ((l (buffer-substring (point-at-bol) (point)))
           (expand-symbol (intern (concat (symbol-name major-mode) "-expand-alist")))
           (expand-alist (if (boundp expand-symbol) (symbol-value expand-symbol) nil))
           a)
      (when (and (looking-at "[ \t]*$")
                 (string-match "^[ \t]*<\\([a-zA-Z]+\\)$" l)
                 (setq a (assoc (match-string 1 l) expand-alist)))
        (backward-delete-char (1+ (length (car-safe a))))
        (if (symbolp (cdr-safe a))
            (funcall (cdr-safe a))
          (insert (cdr-safe a)))
        t)
      ad-do-it))
#+end_src

假如希望在 emacs-lisp-mode 輸入 <r 再按下 TAB 就可以使用 yasnippet 展開
require 的 snippet, 則添加以下程式

#+begin_src emacs-lisp :tangle no
 (setq emacs-lisp-mode-expand-alist '(("r" . "require")))
#+end_src

注意到 major-mode 是什麼，則添加相對應的 *major-mode-expand-alist*,
比如 major-mode 是 c-mode 則加入

#+begin_src emacs-lisp :tangle no
 (setq c-mode-expand-alist '(("i" . "include")))
#+end_src

其他以此類推

*** 在建立新的檔案時，自動插入樣板

#+begin_src emacs-lisp
  ;; Auto add HEADER in new file
  (add-hook 'find-file-hook
            '(lambda ()
               (when (and (buffer-file-name)
                          (not (file-exists-p (buffer-file-name)))
                          (= (point-max) 1))
                 (let ((header-snippet "HEADER")
                       (yas/fallback-behavior 'return-nil))
                   (insert header-snippet)
                   ;; if can't expand snippet, clear whole buffer
                   (if (not (yas/expand))
                       (delete-region (point-min) (point-max)))))))
#+end_src

** 使用 undo-tree 來進行 undo/redo                               :undo@tree:

- 關於 undo-tree

  undo-tree 是 emacs 與 vim 上面都有的一個套件，對於 emacs 使用者而言，
  undo-tree 幫 emacs 增加了 redo 的功能。

- 載入相依套件

  #+begin_src emacs-lisp
    (require 'undo-tree)
  #+end_src

- 全域性啟用 undo-tree

  #+begin_src emacs-lisp
    (global-undo-tree-mode)
  #+end_src

- 使用 C-g 跳出 undo-tree

  #+begin_src emacs-lisp
;;    (define-key undo-tree-visualizer-map (kbd "C-g") 'undo-tree-visualizer-quit)
  #+end_src

** 自動在英文與中文之間加入空白

- 關於 pangu-spacing

  [[https://github.com/coldnew/pangu-spacing][pangu-spacing]] 是 emacs 上的一個 minor-mode, 啟用他後，他會在英文與中文
  之間自動加入空白符號，讓你使用 emacs 在閱讀文章的時候能夠非常舒適 :)

- 名稱由來

  pangu-spacing 名稱來自於 [[https://github.com/gibuloto/paranoid-auto-spacing][paranoid-auto-spacing]] 的 README

  #+BEGIN_EXAMPLE

    引述自 paranoid-auto-spacing README

    如果你跟我一樣，每次看到網頁上的中文字和英文、數字、符號擠在一塊，就會
    坐立難安，忍不住想在它們之間加個空格。這個外掛（支援 Chrome 和 Firefox）
    正是你在網路世界走跳所需要的東西，它會自動替你在網頁中所有的中文字和半
    形的英文、數字、符號之間插入空白。

    漢學家稱這個空白字元為「盤古之白」，因為它劈開了全形字和半形字之間的混
    沌。另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都
    走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成
    的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。

    與大家共勉之。ori test
  #+END_EXAMPLE

- 載入相關套件

  #+begin_src emacs-lisp
    (require 'pangu-spacing)
  #+end_src

- 全域性啟用 pangu-spacing

  #+begin_src emacs-lisp
    (global-pangu-spacing-mode 1)
  #+end_src

- 只有在 org-mode 裏面真的添加空白進去

  #+begin_src emacs-lisp
     (add-hook 'org-mode-hook
               '(lambda ()
                 (set (make-local-variable 'pangu-spacing-real-insert-separtor) t)))
  #+end_src
** TODO remember
*** electric-pair-mode
#+begin_src emacs-lisp
  (electric-pair-mode 1)
  ;; setting for auto-close brackets for electric-pair-mode regardless of current major mode syntax table
  (setq electric-pair-pairs '(
                              (?\" . ?\")
                              (?\{ . ?\})
                              ) )
#+end_src
#+begin_src emacs-lisp
  (setq fill-column      100 ) ; column beyond which automatic line-wrapping shold happen
  (setq kill-ring-max    3000 ) ; Maximum lenght of kill-ring
  (setq next-line-add-newlines t ) ;
  (setq shift-select-mode      t ) ; Enable shift-select mode

  ;; Enable delete-selection-mode
  (delete-selection-mode t)
#+end_src
** 允許文件使用特定的區域變數

有些時候我會在一些特定的文件使用區域變數，可是 emacs 就會跑過來問我說:
這個變數很危險，是否要啟用？ 這個功能真是麻煩，於是我決定將我會啟用的
變數資訊加入到 =safe-local-variable-values= 並且修改
=enable-local-variables= 的資訊，這樣以後 emacs 就不會再問我同樣的問題
了。

#+BEGIN_SRC emacs-lisp
  (setq enable-local-variables :safe)
  (setq safe-local-variable-values
        '((org-export-latex-title-command . "")))
#+END_SRC

* 編輯器按鍵設置

這邊是我定義的 coldnew-editor-mode 的按鍵設定，每個類型的標條都會附註這裏面的
按鍵是 Normal, Insert 或是其他模式下才會有的按鍵。

** 按鍵巨集錄製/播放 (N) (I)

| 按鍵  | 命令                          | 用途              |
|-------+-------------------------------+-------------------|
| C-x q | toggle-kbd-macro-recording-on | 錄製/停止鍵盤巨集 |
| C-x e | call-last-kbd-macro           | 播放最後一個巨集  |
| C-.   | repeat                        | 重複上一個命令    |

#+begin_src emacs-lisp
  (vim:mode-map coldnew-editor-map (kbd "C-x q") 'toggle-kbd-macro-recording-on)
  (vim:mode-map coldnew-editor-map (kbd "C-x e") 'call-last-kbd-macro)
  (vim:mode-map coldnew-editor-map (kbd "C-.")   'repeat)
#+end_src

** 常用按鍵 (N) (I)

| 按鍵    | 命令             | 用途                   |
|---------+------------------+------------------------|
| C-c C-e | eval-and-replace | eval emacs-lisp 命令   |
| C-x l   | hl-line-mode     | 將游標目前行加上彩色條 |
| C-x L   | linum-mode       | 切換顯示行號           |

#+begin_src emacs-lisp
  (vim:mode-map coldnew-editor-map (kbd "C-c C-e") 'eval-and-replace)
  (vim:mode-map coldnew-editor-map (kbd "C-x l") 'hl-line-mode)
  (vim:mode-map coldnew-editor-map (kbd "C-x L") 'linum-mode)

  (when (require 'ace-jump-mode nil 'noerror)
    (vim:mode-nmap coldnew-editor-map (kbd "<SPC>") 'ace-jump-mode))
#+end_src

| 按鍵 | 命令                     | 用途             |
|------+--------------------------+------------------|
| M-y  | helm-show-kill-ring      | 顯示 kill-ring   |
| M-x  | smex                     | 顯示 emacs 命令  |
| s-x  | smex-major-mode-commands | 顯示主模式的命令 |

#+BEGIN_SRC emacs-lisp
  (when (require 'helm nil 'noerror)
    (vim:mode-map coldnew-editor-map (kbd "M-y") 'helm-show-kill-ring))

  (when (require 'smex nil 'noerror)
    (vim:mode-map coldnew-editor-map (kbd "M-x") 'smex)
    (vim:mode-map coldnew-editor-map (kbd "s-x") 'smex-major-mode-commands))
#+END_SRC

| 按鍵 | 命令                | 用途                         |
|------+---------------------+------------------------------|
| M-2  | multi-eshell        | 切換至完整的 eshell 視窗     |
| M-3  | multi-eshell-switch | 切換目前已打開的 eshell 視窗 |

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'eshell
    '(progn
       (when (require 'multi-eshell nil 'noerror)
         (vim:mode-map coldnew-editor-map (kbd "M-2")   'multi-eshell)
         (vim:mode-map coldnew-editor-map (kbd "M-3")   'multi-eshell-switch)
         (vim:nmap (kbd "M-2") 'multi-eshell)
         (vim:nmap (kbd "M-3") 'multi-eshell-switch))))
#+END_SRC

** 檔案相關 (N) (I)

| 按鍵    | 命令                   | 用途                         |
|---------+------------------------+------------------------------|
| C-x C-f | lusty-file-explorer    | 查詢並打開檔案               |
| C-x C-r | lusty-sudo-explorer    | 使用 sudo 打開檔案           |
| C-x C-s | save-buffer-always     | 儲存檔案                     |
| C-x f x | set-file-executable    | 為目前檔案加上可執行權限     |
| C-x f c | clone-file-and-open    | 複製目前檔案到其他檔案並打開 |
| C-x f d | delete-file-and-buffer | 刪除目前的檔案與緩衝區       |

#+begin_src emacs-lisp
  (vim:mode-map coldnew-editor-map (kbd "C-x C-f")  'lusty-file-explorer)
  (vim:mode-map coldnew-editor-map (kbd "C-x C-r")  'lusty-sudo-explorer)
  (vim:mode-map coldnew-editor-map (kbd "C-x C-s")  'save-buffer-always)
  (vim:mode-map coldnew-editor-map (kbd "C-x fx")  'set-file-executable)
  (vim:mode-map coldnew-editor-map (kbd "C-x fc")  'clone-file-and-open)
  (vim:mode-map coldnew-editor-map (kbd "C-x fd")  'delete-file-and-buffer)
#+end_src

| 按鍵 | 命令              | 用途                        |
|------+-------------------+-----------------------------|
| M-o  | coldnew/helm-mini | 使用自訂的 helm-mini 找檔案 |

#+begin_src emacs-lisp
  (eval-after-load 'helm
    '(progn
       (vim:mode-map coldnew-editor-map (kbd "M-o")
                     '(lambda ()
                        "coldnew's helm-mini"
                        (interactive)
                        (helm-other-buffer
                         '(helm-source-ls-git
                           helm-source-locate
                           helm-c-source-buffers-list
                           helm-c-source-recentf
                           helm-c-source-buffer-not-found)
                         "*coldnew helm mini*")))
       ))
#+end_src

** 緩衝區編輯 (I)

| 按鍵    | 命令                | 用途                          |
|---------+---------------------+-------------------------------|
| C-x C-y | yank-n-times        | 多次貼上                      |
| C-x C-l | recenter            | 將游標至於緩衝區中間          |
| C-x C-i | indent-whole-buffer | 縮排整個緩衝區                |
| C-x C-q | toggle-read-only    | 切換緩衝區變成唯讀/可寫的狀況 |
| C-x C-n | auto-complete       | 自動補全                      |

#+begin_src emacs-lisp
  (vim:mode-imap coldnew-editor-map (kbd "C-x C-y")  'yank-n-times)
  (vim:mode-imap coldnew-editor-map (kbd "C-x C-l")  'recenter)
  (vim:mode-imap coldnew-editor-map (kbd "C-x C-i")  'indent-whole-buffer)
  (vim:mode-imap coldnew-editor-map (kbd "C-x C-q")  'toggle-read-only)
  (vim:mode-imap coldnew-editor-map (kbd "C-x C-n")  'auto-complete)
#+end_src

| 按鍵     | 命令                   | 用途         |
|----------+------------------------+--------------|
| C-d      | hyngry-delete-forward  | 向右貪婪刪除 |
| C-l      | hyngry-delete-backward | 向左貪婪刪除 |
| <delete> | hyngry-delete-backward | 向左貪婪刪除 |

#+begin_src emacs-lisp
  (eval-after-load 'hungry-delete
    '(progn
       (vim:mode-imap coldnew-editor-map (kbd "C-d") 'hungry-delete-forward)
       (vim:mode-imap coldnew-editor-map (kbd "C-l") 'hungry-delete-backward)
       (vim:mode-imap coldnew-editor-map (kbd "<delete>") 'hungry-delete-backward)))
  #+end_src

| 按鍵 | 命令           | 用途 |
|------+----------------+------|
| C-/  | undo-tree-undo | undo |
| M-/  | undo-tree-redo | redo |

#+begin_src emacs-lisp
  (eval-after-load 'undo-tree
    '(progn
      (vim:mode-imap coldnew-editor-map (kbd "C-/") 'undo-tree-undo)
      (vim:mode-imap coldnew-editor-map (kbd "M-/") 'undo-tree-redo)))
#+end_src

| 按鍵 | 命令       | 用途                       |
|------+------------+----------------------------|
| C-;  | iedit-mode | 快速修改緩衝區內相同的文字 |

#+begin_src emacs-lisp
  (eval-after-load 'iedit
    '(progn
       (vim:mode-imap coldnew-editor-map (kbd "C-;") 'iedit-mode)))
#+end_src

| 按鍵 | 命令          | 用途                       |
|------+---------------+----------------------------|
| M-v  | expand-region | 快速選取游標下的文字、區域 |

#+begin_src emacs-lisp
  (eval-after-load 'expand-region
    '(progn
       (vim:mode-imap coldnew-editor-map (kbd "M-v") 'er/expand-region)))
#+end_src

| 按鍵 | 用途                             |
|------+----------------------------------|
| M-s  | 快速找尋緩衝區內所有要找尋的文字 |

#+begin_src emacs-lisp
  (eval-after-load 'helm
    '(progn
       (vim:mode-imap coldnew-editor-map (kbd "M-s") 'coldnew/helm-occur)))
#+end_src

| 按鍵    | 用途         |
|---------+--------------|
| C-c C-h | 快速代碼折疊 |

#+begin_src emacs-lisp
  (vim:mode-imap coldnew-editor-map (kbd "C-c C-h")
                 '(lambda ()
                    ""
                    (interactive)
                    (set-selective-display
                     (if selective-display nil 1))))
#+end_src


| 按鍵    | 用途              |
|---------+-------------------|
| M-<SPC> | 插入 <U200B> 字元 |
| s-<SPC> | 插入 <U200B> 字元 |

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-editor-map (kbd "M-<SPC>")
                 '(lambda ()(interactive) (insert "\ufeff")))
  (vim:mode-imap coldnew-editor-map (kbd "s-<SPC>")
                 '(lambda ()(interactive) (insert "\ufeff")))
#+END_SRC


| 按鍵  | 命令                | 用途           |
|-------+---------------------+----------------|
| C-M , | beginning-of-buffer | 回到緩衝區開頭 |
| C-M . | end-of-buffer       | 回到緩衝區尾巴 |

#+begin_src emacs-lisp
  (vim:mode-imap coldnew-editor-map (kbd "C-M-,") 'beginning-of-buffer)
  (vim:mode-imap coldnew-editor-map (kbd "C-M-.") 'end-of-buffer)
#+end_src

** 字體調整 (N) (I)

| 按鍵 | 命令                     | 用途               |
|------+--------------------------+--------------------|
| C-=  | increase-emacs-font-size | 放大緩衝區內的字體 |
| C-   | decrease-emacs-font-size | 縮小緩衝區內的字體 |

#+begin_src emacs-lisp
  (vim:mode-map coldnew-editor-map (kbd "C-=")  'increase-emacs-font-size)
  (vim:mode-map coldnew-editor-map (kbd "C--")  'decrease-emacs-font-size)
#+end_src

** org-mode 相關按鍵

和 org-mode 相關的全域按鍵都整理到這裡

| 按鍵  | 命令           | 用途                         |
|-------+----------------+------------------------------|
| C-c a | org-agenda     | 呼叫 org-mode agenda 命令    |
| C-c l | org-store-link | 儲存目前游標位置作為連結使用 |
| C-c c | org-capture    |                              |

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-editor-map (kbd "C-c a")  'org-agenda)
  (vim:mode-imap coldnew-editor-map (kbd "C-c l")  'org-store-link)
  (vim:mode-imap coldnew-editor-map (kbd "C-c c")  'org-capture)
#+END_SRC

** 特殊命令 (super, function)

有些很好用的命令，比如說呼叫 Woman, 或是彈出一個 terminal 視窗，這些我
將他們綁定到 super 按鍵作為 prefix，這一類按鍵有些會有相對應的 F1 ~ F12
的按鍵。

| 按鍵       | 命令      | 用途                |
|------------+-----------+---------------------|
| s-1 , <F1> | woman     | 使用 woman 查看文檔 |
| s-2 , <F2> | shell-pop | 彈出 eshell 視窗    |


#+BEGIN_SRC emacs-lisp
  (vim:mode-map coldnew-editor-map (kbd "<f1>")  'woman)
  (vim:mode-map coldnew-editor-map (kbd "s-1")   'woman)

  (vim:mode-map coldnew-editor-map (kbd "<f2>")  'shell-pop)
  (vim:mode-map coldnew-editor-map (kbd "s-2")   'shell-pop)

#+END_SRC

** 復合式按鍵

這邊的按鍵呼叫的功能比較特別，是 *複合式* 的，代表一個命令可能依據使用
的方式不同，而具有不同的功能。

因為這邊的命令也是特別的，因此同時定義在這裡

| 按鍵 | 用途 1       | 用途 2       |
|------+--------------+--------------|
| M-r  | 旋轉切換視窗 | 尋找並取代   |
| C-v  | 選取區域     | 選取矩型區域 |

- 旋轉切換視窗 or 尋找並取代

  #+begin_src emacs-lisp
    (vim:mode-imap coldnew-editor-map (kbd "M-r")
                   '(lambda ()
                      "If in region, us query replace, else use rotate-window-only."
                      (interactive)
                      (if (or mark-active (= (length (window-list)) 1))
                          (call-interactively 'query-replace-regexp)
                        (rotate-windows-only))))
  #+end_src

- 選取區域 or 選取矩型區域

  #+begin_src emacs-lisp
    (vim:mode-imap coldnew-editor-map (kbd "C-v")
                   '(lambda ()
                      "toggle between cua-set-mark or cua-rectangle-mark"
                      (interactive)
                      (if (not mark-active)
                          (call-interactively 'cua-set-mark)
                        (cua-toggle-rectangle-mark))))
  #+end_src

* Cedet                                                                :cedet:
#+begin_src emacs-lisp
  (require 'semantic)

  ;; Enable Semantic features
  (semantic-mode 1)

  ;; Maintain tag database
  (global-semanticdb-minor-mode 1)
  ;; Reparse buffer when idle
  (global-semantic-idle-scheduler-mode 1)
  ;; Show completions when idle
  (global-semantic-idle-completions-mode 1)
  ;; Provide `switch-to-buffer'-like keybinding for tag names.
  (global-semantic-mru-bookmark-mode 1)
  ;; Show summary of tag at point
  (global-semantic-idle-summary-mode 1)
  ;;;; Disable
  ;; Highlight the current tag.
  (global-semantic-highlight-func-mode -1)
  ;; Show current fun in header line
  (global-semantic-stickyfunc-mode -1)
  ;; Additional tag decorations
  (global-semantic-decoration-mode -1)

  ;;;; Enable support for GNU Global
;;  (semanticdb-enable-gnu-global-databases 'c-mode)
;;  (semanticdb-enable-gnu-global-databases 'c++-mode)

  (setq semanticdb-default-save-directory (concat emacs-cache-dir "semanticdb"))
  (set-default 'semantic-case-fold t)

#+end_src

* ECB                                                                   :ecb:
** 載入相關套件

#+begin_src emacs-lisp
  (require 'ecb)
#+end_src

** 不要顯示 tips-of-the-day，感覺很煩人

#+begin_src emacs-lisp
  (setq ecb-tip-of-the-day nil)
#+end_src

** 不要自動檢查版本是否相容，很煩人...

#+begin_src emacs-lisp
  (setq ecb-auto-compatibility-check nil)
#+end_src


** 使用命令顯示/隱藏 ecb-mode

#+begin_src emacs-lisp
  (defun toggle-ecb-mode ()
    "Toggle ecb-minor-mode and resize window accordingly"
    (interactive)
    (if ecb-minor-mode
        (progn
          (let ((w (frame-width ecb-frame)))
            (message "%i" w))
          (ecb-minor-mode))
      (progn
        (message "%s" "turning on, make frame wider")
        (ecb-minor-mode))))
#+end_src
* Cscope                                                             :cscope:
** 載入和 cscope 相關的 package
#+begin_src emacs-lisp
  (require 'xcscope)
  (require 'xcscope+)
  (setq cscope-do-not-update-database t)
#+end_src
* 程式開發                                                         :language:

各種不同程式語言開發用的設定。

** Android                                                          :android:
#+begin_src emacs-lisp
  (require 'android-mode)
  ;; Set my android-emulator-path
  (setq android-mode-sdk-dir "/opt/android-sdk-update-manager/")
#+end_src
** C/C++ 通用設定

C/C++ 語言基本上很多設定都沒有差，因此將通用的設定寫在這邊。

*** 將 #if 0 #endif 區域上色為灰色

emacs 預設不會將 #if 0 到 #endif 之間的區域用其他顏色隔開，這邊將這種類型的
code 變成灰色，這樣在看 code 時比較不會吃力。

#+begin_src emacs-lisp
  (defun cc-mode:highlight-if-0 ()
    "highlight c/c++ #if 0 #endif macros"
    (interactive)
    (setq cpp-known-face 'default)
    (setq cpp-unknown-face 'default)
    (setq cpp-known-writable 't)
    (setq cpp-unknown-writable 't)
    (setq cpp-edit-list '(("0" '(foreground-color . "gray")  default both)
                          ("1" default font-lock-comment-face both)))
    (cpp-highlight-buffer t))

  ;; Add to c/c++ mode
  (add-hook 'c-mode-common-hook 'cc-mode:highlight-if-0)
#+end_src

*** 縮排 #ifdef 語句

#+begin_src emacs-lisp
  (defun cc-mode:indent-preprocessor ()
    "Indent #ifdef ... #else ... #endf region as if ... else ... statement.
      This code is based on ppindent.el

      Note: you must (require 's) to use this code."
    (let ((result
           (catch 'err
             (save-excursion
               (let* ((cnt 0)
                      (file-ext (file-name-extension (buffer-file-name (current-buffer))))
                      (header-p (or (string= "h" file-ext) (string= "hpp" file-ext))))
                 (flet ((make-space (x) (if (< x 0) "" (make-string x ?\s))))
                   (goto-char (point-min))
                   ;; We decrease cnt when this buffer is headerfile
                   (if header-p (decf cnt c-basic-offset))

                   (while (re-search-forward "^[ \t]*#[ \t]*\\(.*\\)" nil t)
                     (cond ((s-starts-with? "if" (match-string-no-properties 1))
                            (replace-match (concat (make-space cnt) "#\\1"))
                            (incf cnt c-basic-offset))
                           ((s-starts-with? "el" (match-string-no-properties 1))
                            (replace-match (concat (make-space (- cnt c-basic-offset)) "#\\1")))
                           ((s-starts-with? "endif" (match-string-no-properties 1))
                            (decf cnt c-basic-offset)
                            (replace-match (concat (make-space cnt) "#\\1")))
                           (t
                            (replace-match (concat (make-space cnt) "#\\1"))))))
                 )))))
      (when result
        (goto-line (car result))
        (error "Error: %s" (cadr result)))))

  (defun cc-mode:indent-preprocessor-check-pair ()
    "Check for #ifdef ... #endif pairs."
    (let ((result
           (catch 'err
             (save-excursion
               (let* ((cnt 0))
                 (goto-char (point-min))
                 (while (re-search-forward "^[ \t]*#[ \t]*\\(.*\\)" nil t)
                   (cond ((s-starts-with? "if" (match-string-no-properties 1))
                          (incf cnt c-basic-offset))
                         ((s-starts-with? "el" (match-string-no-properties 1))
                          (when (< (- cnt c-basic-offset) 0)
                            (throw 'err `(,(line-number-at-pos) "Unmatched #else or #elif"))))
                         ((s-starts-with? "endif" (match-string-no-properties 1))
                          (when (< (- cnt c-basic-offset) 0)
                            (throw 'err `(,(line-number-at-pos) "Unmatched #endif")))
                          (decf cnt c-basic-offset))
                         )))))))
      (when result
        (goto-line (car result))
        (error "Error: %s" (cadr result)))))

  ;; Advice th indent-region function
  (defadvice indent-region (after indent-preprocessor activate)
    "Indent #ifdef ... #else ... #endif region as if ... else ... statement for c/c++ mode."
    (let ((buffer-major-mode (with-current-buffer (current-buffer) major-mode)))
      (if (or (eq major-mode 'c-mode)
              (eq major-mode 'c++-mode))
          (progn
            (cc-mode:indent-preprocessor)
            (cc-mode:indent-preprocessor-check-pair)))))

  #+end_src

*** 加入 eldoc 支援

#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook
            '(lambda ()
               (when (require 'c-eldoc nil 'noerror)
                 (setq c-eldoc-includes "`pkg-config gtk+-3.0 --cflags --libs` -I./ -I../")
                 (c-turn-on-eldoc-mode))))
#+end_src

*** 使用 cwarn-mode 顯示可能有問題的代碼

cwarn-mode 會顯示出 C/++ 下面一些致命的錯誤，以下面的程式碼來說

#+begin_src c :tangle no
  void test ()
  {
          if (x = y);
                 printf("This is error example\n");
  }
#+end_src

這段程式碼包含了兩種致命的錯誤。第一個是 *=* 只有在指派變數的值時才會
使用到，而不會存在於判斷式裏面，這邊應該要修改成 *==* 。

另外一個問題是，這邊多添加了不必要的分號在 if 判斷式的尾巴，這會讓 if
判斷式出錯，拿掉就沒問題了。

簡單的來說，cwarn-mode 包含以下幾種語法檢查:

  - Semicolons right after conditions and loops

    #+BEGIN_SRC c :tangle no
      if (x == y);
    #+END_SRC

  - Assignments in tests

    #+BEGIN_SRC c :tangle no
      void test() {
              if (a = b) foo();
      }
    #+END_SRC

  - Functions with reference parameters

    #+begin_src c++ :tangle no
      void funct(string &p) {
    #+end_src

這邊將 cwarn-mode 加入到 c-mode-common-hook 裏面。

#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook
            '(lambda () (cwarn-mode 1)))
#+end_src
*** 使用 ctypes 高亮 C/C++ 自行定義的 typedef

ctypes 這個套件可以識別 C/C++ 裏面的 typdef 定義，自動對他們進行語法高
亮。

#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook
            '(lambda ()
               (when (require 'ctypes nil 'noerror)
                 (ctypes-auto-parse-mode 1))))
#+end_src

** C
*** 設定 C 語言 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.c$" . c-mode))
  (add-to-list 'auto-mode-alist '("\\.h$" . c-mode))
#+end_src

*** 預設使用 Linux Coding Style

#+begin_src emacs-lisp
  (add-hook 'c-mode-hook
            '(lambda ()
               (c-set-style "linux")))
#+end_src

*** TODO 自動偵測 c-basic-offset
#+begin_src emacs-lisp
  (require 'guess-offset)
#+end_src
*** 快速插入樣板

#+begin_src emacs-lisp
    (defun c-mode:insert-inc-or-if ()
      "If at the start of line. add `inc' and expand it,
    else add `if' and expand it."
      (interactive)
      (let* ((current (point))
             (begin (line-beginning-position)))
        (if (eq current begin)
            (progn
              (c-mode:insert-include)
              (newline-and-indent))
          (progn
            (insert "if")
            (yas/expand)))))

  (setq c-mode-expand-alist
        '(("i" . c-mode:insert-inc-or-if)
          ("m" . "main")
          ))
#+end_src

*** 按鍵配置                                                       :keymap:
#+begin_src emacs-lisp
  (define-key c-mode-map (kbd "C-x C-o") 'ff-find-other-file)
#+end_src

*** make define indent in if

#+begin_src emacs-lisp
  (defun cc-mode:tmp ()
    (c-set-offset 'cpp-macro 0))

  (add-hook 'c-mode-hook 'cc-mode:tmp)
#+end_src

** C++
*** 設定 C++ 語言 檔案的副檔名與對應的模式
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.hpp$" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.cpp$" . c++-mode))
  ;; (add-to-list 'magic-mode-alist
  ;;              `(,(lambda ()
  ;;                   (and (string= (file-name-extension buffer-file-name) "h")
  ;;                        (re-search-forward "\\W\\(class\\|template\\namespace\\)\\W"
  ;;                                           magic-mode-regexp-match-limit t)))
  ;;                . c++-mode))
#+end_src
*** Codinf Style
#+begin_src emacs-lisp
    ;;;; CodingStyle
  (add-hook 'c++-mode-hook
            '(lambda ()

               ;; TODO: add comment here
               (setq c-macro-shrink-window-flag t)
               (setq c-macro-preprocessor "cpp")
               (setq c-macro-cppflags " ")
               (setq c-macro-prompt-flag t)

               ;; Use linux-kernel style
               (c-set-style "linux")

               ;; Setting indentation lvel
               (setq c-basic-offset 4)

               ;; Make TAB equivilent to 4 spaces
               (setq tab-width 4)

               ;; Use spaces to indent instead of tabs.
               (setq indent-tabs-mode nil)

               ;; Indent the continuation by 2
               (setq c-continued-statement-offset 2)

               ;; Brackets should be at same indentation level as the statements they open
               ;; for example:
               ;;                 if (0)        becomes        if (0)
               ;;                     {                        {
               ;;                        ;                         ;
               ;;                     }                        }
               (c-set-offset 'substatement-open '0)
               ;; make open-braces after a case
               (c-set-offset 'case-label '+)

               ))

#+end_src
#+begin_src emacs-lisp
      ;; Default clang completion flags
    ;;    (setq clang-completion-flags
    (setq ac-clang-flags
          (split-string
           (concat
            "-pthread -I./ -I../ "
            (shell-command-to-string "pkg-config --cflags-only-I opencv gtk+-3.0"))))
#+end_src

*** Hooks
**** 自動猜測縮排風格
#+begin_src emacs-lisp
  (when (require 'dtrt-indent nil 'noerror)
    (add-hook 'c++-mode-hook
              (lambda () (dtrt-indent-mode t))))
#+end_src
*** 自動補全設定
**** 載入其餘需要使用的套件。
#+begin_src emacs-lisp
  (require 'auto-complete-clang)
#+end_src
**** 設定用來補全的資訊。
#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook 'ac-cpp-mode-setup)
  (defun ac-cpp-mode-setup ()
    "auto-complete settings for c-mode."
    (setq ac-sources '(
;;                       ac-source-clang
                       ac-source-dictionary
                       ac-source-abbrev
                       ac-source-semantic
                       ac-source-filename
                       ac-source-files-in-current-dir
                       ac-source-words-in-same-mode-buffers
                       )))
#+end_src
*** Keybinding
#+begin_src emacs-lisp
  (define-key c++-mode-map (kbd "C-x C-o") 'ff-find-other-file)
#+end_src
C-c  s             序找符号
C-c  g             寻找全局的定义
C-c  c             看看指定函数被哪些函数所调用
C-c  C             看看指定函数调用了哪些函数
C-c  e             寻找正则表达式
C-c  f             寻找文件
C-c  i             看看指定的文件被哪些文件 include
C-c  a             设定初始化的目录，一般是你代码的根目录
C-c  I             对目录中的相关文件建立列表并进行索引
#+begin_src emacs-lisp
  (define-key c++-mode-map (kbd "C-c s") 'cscope-find-this-symbol)
  (define-key c++-mode-map (kbd "C-c g") 'cscope-find-global-definition)
  (define-key c++-mode-map (kbd "C-c I") 'cscope-create-list-of-files-to-index)
 ;; remember to remove
  (define-key c++-mode-map (kbd "C-c f") 'cscope-find-this-file)
#+end_src
** CMake
*** 設定 CMake 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (require 'cmake-mode)
  (add-to-list 'auto-mode-alist '("\\.cmake\\'" . cmake-mode))
  (add-to-list 'auto-mode-alist '("CMakeLists\\.txt\\'" . cmake-mode))
#+end_src

** Clojure
*** 載入相關套件

#+begin_src emacs-lisp :tangle no
  (require 'clojure-mode)
  ;;(require 'clojure-test-mode)
  ;;(require 'nrepl)
  ;;  (require 'ac-nrepl)
  (require 'cider)
#+end_src

*** 設定 Clojure 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))
#+end_src

*** 自動補全設定

#+begin_src emacs-lisp :tangle no
;;  (eval-after-load "auto-complete" '(add-to-list 'ac-modes 'nrepl-mode))
;;  (add-hook 'clojure-mode-hook 'ac-clojure-mode-setup)
;;  (add-hook 'nrepl-mode-hook   'ac-clojure-mode-setup)
;;  (add-hook 'nrepl-interaction-mode-hook   'ac-clojure-mode-setup)
;;  (defun ac-clojure-mode-setup ()
;;    "auto-complete settings for clojure-mode."
;;    (setq ac-sources '(
;;                       ac-source-nrepl-ns
;;                       ac-source-nrepl-vars
;;                       ac-source-nrepl-ns-classes
;;                       ac-source-nrepl-all-classes
;;                       ac-source-nrepl-java-methods
;;                       ac-source-nrepl-static-methods
;;                       ac-source-dictionary
;;                       ac-source-abbrev
;;                       ac-source-semantic
;;                       ac-source-filename
;;                       ac-source-files-in-current-dir
;;                       ac-source-words-in-same-mode-buffers
;;                       )))
#+end_src

** Clojure Script
*** 載入相關套件

#+begin_src emacs-lisp
  (require 'clojurescript-mode)
#+end_src

*** 設定 Clojure Script 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.cljs$" . clojurescript-mode))
#+end_src

** Emacs Lisp

*** 設定 emacs-lisp 的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.el$" . emacs-lisp-mode))
#+end_src

*** 顯示目前所使用的函式宣告在 minibuffer 上面

eldoc 能夠將目前所使用的 elisp function 所需要的 argument 顯示在
minibuffer 上。

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               (when (require 'eldoc nil 'noerror)
                 (turn-on-eldoc-mode)

                 ;; fix for paredit
                 (eval-after-load 'paredit
                   '(progn
                      (eldoc-add-command 'paredit-backward-delete
                                         'paredit-close-round))))))
#+end_src

*** 高亮屬於 cl.el 套件的 function 或是 macro

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               (when (require 'highlight-cl nil 'noerror)
                 (highlight-cl-add-font-lock-keywords))))
#+end_src

*** 自動補全

#+begin_src emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'ac-emacs-lisp-mode-setup)
    (defun ac-emacs-lisp-mode-setup ()
        "auto-complete settings for emacs-lisp-mode"
        (setq ac-sources
              '(ac-source-symbols
                ac-source-variables
                ac-source-functions
                ac-source-features
                ac-source-filename
                ac-source-files-in-current-dir
                ac-source-words-in-same-mode-buffers
                )))
#+end_src

*** 快速插入樣板
#+begin_src emacs-lisp
  (setq emacs-lisp-mode-expand-alist
        '(("r" . "require")
          ("d" . "defun")
          ("l" . "lambda")
          ))
#+end_src

*** 當打開 elisp 檔案的時候，移除 *.elc 檔案

我們會打開 elisp 程式通常都是為了編輯，並重新載入他，因此把 *.elc 檔案
移除勢必要的，這樣可以避免下次載入到錯誤的 elisp 程式。

#+begin_src emacs-lisp
  (defun remove-elc-when-visit ()
    "After visit elisp file, remove .elc extension file."
    (make-local-variable 'find-file-hook)
    (add-hook 'find-file-hook
              (lambda ()
                (if (and (file-exists-p (concat buffer-file-name "c"))
                         (file-writable-p (concat buffer-file-name "c")))
                    (delete-file (concat buffer-file-name "c"))))))

  (add-hook 'emacs-lisp-mode-hook 'remove-elc-when-visit)
#+end_src

** newlisp

*** 設定 newlisp 的副檔名與對應的模式

#+begin_src emacs-lisp
  (when (require 'newlisp nil 'noerror)
    (add-to-list 'auto-mode-alist '("\\.lsp$" . newlisp-mode)))
#+end_src

** Graphviz

#+BEGIN_SRC emacs-lisp
  (require 'graphviz-dot-mode)
  (defalias 'dot-mode 'graphviz-dot-mode)
#+END_SRC
** Go
*** 載入相關套件

#+begin_src emacs-lisp
(require 'go-mode)
#+end_src

*** 設定 go 的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.go$" . go-mode))
#+end_src

** QML
*** 設定 QML 的副檔名與對應的模式
#+begin_src emacs-lisp
  (require 'qml-mode)
  (add-to-list 'auto-mode-alist '("\\.qml$" . qml-mode))
#+end_src
*** 快速插入樣板
#+begin_src emacs-lisp
  (setq qml-mode-expand-alist
        '(("R" . "Rectangle")
          ("I" . "Item")
          ("M" . "MouseArea")
          ("L" . "ListModel")
          ("C" . "Component")
          ("T" . "Text")
          ("i" . "import")
          ))
#+end_src
*** 自動補全
#+begin_src emacs-lisp
  (add-hook 'qml-mode-hook 'ac-qml-mode-setup)
  (defun ac-qml-mode-setup ()
    "auto-complete settings for qml-mode"
    (setq ac-sources
          '(
            ac-source-dictionary
            ac-source-abbrev
            ac-source-filename
            ac-source-files-in-current-dir
            ac-source-words-in-same-mode-buffers
            )))
#+end_src
** qmake
*** 設定 qmake 的副檔名與對應的模式
#+begin_src emacs-lisp
  (require 'qmake-mode)
  (add-to-list 'auto-mode-alist '("\\.pro$" . qmake-mode))
#+end_src

** Lisp 通用設定

*** 建立編輯 lisp 程式用的 minor-mode

這個 minor-mode 類似我自己全域使用的 coldnew-editor-mode，但是是針對
lisp 類語言增加額外的設定。

#+BEGIN_SRC emacs-lisp
  (defvar coldnew-lisp-map (make-keymap))

  (define-minor-mode coldnew-lisp-mode
    "coldnew's lisp editing mode."
    :init-value nil
    :global nil
    :keymap coldnew-lisp-map)
#+END_SRC

定義會被加入到 coldnew-lisp-mode 的 major-mode list

#+begin_src emacs-lisp
  (defvar coldnew/lisp-mode
    '(;; emacs
      emacs-lisp-mode
      ;; clojure
      clojure-mode clojurescript-mode clojure-test-mode
      ;; newlisp
      newlisp-mode
      ;; scheme
      scheme-mode
      ))

  ;;; Add coldnew/lisp-mode to coldnew-lisp-mode
  (dolist (mode coldnew/lisp-mode)
    (let ((hook (intern (concat (symbol-name mode) "-hook"))))
      (add-hook hook (lambda () (coldnew-lisp-mode 1))
                ;;    (add-hook hook 'coldnew-lisp-mode)
                )))
#+end_src

*** 將 lambdada 以及 fn 變成希臘符號

pretty-lambdada 用來將 lambdada 變成希臘符號
#+begin_src emacs-lisp
  (when (require 'pretty-lambdada nil 'noerror)
    (add-hook 'coldnew-lisp-mode-hook 'pretty-lambda-mode))
#+end_src

*** 對每一個括號進行上色

#+begin_src emacs-lisp
  (when (require 'rainbow-delimiters nil 'noerror)
    (add-hook 'coldnew-lisp-mode-hook '(lambda () (rainbow-delimiters-mode 1))))
#+end_src

*** 使用 paredit 來簡化括號的操作

[[http://www.emacswiki.org/emacs/ParEdit][ParEdit]] 是一個非常好用的括號批配模式，特別是在寫 lisp 程式的時候，使用
paredit 可以幫助傳寫程式的速度。

正常來說，要加入 paredit 只需要使用

#+BEGIN_SRC emacs-lisp :tangle no
  (paredit-mode 1)
#+END_SRC

這樣就足夠了，但是有些按鍵我不希望 paredit 去更改他，因此我重新定義我自
己習慣的 paredit 案件。*

**** 基本的插入

***** 圓括號

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-lisp-map (kbd "(") 'paredit-open-round)
  (vim:mode-imap coldnew-lisp-map (kbd ")") 'paredit-close-round)
  (vim:mode-imap coldnew-lisp-map (kbd "M-)") 'paredit-close-round-and-newline)
#+END_SRC

***** 方括號

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-lisp-map (kbd "[") 'paredit-open-square)
  (vim:mode-imap coldnew-lisp-map (kbd "]") 'paredit-close-square)
#+END_SRC

***** 大括號

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-lisp-map (kbd "{") 'paredit-open-bracket)
  (vim:mode-imap coldnew-lisp-map (kbd "}") 'paredit-close-bracket)
#+END_SRC

***** 單、雙引號

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-lisp-map (kbd "\"") 'paredit-doublequote)
  (vim:mode-imap coldnew-lisp-map (kbd "M-\"") 'paredit-meta-doublequote)
#+END_SRC

***** 反斜線

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-lisp-map (kbd "\\") 'paredit-backslash)
#+END_SRC

**** 刪除

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-lisp-map (kbd "C-d") 'paredit-forward-delete)
  ;;  (vim:mode-imap coldnew-lisp-map (kbd "C-l") 'paredit-backword-delete)
  (vim:mode-imap coldnew-lisp-map (kbd "C-k") 'paredit-kill)
  (vim:mode-imap coldnew-lisp-map (kbd "M-d") 'paredit-forward-kill-word)
  (vim:mode-imap coldnew-lisp-map (kbd "M-l") 'paredit-backward-kill-word)
#+END_SRC

**** 移動

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-lisp-map (kbd "C-M f") 'paredit-forward)
  (vim:mode-imap coldnew-lisp-map (kbd "C-M b") 'paredit-backward)
#+END_SRC

**** 括號等級調整

#+BEGIN_SRC emacs-lisp
  (vim:mode-imap coldnew-lisp-map (kbd "M-9") 'paredit-wrap-round)
  (vim:mode-imap coldnew-lisp-map (kbd "M-(") 'paredit-wrap-round)
#+END_SRC

** Python
*** 設定 Python 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.py" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))
#+end_src

*** 使用 elpy 增強 emacs 編輯 python 的能力

- 關於 elpy 以及安裝

  [[https://github.com/jorgenschaefer/elpy][elpy]] 是一個用來增強 python 編輯能力的套件，使用這個套件之前必須先安裝
  elpy 與 rope 的 python 套件。

  : pip install elpy rope

  接著在 *scratch* 緩衝區對以下程式進行求值(eval)

  #+begin_src emacs-lisp :tangle no
    (add-to-list 'package-archives
                 '("marmalade" . "http://marmalade-repo.org/packages/"))
  #+end_src

  接著執行 M-x package-refresh-contents 來載入新的套件資訊，並安裝 elpy。

  : package-install elpy

  最後，在 .emacs 裏面加上下面兩行

  #+begin_src emacs-lisp :tnagle no
    (package-initialize)
  #+end_src

  #+begin_src emacs-lisp :tangle no
    (when (require 'elpy nil 'noerror)
      (elpy-enable))
  #+end_src
*** 自動補全

#+begin_src emacs-lisp
;;  (require 'ac-python)
#+end_src

*** 使用 jedi 進行自動補全

[[http://tkf.github.io/emacs-jedi/][jedi.el]] 是 emacs 下非常不錯的 python 自動補全方案。

#+BEGIN_SRC emacs-lisp
  (require 'jedi)
  (add-hook 'python-mode-hook 'jedi:setup)
  (setq jedi:setup-keys t)                      ; optional
  (setq jedi:complete-on-dot t)                 ; optional
#+END_SRC

** Markdown
*** 設定 Markdown 檔案的副檔名與對應的模式

#+begin_src emacs-lisp
  (require 'markdown-mode)
  (add-to-list 'auto-mode-alist '("\\.\\(md\\|markdown\\)\\'" . markdown-mode))
#+end_src

* 網頁開發                                                               :web:
** 網頁開發基本設定
*** 讓 emacs 能與 firefox 溝通

在讓 emacs 和 firefox 能互相溝通之前，兩邊都必須先裝上 moz-repl 這個外掛。
可以在 firefox 上的 moz-repl 選單，選擇 Active on startup 來確保當 firefox
啟動時會同時啟動 moz-repl

#+begin_src emacs-lisp
  (require 'moz)
#+end_src

*** 令 firefox 更新目前的頁面

#+begin_src emacs-lisp
  (defun firefox-refresh ()
    "Refresh the firefox browser"
    (interactive)
    (comint-send-string (inferior-moz-process)
                        "BrowserReload();"))
#+end_src

*** 整合 Javascript/HTML/CSS 色彩

#+begin_src emacs-lisp
  (require 'multi-web-mode)
  (setq mweb-default-major-mode 'html-mode)
  (setq mweb-tags
        '((php-mode "<\\?php\\|<\\? \\|<\\?=" "\\?>")
          (js-mode  "<script +\\(type=\"text/javascript\"\\|language=\"javascript\"\\)[^>]*>" "</script>")
          (css-mode "<style +type=\"text/css\"[^>]*>" "</style>")))
  (setq mweb-filename-extensions '("php" "htm" "html" "ctp" "phtml" "php4" "php5"))
  (multi-web-global-mode 1)
#+end_src

** CSS
*** 設定 CSS 的副檔名與對應的模式

#+begin_src emacs-lisp
  (require 'css-mode)
  (add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
#+end_src
** Less-CSS

*** 設定 LESS-CSS 的副檔名與對應的模式
#+begin_src emacs-lisp
  (require 'less-css-mode)
  (add-to-list 'auto-mode-alist '("\\.less$" . less-css-mode))
#+end_src

** JavaScript

*** 設定 javascript 的副檔名與對應的模式

使用 js2-mode 替代原本系統內建的 js-mode。
#+begin_src emacs-lisp
  (require 'js2-mode)
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src

*** 自動補全

#+begin_src emacs-lisp
  (add-hook 'js-mode-hook 'ac-javascript-mode-setup)
  (defun ac-javascript-mode-setup ()
    "auto-complete settings for javascript-mode"
    (setq ac-sources
          '(ac-source-dictionary
            ac-source-filename
            ac-source-files-in-current-dir
            ac-source-words-in-same-mode-buffers
            )))
#+end_src

*** REPL 設定

使用 js-comint 來設定 REPL 模式。
**** 設定起始位置

#+begin_src emacs-lisp
  (when (require 'js-comint nil 'noerror)
#+end_src

**** 設定 REPL 程式為 node.js
#+begin_src emacs-lisp
    (setq inferior-js-program-command "node")
#+end_src

**** 設定終止位置
#+begin_src emacs-lisp
    )
#+end_src

** HTML
*** 使用 zencoding-mode 讓寫 HTML 更方便

#+begin_src emacs-lisp
  (require 'zencoding-mode)
  (add-hook 'html-mode-hook 'zencoding-mode)
#+end_src

*** 使用 impatient-mode 即時顯示網頁

#+begin_src emacs-lisp
  (require 'impatient-mode)
  (require 'simple-httpd)
  (require 'htmlize)

  (add-hook 'css-mode-hook 'impatient-mode)
  (add-hook 'html-mode-hook 'impatient-mode)
  (add-hook 'js-mode-hook 'impatient-mode)
#+end_src

* 狀態欄                                                           :modeline:
** 顯示主模式

這個 function 用來定義如何顯示 major-mode，要放入 mode-line-format 才會真的顯示。

#+begin_src emacs-lisp
  (defun mode-line-major-mode ()
    "Get major-mode name with << >>."
    (concat "<< " (propertize mode-name 'face 'mode-line-mode-name-face) " >>"))
#+end_src

** 顯示 Evil 狀態

這個 function 用來定義如何顯示目前 evil-mode 的狀態，要放入 mode-line-format 才會真的顯示。

#+begin_src emacs-lisp
  (defun evil-mode-string ()
    (let ((evil-state-string (substring evil-mode-line-tag 2 3)))
      (setq evil-state-string-face
            (cond
             ((string= "N" evil-state-string) 'evil-state-normal-face)
             ((string= "I" evil-state-string) 'evil-state-insert-face)
             ((string= "V" evil-state-string) 'evil-state-visual-face)
             ((string= "E" evil-state-string) 'evil-state-emacs-face)
             ))
      (concat "<" (propertize evil-state-string 'face evil-state-string-face) ">")
      ))
#+end_src

** 顯示檔案的權限

#+begin_src emacs-lisp
  (defun mode-line-buffer-permissions ()
    "Get buffer-file permissions."
    (when (buffer-file-name)
      (format "-%04o-" (file-modes (buffer-file-name)))))
#+end_src

** 樣式設定

自己定義  mode-line 的樣式。

#+begin_src emacs-lisp
  (setq-default mode-line-format
                  '((" "
                     mode-line-mule-info
                     ;; read-only or modified status
                     (:eval
                      (cond (buffer-read-only
                             (propertize "RO" 'face 'mode-line-read-only-face))
                            ((buffer-modified-p)
                             (propertize "**" 'face 'mode-line-modified-face))
                            (t "--")))
                     "   "
                     (when (featurep 'evil)
                       (:eval (evil-mode-string)))
                     "   "
                     mode-line-buffer-identification
                     " " (:eval (mode-line-buffer-permissions))
                     "   "
                     ;; major-mode name
                     (:eval (mode-line-major-mode))
                     "   "
                     ;; line and column
                     "("
                     (:eval (propertize "%02l" 'face 'font-lock-type-face))
                     ","
                     (:eval (propertize "%02c" 'face 'font-lock-type-face))
                     ")"

                     "   "
                     (vc-mode vc-mode)
                     "   "
                     ;; relative position, size of file
                     "["
                     (:eval (propertize "%p" 'face 'font-lock-constant-face)) ;; % above top
                     "/"
                     (:eval (propertize "%I" 'face 'font-lock-constant-face)) ;; size
                     "] "
                     )))
#+end_src
* 互動式命令                                                        :command:

互動式命令就是可以在 emacs 裏面使用 M-x 然後呼叫的那些 command,
這邊根據其用途進行分類。

*注意* : 這邊的命令可能依賴我所自訂的 function。

** 緩衝區處理                                                       :buffer:

*** 將 unix 格式的文件轉換成 dos 格式

#+begin_src emacs-lisp
  (defun unix2dos ()
    "Convert buffer file from unix file to dos file."
    (interactive)
    (unix->dos (current-buffer)))
#+end_src

*** 將 dos 格式的文件轉換成 unix 格式


#+begin_src emacs-lisp
  (defun dos2unix ()
    "Convert buffer file from dos file to unix file."
    (interactive)
    (dos->unix (current-buffer)))
#+end_src

*** 將緩衝區的編碼改成 utf8

#+begin_src emacs-lisp
  (defun encode-to-utf8 ()
    "Sets the buffer-file-coding-system to UTF8."
    (interactive)
    (set-buffer-file-coding-system 'utf-8 nil))
#+end_src

*** 讓 emacs 可以一直儲存緩衝區 (即使檔案未經修正)

預設的 save-buffer 在 buffer 沒有變動時，不會進行儲存，
使用此命令可以使得在呼叫 save-buffer-always 時，將 buffer 變更為修改過，
並進行儲存。
#+begin_src emacs-lisp
  (defun save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))
#+end_src

*** 關閉除了 **scratch** 以外的所有 buffer。

當我想要讓我的 emacs 變得很乾淨的時候，這命令很好用。

#+begin_src emacs-lisp
  (defun nuke-all-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapcar (lambda (x) (kill-buffer x)) (buffer-list))
    (delete-other-windows))
#+end_src

*** 清除除了目前的緩衝區以外的緩衝區

和 nuke-all-buffers 很像，但是這個命令只會保留目前的緩衝區。

#+begin_src emacs-lisp
    (defun kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+end_src

*** 跳轉到 **scratch**

跳轉目前 buffer 與 **scratch**，假如 **scratch** 不存在，
則建立一個 major-mode 為 lisp-interaction-mode 的 **scratch**

#+begin_src emacs-lisp
  (defun scratch-toggle ()
    "Toggle between *scratch* buffer and the current buffer.
     If the *scratch* buffer does not exist, create it."
    (interactive)
    (let ((scratch-buffer-name (get-buffer-create "*scratch*")))
      (if (equal (current-buffer) scratch-buffer-name)
          (switch-to-buffer (other-buffer))
        (progn
          (switch-to-buffer scratch-buffer-name)
          (unless (equal major-mode 'lisp-interaction-mode)
            (lisp-interaction-mode))))))
#+end_src

*** 縮排整個緩衝區

將整個緩衝區進行縮排的動作，同時移除多餘的空白以及將 TABS 轉換
成空白

#+begin_src emacs-lisp
  (defun indent-whole-buffer ()
    "Indent whole buffer and delete trailing whitespace.
  This command will also do untabify."
    (interactive)
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max))
    (untabify (point-min) (point-max)))
#+end_src

*** 縮牌選擇區域或是整個緩衝區

將整個緩衝區進行縮排的動作，同時移除多餘的空白以及將 TABS 轉換
成空白，如果有選取區域，則只對區域有效，反之種個緩衝區有效。

#+begin_src emacs-lisp
  (defun indent-region-or-buffer ()
    "Indents a region if selected, otherwise the whole buffer."
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (delete-trailing-whitespace (region-beginning) (region-end))
            (indent-region (region-beginning) (region-end))
            (untabify (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-region-or-buffer)
          (message "Indented buffer.")))))
#+end_src

** 檔案處理                                                           :file:

這編放的是和檔案處理，或是和檔案相關的緩衝區處理命令。

*** 刪除目前的檔案與 buffer

有些時候我們不只是想要關掉緩衝區，同時還要順便把這個檔案砍了，
使用這個命令可以同時將這兩個想法完成。

#+begin_src emacs-lisp
  (defun delete-file-and-buffer ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
#+end_src

*** 使用瀏覽器觀看目前的檔案

透過 emacs 的 browse-url function 來呼叫瀏覽器打開目前的檔案。

#+begin_src emacs-lisp
  (defun browse-current-file ()
    "Open the current file as a URL using `browse-url'."
    (interactive)
    (browse-url (concat "file://" (buffer-file-name))))
#+end_src

*** 重新載入緩衝區裏面的檔案

如果沒有設定

: (global-auto-revert-mode 1)

的話，emacs 式不會自動重新載入檔案的，這個時候就會需要使用命令
來幫忙將所有緩衝區的檔案進行重新載入，避免寫入檔案時出現錯誤。

#+begin_src emacs-lisp
(defun revert-all-buffers ()
  "Revert all non-modified buffers associated with a file.
This is to update existing buffers after a Git pull of their underlying files."
  (interactive)
  (save-current-buffer
    (mapc (lambda (b)
            (set-buffer b)
            (unless (or (null (buffer-file-name)) (buffer-modified-p))
              (revert-buffer t t)
              (message "Reverted %s\n" (buffer-file-name))))
          (buffer-list))))
#+end_src

*** 複製並開啟檔案

使用這個命令，可以複製目前的緩衝區到另外一個檔案，同時打開那個檔案。

#+begin_src emacs-lisp
  (defun clone-file-and-open (filename)
    "Clone the current buffer writing it into FILENAME and open it"
    (interactive "FClone to file: ")
    (save-restriction
      (widen)
      (write-region (point-min) (point-max) filename nil nil nil 'confirm))
    (find-file filename))
#+end_src

*** 將目前緩衝區的檔案加上可執行權限

簡單的來說，這個功能就是

: chmod +x <file>

但是在以下的程式裏面，並未使用 chmod 的命令，而是使用 emacs 的
logior function 來改變檔案屬性。

這邊我只讓目前使用者可以執行這份檔案，至於群組、其他使用者則維持不動。

#+begin_src emacs-lisp
  (defun set-file-executable()
    "Add executable permissions on current file."
    (interactive)
    (when (buffer-file-name)
      (set-file-modes buffer-file-name
                      (logior (file-modes buffer-file-name) #o100))
      (message (concat "Made " buffer-file-name " executable"))))
#+end_src

*** TODO 使用 root 權限修改目前正在編輯的檔案

#+begin_src emacs-lisp
  (defun edit-current-file-as-root ()
    "Edit the file that is associated with the current buffer as root"
    (interactive)
    (if (buffer-file-name)
        (progn
          (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
          (find-file file))
      (message "Current buffer does not have an associated file.")))
#+end_src

** 視窗操作                                                         :window:

*** 將整個 emacs 全螢幕

有些時候我會很希望我的 emacs 可以全螢幕，用這個命令可以很方便達到我的想法。
#+begin_src emacs-lisp
  (defun fullscreen-window ()
    "Make the window full-screen."
    (interactive)
    (let ((current-value (frame-parameter nil 'fullscreen))
          (old-value nil))
      (set-frame-parameter nil 'fullscreen
                           (if (equal 'fullboth current-value)
                               'old-value
                             (progn
                               (setq old-value current-value)
                               'fullboth)))))
#+end_src

*** 旋轉視窗

有時候就是希望左右兩邊視窗可以對調，因此弄了以下的命令讓視窗可以進行旋
轉移動，若只有兩個視窗，則這個命令相當於 swap-windows 的功能，這邊設計
了兩種類型的旋轉視窗

- rotate-windows - 選轉視窗，視窗焦點會落在原本的緩衝區內。
- rotate-windows-only - 旋轉視窗，但是視窗的焦點還是在原本的視窗內。

#+begin_src emacs-lisp
  (defun rotate-windows-helper (x d)
    "Helper function for rotate window."
    (if (equal (cdr x) nil)
        (set-window-buffer (car x) d)
      (set-window-buffer (car x) (window-buffer (cadr x)))
      (rotate-windows-helper (cdr x) d)))

  (defun rotate-windows ()
    "Rotate window but make the focus on the same bufer."
    (interactive)
    (rotate-windows-helper (window-list) (window-buffer (car (window-list))))
    (select-window (car (last (window-list)))))

  (defun rotate-windows-only ()
    "Rotate windows only, keep focus at the same window."
    (interactive)
    ;; sotre window
    (let ((cur (car (window-list))))
      (rotate-windows-helper (window-list) (window-buffer (car (window-list))))
      (select-window cur)))
#+end_src

** 插入

*** 插入目前的時間

#+begin_src emacs-lisp
  (defun insert-date-time ()
    "Insert current-date."
    (interactive)
    (insert (current-date-time)))
#+end_src

*** 插入空白行

#+begin_src emacs-lisp
  (defun insert-empty-line ()
    "Insert an empty line after current line and position cursor on newline."
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line 1))
#+end_src

*** 多次貼上

emacs 本身的 yank 命令是無法使用 universla-argument 的，
也就是說無法使用 C-u 80 C-y 來貼上複製的東西 80 次，
而是貼上前幾次紀錄在 kill-ring 的資訊。

yank-n-times 則可以重複的進行貼上。

當沒有使用 universal-argument 指定要貼上多少次時，
會使用 prompt 詢問貼上的次數。
#+begin_src emacs-lisp
  (defun yank-n-times (&optional arg)
    "yank multiple times."
    (interactive "P")
    (let ((times (if (equal current-prefix-arg nil)
                     (read-number "yank repet times: ")
                   arg)))
      (if (< times 1)
          (setq times 1)
        (dotimes 'times (yank)))))
#+end_src
** 系統命令

*** gitg

雖然很多時候我都會用 magit 來察看 git log, 不過我還是很喜歡 gitg。

#+begin_src emacs-lisp
  (defun gitg ()
    "Launch gitg in the current directory."
    (interactive)
    (start-process "gitg" nil "gitg"))
  #+end_src

** 強化功能命令

*** 切換按鍵巨集的錄製/停止

#+begin_src emacs-lisp
  (defun toggle-kbd-macro-recording-on ()
    "One-key keyboard macros: turn recording on."
    (interactive)
    (define-key
      global-map
      (this-command-keys)
      'toggle-kbd-macro-recording-off)
    (start-kbd-macro nil))

  (defun toggle-kbd-macro-recording-off ()
    "One-key keyboard macros: turn recording off."
    (interactive)
    (define-key
      global-map
      (this-command-keys)
      'toggle-kbd-macro-recording-on)
    (end-kbd-macro))
#+end_src

** 文字/字詞處理

*** 將游標下的文字改用絕對路徑表示

這個命令可以再當你輸入 ~/ 時，使用他會將他變成絕對路徑。

#+begin_src emacs-lisp
  (defun resolve-sym-link ()
    "Replace the string at the point with the true path."
    (interactive)
    (beginning-of-line)
    (let* ((file (buffer-substring (point)
                                   (save-excursion (end-of-line) (point))))
           (file-dir (file-name-directory file))
           (file-true-dir (file-truename file-dir))
           (file-name (file-name-nondirectory file)))
      (delete-region (point) (save-excursion (end-of-line) (point)))
      (insert (concat file-true-dir file-name))))
#+end_src

** TODO 要重新調整
*** 其他、未歸類
**** TODO rewrite

#+begin_src emacs-lisp
  (defun align-code (beg end &optional arg)
    (interactive "rP")
    (if (null arg)
        (align beg end)
      (let ((end-mark (copy-marker end)))
        (indent-region beg end-mark nil)
        (align beg end-mark))))
#+end_src
#+begin_src emacs-lisp
  (defun mark-line (&optional arg)
    (interactive "p")
    (beginning-of-line)
    (let ((here (point)))
      (dotimes (i arg)
        (end-of-line))
      (set-mark (point))
      (goto-char here)))
  (defun mark-sentence (&optional arg)
    (interactive "P")
    (backward-sentence)
    (mark-end-of-sentence arg))
(defun delete-indentation-forward ()
  (interactive)
  (delete-indentation t))
(defun delete-current-line (&optional arg)
  (interactive "p")
  (let ((here (point)))
    (beginning-of-line)
    (kill-line arg)
    (goto-char here)))
#+end_src
#+begin_src emacs-lisp
  (defun window-horizontal-to-vertical ()
    "Switches from a horizontal split to a vertical split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-horizontally)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))

  (defun window-vertical-to-horizontal ()
    "Switches from a vertical split to a horizontal split."
    (interactive)
    (let ((one-buf (window-buffer (selected-window)))
          (buf-point (point)))
      (other-window 1)
      (delete-other-windows)
      (split-window-vertically)
      (switch-to-buffer one-buf)
      (goto-char buf-point)))

  (defun my-column-ruler (width)
    "Display temp ruler at point."
    (interactive `(,(+ (window-hscroll)(window-width))))
    (momentary-string-display
     (let* ((iterations (/ (1- width) 10))
            (result1 "|...|....|")
            (result2 "1   5   10")
            (inc1 "....|....|")
            (inc2 "        %d0")
            (i 1))
       (while  (<= i iterations)
         (setq i (1+ i))
         (setq result1 (concat result1 inc1))
         (setq result2 (concat result2 (substring (format inc2 i) -10))))
       (concat (substring result2 0 width) "\n"
               (substring result1 0 width) "\n"))
     (line-beginning-position)
     nil "[space]Clears ruler"))

#+end_src

#+begin_src emacs-lisp
  (defun swap-with (dir)
    (interactive)
    (let ((other-window (windmove-find-other-window dir)))
      (when other-window
        (let* ((this-window (selected-window))
               (this-buffer (window-buffer this-window))
               (other-buffer (window-buffer other-window))
               (this-start (window-start this-window))
               (other-start (window-start other-window)))
          (set-window-buffer this-window other-buffer)
          (set-window-buffer other-window this-buffer)
          (set-window-start this-window other-start)
          (set-window-start other-window this-start)))))

  ;; (global-set-key (kbd "C-M-J") (lambda () (interactive) (swap-with 'down)))
  ;; (global-set-key (kbd "C-M-K") (lambda () (interactive) (swap-with 'up)))
  ;; (global-set-key (kbd "C-M-H") (lambda () (interactive) (swap-with 'left)))
  ;; (global-set-key (kbd "C-M-L") (lambda () (interactive) (swap-with 'right)))

  ;; (global-set-key (kbd "M-J") (lambda () (interactive) (enlarge-window 1)))
  ;; (global-set-key (kbd "M-K") (lambda () (interactive) (enlarge-window -1)))
  ;; (global-set-key (kbd "M-H") (lambda () (interactive) (enlarge-window -1 t)))
  ;; (global-set-key (kbd "M-L") (lambda () (interactive) (enlarge-window 1 t)))


  (defun select-forwards-to-before-match (match)
    "Selects forwards to just before next match, uses
  select-region-to-before-match"
    (interactive "MSelect forwards to just before: ")
    (select-region-to-before-match match 'forwards))

  (defun select-backwards-to-before-match (match)
    "Selects backwards to just before next match, uses
  select-region-to-before-match"
    (interactive "MSelect backwards to just before: ")
    (select-region-to-before-match match 'backwards))

  (defun kill-forwards-to-before-match (match)
    "Selects forwards to just before next match, uses
  select-region-to-before-match, then kills that region."
    (interactive "MKill forwards to just before: ")
    (let* ((positions (select-region-to-before-match match 'forwards))
           (start (car positions))
           (end (cadr positions)))
      (kill-region start end)))

  (defun kill-backwards-to-before-match (match)
    "Selects backwards to just before next match, uses
  select-region-to-before-match, then kills that region."
    (interactive "MKill backwards to just before: ")
    (let* ((positions (select-region-to-before-match match 'backwards))
           (start (car positions))
           (end (cadr positions)))
      (kill-region start end)))

  (defun match-paren (arg)
    "Go to the matching paren if on a paren; otherwise insert %."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
          (t (self-insert-command (or arg 1)))))


  (defadvice kill-ring-save (before slickcopy activate compile)
    "When called interactively with no active region, copy a single line
  instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slickcut activate compile)
    "When called interactively with no active region, kill a single line
  instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defun zap-up-to-char-backward (arg char)
    (interactive "p\ncZap up to char backward: ")
    (zap-up-to-char (- arg) char))

  (defun go-to-char (arg char)
    (interactive "p\ncGo to char: ")
    (forward-char 1)
    (if (if arg
            (search-forward (char-to-string char) nil nil arg)
          (search-forward (char-to-string char)))
        (backward-char 1)))

  (defun go-back-to-char (arg char)
    (interactive "p\ncGo back to char: ")
    (forward-char -1)
    (if arg
        (search-backward (char-to-string char) nil nil arg)
      (search-backward (char-to-string char))))

  (defun vjo-forward-current-word-keep-offset ()
    " (Vagn Johansen 1999)"
    (interactive)
    (let ((re-curword) (curword) (offset (point))
          (old-case-fold-search case-fold-search) )
      (setq curword (thing-at-point 'symbol))
      (setq re-curword (concat "\\<" (thing-at-point 'symbol) "\\>") )
      (beginning-of-thing 'symbol)
      (setq offset (- offset (point)))    ; offset from start of symbol/word
      (setq offset (- (length curword) offset)) ; offset from end
      (forward-char)
      (setq case-fold-search nil)
      (if (re-search-forward re-curword nil t)
          (backward-char offset)
        ;; else
        (progn (goto-char (point-min))
               (if (re-search-forward re-curword nil t)
                   (progn (message "Searching from top. %s" (what-line))
                          (backward-char offset))
                 ;; else
                 (message "Searching from top: Not found"))
               ))
      (setq case-fold-search old-case-fold-search)
      ))

  (defun vjo-backward-current-word-keep-offset ()
    " (Vagn Johansen 2002)"
    (interactive)
    (let ((re-curword) (curword) (offset (point))
          (old-case-fold-search case-fold-search) )
      (setq curword (thing-at-point 'symbol))
      (setq re-curword (concat "\\<" curword "\\>") )
      (beginning-of-thing 'symbol)
      (setq offset (- offset (point)))    ; offset from start of symbol/word
      (forward-char)
      (setq case-fold-search nil)
      (if (re-search-backward re-curword nil t)
          (forward-char offset)
        ;; else
        (progn (goto-char (point-max))
               (if (re-search-backward re-curword nil t)
                   (progn (message "Searching from bottom. %s" (what-line))
                          (forward-char offset))
                 ;; else
                 (message "Searching from bottom: Not found"))
               ))
      (setq case-fold-search old-case-fold-search)
      ))

  ;; ;; FIXME: need to test
  ;; (defun set-frame-size-according-to-resolution ()
  ;;   (interactive)
  ;;   (if window-system
  ;;       (progn
  ;;      (if (> (x-display-pixel-width) 1500) ;; 1500 is the delimiter marging in px to consider the screen big
  ;;          (set-frame-width (selected-frame) 237) ;; on the big screen make the fram 237 columns big
  ;;        (set-frame-width (selected-frame) 177)) ;; on the small screen we use 177 columns
  ;;      (setq my-height (/ (- (x-display-pixel-height) 150) ;; cut 150 px of the screen height and use the rest as height for the frame
  ;;                         (frame-char-height)))
  ;;      (set-frame-height (selected-frame) my-height)
  ;;      (set-frame-position (selected-frame) 3 90) ;; position the frame 3 pixels left and 90 px down
  ;;      )))

  ;; (set-frame-size-according-to-resolution)
  ;;  (global-set-key (kbd "C-x 9") 'set-frame-size-according-to-resolution)

  (defun open-in-largest-window()
    "Open current buffer in largest window"
    (interactive)
    (let ((oldbuf (current-buffer)))
      (select-window (get-largest-window))
      (switch-to-buffer oldbuf))
    )
  ;;(global-set-key (kbd "C-x 5") 'open-in-largest-window)

#+end_src

**** 將整個 emacs 全螢幕

#+begin_src emacs-lisp
  (defun collapse-or-expand ()
    (interactive)
    (if (> (length (window-list)) 1)
        (delete-other-windows)
      (bury-buffer)))
#+end_src
#+begin_src emacs-lisp
  (defun windmove-down-fullscreen ()
    "Select window below current one and make it fullscreen."
    (interactive)
    (if (windmove-down)
        (delete-other-windows)))

  (defun windmove-up-fullscreen ()
    "Select window above the current one and make it fullscreen."
    (interactive)
    (if (windmove-up)
        (delete-other-windows)))

  (defun windmove-left-fullscreen ()
    "Select window left to current one and make it fullscreen."
    (interactive)
    (if (windmove-left)
        (delete-other-windows)))

  (defun windmove-right-fullscreen ()
    "Select window right to current one and make it fullscreen."
    (interactive)
    (if (windmove-right)
        (delete-other-windows)))

  (defun sudo-edit (&optional arg)
    "Edit file with sudo in emacs"
    (interactive "p")
    (if (or arg (not buffer-file-name))
        ;; (find-file (concat "/sudo:root@localhost:" (anything-read-file-name "File: ")))
        (find-file (concat "/sudo:root@localhost:" (read-file-name "File: ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

  (setq tramp-debug-buffer t)
  (setq tramp-chunksize 500)


  (require 'mm-url)

  (defun insert-tinyurl (url)
    "Insert a shortend URL at point by passed in URL"
    (interactive "sEnter url: " )
    (let* ((url (replace-regexp-in-string "^http://" "" url))
           (tinyurl
            (save-excursion
              (with-temp-buffer
                (mm-url-insert
                 (concat "http://tinyurl.com/api-create.php?url=http://" url))
                (kill-ring-save (point-min) (point-max))
                (buffer-string)))))
      (insert tinyurl)))

      ;;;; ---------------------------------------------------------------------------
      ;;;; Search
      ;;;; ---------------------------------------------------------------------------
  (defun multi-occur-in-this-mode ()
    "Show all lines matching REGEXP in buffers with this major mode."
    (interactive)
    (multi-occur
     (get-buffers-matching-mode major-mode)
     (car (occur-read-primary-args)))
    (select-window (get-buffer-window "*Occur*")))

      ;;;; ---------------------------------------------------------------------------
      ;;;; key-macro
      ;;;; ---------------------------------------------------------------------------

      ;;;; ---------------------------------------------------------------------------
      ;;;; Commands that define for key-chord
      ;;;; ---------------------------------------------------------------------------
  (defun upcase-word-backward ()
    "upcase word backward."
    (interactive)
    (upcase-word -1))

  (defun downcase-word-backward ()
    "downcase word backward."
    (interactive)
    (downcase-word -1))

  (defun capitalize-word-backward ()
    "captialize word backward."
    (interactive)
    (capitalize-word -1))

  (defun backward-kill-line (arg)
    "Kill chars backward until encountering the end of a line."
    (interactive "p")
    (kill-line 0))
#+end_src
*** 刪除
**** 刪除相對應的括號
#+begin_src emacs-lisp
  (defun delete-between-pair (char)
    "Delete in between the given pair"
    (interactive "cDelete between pair: ")
    (let ((pair-char))
      (search-backward-to-char char)
      (forward-char 1)
      (cond
       ((char-equal char ?\() (setq pair-char ?\)))
       ((char-equal char ?\") (setq pair-char ?\"))
       ((char-equal char ?\') (setq pair-char ?\'))
       ((char-equal char ?\[) (setq pair-char ?\]))
       ((char-equal char ?\{) (setq pair-char ?\}))
       ((char-equal char ?\<) (setq pair-char ?\>)))
      (zap-up-to-char 1 pair-char)))
#+end_src

**** 刪除一個 '字'
#+begin_src emacs-lisp
  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-region (point) (progn (forward-word arg) (point))))

#+end_src

**** 向左刪除一個 '字'
#+begin_src emacs-lisp
  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))
#+end_src

*** 轉換

**** eval-and-replace
將前面的 sexp 刪除並進行 eval 的動作，如果 eval 失敗則還原前面的 sexp。
#+begin_src emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
#+end_src
**** expand-last-sexp
#+begin_src emacs-lisp
  (defun expand-last-sexp ()
    "Expand macro from sexp before point;print value in pp eval buffer"
    (interactive)
    (pp-eval-expression '(macroexpand (read (thing-at-point 'sexp)))))
#+end_src

* 窗口管理                                                           :window:
** popwin

popwin is a popup window manager for Emacs which makes you free from the hell of annoying buffers such like *Help*, *Completions*, *compilation*, and etc.
Take an example. When you complete file names during find-file, the (annoying) *Completions* buffer will appear in a newly splitted window.
You might understand the necessity of the window, but you may wonder why the window still remains after completion...
popwin resolves there problems. Windows of such temporary buffers will be shown as a popup window, and you can close them smoothly by typing C-g in anytime.

#+begin_src emacs-lisp
  (require 'popwin)
  (setq display-buffer-function 'popwin:display-buffer)
#+end_src

** 使用 winner-mode 快速切換窗口佈局

winner-mode 是 emacs 自帶的窗口佈局管理器，可以對窗口的改變進行 undo/redo 的動作。

*** 載入相關套件

#+begin_src emacs-lisp
  (require 'winner)
#+end_src

*** 不使用 winner 預設的按鍵

#+begin_src emacs-lisp
  (setq winner-dont-bind-my-keys t)
#+end_src

*** 全域啟用 winner-mode

#+begin_src emacs-lisp
  (winner-mode t)
#+end_src

*** winner-mode 按鍵設定                                         :global@key:

| 按鍵 | 命令        | 用途                               |
|------+-------------+------------------------------------|
| M-[  | winner-undo | 回復上一個窗口佈局                 |
| M-]  | winner-redo | 切回上一組進行窗口復原時的窗口佈局 |

#+begin_src emacs-lisp
  (global-set-key (kbd "M-[") 'winner-undo)
  (global-set-key (kbd "M-]") 'winner-redo)
#+end_src

** golden-ratio

When working with many windows at the same time, each window has a
size that is not convenient for editing.

golden-ratio helps on this issue by resizing automatically the windows
you are working on to the size specified in the "Golden Ratio". The
window that has the main focus will have the perfect size for editing,
while the ones that are not being actively edited will be re-sized to
a smaller size that doesn't get in the way, but at the same time will
be readable enough to know it's content.

#+begin_src emacs-lisp
  (require 'golden-ratio nil 'noerror)
#+end_src

* 聊天軟體                                                             :chat:
** IRC

emacs 底下最常用的 IRC 軟體為 ERC 和 RCIRC，這邊我選用 ERC 作為 IRC 客戶端。

*** 載入相依套件

#+begin_src emacs-lisp
  (require 'erc)
  (require 'erc-notify)
  (require 'erc-spelling)
  (require 'erc-autoaway)
#+end_src

*** 設定 prompt 為 >>

#+begin_src emacs-lisp
  (setq erc-prompt ">>")
#+end_src

*** 編碼設定為 utf-8

#+begin_src emacs-lisp
  (setq erc-server-coding-system '(utf-8 . utf-8))
#+end_src

*** 當 ERC 啟動時，自動連入 IRC 伺服器

#+begin_src emacs-lisp
  (erc-autojoin-mode t)
#+end_src

*** 自動連線的伺服器與聊天室

#+begin_src emacs-lisp
  (setq erc-autojoin-channels-alist
        '(;; english channel
          (".*\\.freenode.net" "#emacs" "#clojure" "#coscup")
          ;; Chinese channel
          (".*\\.freenode.net" "#emacs.tw" "#tossug")
          (".*\\.oftc.net" "#dot")
          ))
#+end_src

*** 關閉部份訊息顯示

#+begin_src emacs-lisp
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src

*** 加入時間戳

#+begin_src emacs-lisp
  (erc-timestamp-mode 1)
#+end_src

*** 紀錄聊天訊息

- 載入相依套件

#+begin_src emacs-lisp
  (require 'erc-log)
#+end_src

- 啟動 erc-log-mode

  #+begin_src emacs-lisp
    (erc-log-mode 1)
  #+end_src

- 設定紀錄檔儲存位置

  #+begin_src emacs-lisp
    (setq erc-log-channels-directory emacs-log-dir)
  #+end_src

- 如果儲存紀錄檔的資料夾不存在，建立他

  #+begin_src emacs-lisp
    (unless (file-exists-p erc-log-channels-directory)
      (mkdir erc-log-channels-directory t))
  #+end_src

- 紀錄檔編碼為 utf-8

  #+begin_src emacs-lisp
    (setq erc-log-file-coding-system 'utf-8)
  #+end_src

- 送出訊息後寫入到 log

  #+begin_src emacs-lisp
    (setq erc-log-write-after-send t)
  #+end_src

- 當有新訊息時，寫入到 log

  #+begin_src emacs-lisp
    (setq erc-log-write-after-insert t)
  #+end_src

*** 設定聊天時的行寬為 100

#+begin_src emacs-lisp
  (setq erc-fill-column 100)
#+end_src

*** 為聊天室裡的使用者暱稱上色

#+begin_src emacs-lisp
  (and
   (require 'erc-highlight-nicknames)
   (add-to-list 'erc-modules 'highlight-nicknames)
   (erc-update-modules))
#+end_src

*** Misc

#+begin_src emacs-lisp
  ;; check channels
  ;; exclude boring stuff from tracking
  (erc-track-mode t)
  (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"

                                  "324" "329" "332" "333" "353" "477"))
  ;; Interpret mIRC-style color commands in IRC chats
  (setq erc-interpret-mirc-color t)
  ;; The following are commented out by default, but users of other
  ;; non-Emacs IRC clients might find them useful.
  ;; Kill buffers for channels after /part
  (setq erc-kill-buffer-on-part t)
  ;; Kill buffers for private queries after quitting the server
  (setq erc-kill-queries-on-quit t)
  ;; Kill buffers for server messages after quitting the server
  (setq erc-kill-server-buffer-on-quit t)
  ;; open query buffers in the current window
  (setq erc-query-display 'buffer)
  (setq erc-save-buffer-on-part t)
  (defadvice save-buffers-kill-emacs (before save-logs (arg) activate)
    (save-some-buffers t (lambda () (when (eq major-mode 'erc-mode) t))))
  ;; truncate long irc buffers
  (erc-truncate-mode +1)
  ;; enable spell checking
  (erc-spelling-mode 0)
  ;; autoaway setup
  (setq erc-auto-discard-away t)
  (setq erc-autoaway-idle-seconds 600)
  (setq erc-autoaway-use-emacs-idle t)
#+end_src

*** Commands

#+begin_src emacs-lisp
  (defun i-wanna-be-social ()
    "Connect to IM networks using bitlbee."
    (interactive)
    (erc :server "localhost" :port 6667 :nick "user"))
#+end_src
#+begin_src emacs-lisp
  (defun erc-cmd-WII (nick &rest ignore)
    "`/WHOIS' command with extra user information."
    (erc-send-command (mapconcat #'identity
                                 (list "WHOIS" nick nick) " ")))
  (defun erc-cmd-IDENTIFY (password &rest ignore)
    "Short-hand alias for `/msg NickServ identify PASS'."
    (erc-send-command (mapconcat #'identity
                                 (list "identify" password) " ")))
  (defun erc-cmd-CS (&rest args)
    "Short alias for `/chanserv ARGS'."
    (let ((command-args (append (list "CHANSERV") args)))
      (let ((chanserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command chanserv-command))))

  (defun erc-cmd-MS (&rest args)
    "Short alias for `/memoserv ARGS'."
    (let ((command-args (append (list "MEMOSERV") args)))
      (let ((memoserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command memoserv-command))))

  (defun erc-cmd-NS (&rest args)
    "Short alias for `/nickserv ARGS'."
    (let ((command-args (append (list "NICKSERV") args)))
      (let ((nickserv-command (mapconcat #'identity command-args " ")))
        (erc-send-command nickserv-command))))
#+end_src

*** Function

#+begin_src emacs-lisp
(defun avoid-erc-oops (txt)
  (when (member txt '("ls" "xb" "cd"))
      (setq erc-send-this nil)))

(add-to-list 'erc-send-pre-hook 'avoid-erc-oops)
#+end_src

*** Command

#+begin_src emacs-lisp
  (defun irc ()
    (interactive)
    (erc :server "irc.freenode.net" :port 6667 :nick erc-nick)
    (erc :server "irc.debian.org" :port 6667 :nick erc-nick))
#+end_src

* 電子郵件                                                            :email:

在 emacs 中有許多好用的電子郵件閱讀器，在試用之後，我決定選擇 [[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] 。
mu4e 是 mu 的 elisp 接口，由 [[http://emacs-fu.blogspot.tw/][emacs-fu]] 的作者 [[http://www.djcbsoftware.nl/][djcb]] 所撰寫。

為什麼選擇使用 mu4e 呢，我的理由有以下幾點:

- 使用外部程式如 offlineimap 下載郵件，不會在下載郵件時讓 emacs 停住
- 使用 C 語言寫的 mu 進行郵件索引，速度快

總歸一句就是 =速度= ，並且我受不了下載郵件時會停住我的 emacs 這種蠢事
(emacs 是單線程的程式)。

由於我的信件是使用 offlineimap 進行下載，因此在使用 mu4e 之前，必須先
安裝 offlineimap，並對他進行配置。

** offlineimap

offlineimap 是 Linux 下很棒的一個 imap 伺服器，可以用他來幫忙下載信件。

*** 讓 offlineimap 透過 emacs 取得密碼

我的信件密碼儲存在 ~/.authinfo.gpg 裡面，因為是使用 gpg 進行加密，並且
我不希望在輸入密碼的過程中另外彈出討厭的視窗，而是讓輸入密碼的視窗
出現在 emacs 中，因此要讓 emacs 來進行讀取檔案並回傳密碼的動作。

要辦到這樣的狀況 offlineimap 可以在設定中加入

: pythonfile = ~/.offlineimap.py

來載入額外的 function，我在這個檔案裏面加入了

#+begin_src python :tangle no
  #!/usr/bin/env python

  import subprocess

  def get_output(cmd):
      # Bunch of boilerplate to catch the output of a command:
      pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
      (output, errout) = pipe.communicate()
      assert pipe.returncode == 0 and not errout
      return output

  def get_password_emacs(host, port):
      cmd = "emacsclient --eval '(offlineimap-get-password \"%s\" \"%s\")'" % (host,port)
      return get_output(cmd).strip().lstrip('"').rstrip('"')
#+end_src

讓 offlineimap 可以透過 get_password_emacs() 來從 emacs 裏面取得密碼。

#+begin_src emacs-lisp
  (defun offlineimap-get-password (host port)
    (let* ((netrc (netrc-parse (expand-file-name "~/.authinfo.gpg")))
           (hostentry (netrc-machine netrc host port port)))
      (when hostentry (netrc-get hostentry "password"))))
#+end_src

因此，在 .offlineimaprc 裏面加入這樣一行

: remotepasseval = get_password_emacs("imap.gmail.com")

即可透過 emacs 取得 password 這個密碼。

** smtp
*** 取得 smtp 的密碼

在我的 ~/.authinfo.gpg 檔案內容是像這樣的

#+begin_src emacs-lisp
  (defvar smtp-account-list nil)
    (defun smtp-get-password (account)
      (require 'netrc)
      ;;(if (file-exists-p emacs-authinfo-file) (load-file emacs-authinfo-file))
      (or (netrc-get smtp-account-list account) ""))
#+end_src

** mu4e
*** 載入套件
#+begin_src emacs-lisp
  (require 'mu4e)
#+end_src
*** 使用 offlineimap 取得郵件

#+begin_src emacs-lisp
  (setq mu4e-get-mail-command "offlineimap")
#+end_src

*** 設定 mu4e 為預設的 email 系統

#+begin_src emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

*** 設定最頂層的郵件資料夾

#+begin_src emacs-lisp
  (setq mu4e-maildir "~/Maildir")
#+end_src

*** 設定我的 email 帳戶列表

#+begin_src emacs-lisp
  (setq message-send-mail-function 'smtpmail-send-it)
  (setq smtpmail-stream-type 'starttls)

  (setq coldnew/mu4e-account-alist
        '(("Gmail"
           (mu4e-sent-folder "/Gmail/Sent")
           (mu4e-drafts-folder "/Gmail/Drafts")
           (mu4e-trash-folder "/Gmail/Trash")
           (user-mail-address "coldnew.tw@gmail.com")
           ;; Sent mail
           (smtpmail-smtp-server "smtp.gmail.com")
           (smtpmail-smtp-service 587)
           (smtpmail-smtp-user "coldnew.tw@gmail.com")
           (smtpmail-auth-credentials (smtp-get-password smtpmail-smtp-user))
           )
          ("Weintek"
           (mu4e-sent-folder "/Weintek/Sent")
           (mu4e-drafts-folder "/Weintek/Drafts")
           (mu4e-trash-folder "/Weintek/Trash")
           (user-mail-address "yenchin@weintek.com"))))
#+end_src

*** 設定預設的帳戶為 Gmail

#+begin_src emacs-lisp
  (defun coldnew/mu4e-set-default-account (account)
    "Setup the default account based on coldnew/mu4e-account-alist."
    (let* ((account (cdr (assoc account coldnew/mu4e-account-alist))))
      (when account (mapc #'(lambda (a)
                              (set (car a) (if (stringp (cadr a)) (cadr a) (eval (cadr a))))) account))))
                              ;;(set (car a) (cadr a))) account))))

  (coldnew/mu4e-set-default-account "Gmail")
#+end_src
*** 每隔 60 秒 重新抓取郵件

#+begin_src emacs-lisp
  (setq mu4e-update-interval 60)
#+end_src

*** 在郵件中顯示圖片

#+begin_src emacs-lisp
  (setq mu4e-view-show-images t)
#+end_src

*** 使用 w3m 將 HTML 轉換為 text 檔

#+begin_src emacs-lisp
  (setq mu4e-html2text-command "w3m -dump -T text/html")

#+end_src

*** TODO 未整理

#+begin_src emacs-lisp
    (setq starttls-use-gnutls t)

    (defun mu4e~view-fontify-diff ()
      "Colorize diff message."
      (interactive)
      (let ((inhibit-read-only t))
        (save-excursion
          (goto-char (point-min))
          ;; consider only lines that heuristically look like a citation line...
          (while (re-search-forward "^\\(\\(\\+\\)[^+]\\|\\(-\\)[^-]\\)" nil t)
            (let ((cur-point (or (match-beginning 2) (match-beginning 3)))
                  (color (if (match-beginning 2)
                             "green"
                           "deep pink")))
              (end-of-line)
              (add-text-properties cur-point (point)
                                   `(face ((foreground-color . ,color))))))
          (goto-char (point-min))
          (while (re-search-forward "^\\(\\+\\+\\+\\|---\\)" nil t)
            (let ((cur-point (match-beginning 1)))
              (end-of-line)
              (add-text-properties cur-point (point)
                                   '(face ((weight . bold)))))))))

    (add-hook 'mu4e-view-mode-hook 'mu4e~view-fontify-diff)
#+end_src

#+begin_src emacs-lisp
  (defun coldnew/mu4e-set-account ()
    "Set the account for composing a message."
    (interactive)
    (let* ((account
            (if mu4e-compose-parent-message
                (let ((maildir (mu4e-msg-field mu4e-compose-parent-message :maildir)))
                  (string-match "/\\(.*?\\)/" maildir)
                  (match-string 1 maildir))
              (completing-read (format "Compose with account: (%s) "
                                       (mapconcat #'(lambda (var) (car var)) coldnew/mu4e-account-alist "/"))
                               (mapcar #'(lambda (var) (car var)) coldnew/mu4e-account-alist)
                               nil t nil nil (caar coldnew/mu4e-account-alist))))
           (account-vars (cdr (assoc account coldnew/mu4e-account-alist))))
      (if account-vars
          (mapc #'(lambda (var)
                    (set (car var) (cadr var)))
                account-vars))))

  (add-hook 'mu4e-compose-pre-hook 'coldnew/mu4e-set-account)
#+end_src
* Git 版本管理                                                          :git:

git 是我最喜歡用的版本管理器，當然能夠在 emacs 下使用是最好的，emacs
有許多好用的 git 套件，諸如 egg, magit, git-emacs 之類，在這邊的設定
我整合了這幾種工具，選用我最喜歡的功能。

** 載入套件

我使用了 egg, magit 以及 git-emacs 這幾種套件。

#+begin_src emacs-lisp
  (require 'magit)
;;  (require 'magit-flow)
  (require 'git-emacs)
  (require 'gitignore-mode)
  (require 'gitconfig-mode)
#+end_src

** 命令綁定、縮寫                                                    :alias:

由於我用了很多 git 的程式，這邊綁定命令到我想用的程式去

#+begin_src emacs-lisp
  (defalias 'git-rebase 'magit-rebase-step)
  (defalias 'git-push   'magit-push)
  (defalias 'git-add-remote 'magit-add-remote)
#+end_src

** 當使用 magit 時，不使用 emacs 原生的 vc 來處理和 git 相關的事情

emacs 本身具有一個 vc-mode 可以幫忙處理和版本管理相關的事情，但
是我覺的 magit 比較好用，所以當有載入 magit 時，就將 vc-mode 裏面
負責處理 git 的部份拿掉。

#+begin_src emacs-lisp
  (when (featurep 'magit)
    (setq vc-handled-backends (remq 'git vc-handled-backends)))
#+end_src

** 全域性使用 git-wip

- 關於 git-wip

  git-wip 是一個能夠不斷幫你進行備份檔案的 shell script 程式，會將你正在進行編輯的檔案，
  放置到 wip branch (Work in Process)，這樣假如你不小心滅掉了你的 commit, 或是某天想找尋
  某次被遺忘的修改，你都可以透過 git-wip 很簡單的完成他。

- 分支

  git-wip 的分支會有 wip/ 作為前綴, 舉例來說，如果你是在 feature branch 進行修改，
  則 git-wip 會幫你維護 wip/feature 分支。

  當你第一次執行 git-wip 的時候，你會自動幫你擷取所有已經被追蹤或是忽略的檔案，並建立
  新的分支。

  #+BEGIN_EXAMPLE
    --- * --- * --- *           <-- topic
                   \
                    ,*          <-- wip/topic
  #+END_EXAMPLE

  當你使用 git wip save 後 (或是用有提供 git wip 功能的文字編輯器儲存後)，
  你會注意到 wip/topic 指向了下一次的 commit。

  #+BEGIN_EXAMPLE
    --- * --- * --- *          <-- topic
                   \
                    ,*
                     \
                      ,*       <-- wip/topic
  #+END_EXAMPLE

  當你真正遞交了新的 commit，git wip 會指向你新遞交的 commit, 並且新增加 wip branch。

  #+BEGIN_EXAMPLE
    --- * --- * --- * --- *    <-- topic
                   \     \
                    ,*     *   <-- wip/topic
                     \
                      *
  #+END_EXAMPLE

- 回復

  若要進行回復，首先我們要先找尋我們感興趣的 commit。假設你最近修改的 branch 是 master,
  那你應該可以找到 wip/master 的參考(reference), 你也可以用以下命令列出 wip/master
  上面有哪些 wip branch。

  : git reflog show wip/master

  我個人是比較推荐你使用，以下命令來直接看到每次的修改

  : git log -g -p wip/master

  一旦你選定好了某次的 commit, 你必須要取得這些檔案。注意到我們不是直接切換到
  這個分支，我們只是要取得檔案。

  : git checkout <commit sha1> .

  如果你只是要該分支的某個檔案，你只要修正 . 為檔案名稱就好。

  都完成後，你可以使用以下命令來察看你取回來的檔案和目前的有什麼差別

  : git diff --cached

- 使用 magit-wip-mode

  在啟用 magit-wip-mode 之前，要記得使用

  : git config --add magit.extension wip-save  # or
  : git config --global --add magit.extension wip-save

  將 git-wip 加到 git 設定中。

  #+begin_src emacs-lisp
    (eval-after-load 'magit
      '(progn
         (require 'magit-wip)
         (magit-wip-mode 1)
         (global-magit-wip-save-mode)))
  #+end_src

** 在 fringe 顯示 git 的狀況

#+begin_src emacs-lisp
  (require 'git-gutter-fringe)
  (global-git-gutter-mode)
#+end_src

** 使用 C-g 離開 git 程式的視窗

我習慣在 emacs 使用 C-g 來跳離視窗，所以這邊也是這樣設定，用來
逃離 magit, git-emacs 的視窗。

#+begin_src emacs-lisp
  (define-key magit-mode-map (kbd "C-g") 'magit-quit-window)
  (define-key git--branch-mode-map (kbd "C-g") 'git--quit-buffer)
#+end_src

** 全域性按鍵設定                                               :global@key:

| 按鍵    | 命令         | 用途                             |
|---------+--------------+----------------------------------|
| C-x v l | magit-log    | 使用 magit 察看 log              |
| C-x v s | magit-status | 使用 magit 查看目前的 git status |

#+begin_src emacs-lisp
  (vim:imap (kbd "C-x vl") 'magit-log)
  (vim:imap (kbd "C-x vs") 'magit-status)
#+end_src

| 按鍵    | 命令                      | 用途                    |
|---------+---------------------------+-------------------------|
| C-x v c | magit-checkout            | 切換到其他的 git branch |
| C-x v p | git-push                  | push 到遠端 repo        |
| C-x v f | magit-flow-feature-create |                         |
| C-x v e | magit-flow-feature-finish |                         |

#+begin_src emacs-lisp
  (vim:map (kbd "C-x vc") 'magit-checkout)
  (vim:map (kbd "C-x vp") 'git-push)
;;  (vim:map (kbd "C-x vf") 'magit-flow-feature-create)
;;  (vim:map (kbd "C-x ve") 'magit-flow-feature-finish)
#+end_src
* 檔案備份                                                           :backup:

雖然現在大家都有在使用 git、svn 等檔案管理系統，但我們最好還是有其他的
備份，這裡設定的是 emacs 內建的備份方式。

*注意*:
　　由於內建的備份方式是採用明碼來備份，所以若是加密的檔案也會直接被
   備份。

** 設定備份檔案的資料夾

這個資料夾將存放所有的備份檔案

#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,emacs-backup-dir)))
#+end_src

** 如果備份檔案用的資料夾不存在，重新建立他

#+begin_src emacs-lisp
  (if (not (file-exists-p emacs-backup-dir))
      (make-directory emacs-backup-dir t))
#+end_src

** 每當敲擊按鍵 50 下時，進行備份

#+begin_src emacs-lisp
  (setq auto-save-interval 50)
#+end_src

** 每 60 秒進行自動儲存

#+begin_src emacs-lisp
  (setq auto-save-timeout 60)
#+end_src

** 真的刪除檔案，而不是放入垃圾桶

#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash nil)
#+end_src

** 當讀取檔案時，不自動進行檔案儲存

#+begin_src emacs-lisp
  (setq auto-save-visited-file-name nil)
#+end_src

** 當緩衝區儲存後，刪除掉自動儲存的檔案

#+begin_src emacs-lisp
  (setq delete-auto-save-files t)
#+end_src

** 讓備份檔案具有版本控管的功能

當備份檔案的時候，可以透過設定 kept-old-versions 以及 kept-new-versions 來決定
要保留多少備份。

#+begin_src emacs-lisp
  (setq version-control t)
#+end_src

** 保留舊有的 10 個備份

當新的備份建立起來後，保留舊有的 10 個備份

#+begin_src emacs-lisp
  (setq kept-old-versions 10)
#+end_src

** 建立新的 20 個備份

建立新的 20 個備份，當備份數量超過 20 以後，第一個備份會變成舊有的備份。

#+begin_src emacs-lisp
  (setq kept-new-versions 20)
#+end_src

** 刪除舊有的備份

刪除非以上所述的 30 個備份

#+begin_src emacs-lisp
  (setq delete-old-versions t)
#+end_src

** 使用複製的方式來產生備份檔案

#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

** 其他設置

#+begin_src emacs-lisp
  (setq auto-save-default    t)           ; auto-save of every file-visiting buffer
  ;; change auto-save-list setting
  (setq auto-save-list-file-prefix (concat emacs-backup-dir "auto-saves-"))
  (setq auto-save-file-name-transforms `((".*"  ,emacs-backup-dir)))
#+end_src

* 遠端編輯                                                            :tramp:

** 設定預設連線方式

#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "scp")
#+END_SRC

** 設定 tramp 自動儲存的資料夾

#+BEGIN_SRC emacs-lisp
  (setq tramp-auto-save-directory emacs-backup-dir)
#+END_SRC

** 設定 tramp 備份文件用的資料夾

#+BEGIN_SRC emacs-lisp
  (setq tramp-backup-directory-alist backup-directory-alist)
#+END_SRC

* Session                                                              :blog:
** saveplace
#+begin_src emacs-lisp
  (require 'saveplace)
  (setq save-place-file (concat emacs-cache-dir "saveplace.dat"))
  (setq-default save-place t)
#+end_src
** recentf
#+begin_src emacs-lisp
  (require 'recentf)
  (require 'recentf-ext)
  ;; Setting cache file for recentf
  (setq recentf-save-file (concat emacs-cache-dir "recentf"))
  ;; Following file won;t contain in recentf
  (setq recentf-exclude '("\\.elc$" "\\.pyc$" "\\.recentd$" "^/tmp/"))
#+end_src
* TODO 全域性按鍵設置                                            :global@key:
** 關閉預設的按鍵設定

關閉部份按鍵設定，在後面重新設定他。
#+begin_src emacs-lisp
  (global-unset-key (kbd "C-r"))
  (global-unset-key (kbd "C-x e"))
  (global-unset-key (kbd "C-x d"))
#+end_src

** 分頁切換

| 按鍵        | 命令                     | 用途          |
|-------------+--------------------------+---------------|
| C-x t n     | elscreen-next            | 下一個分頁    |
| C-x t p     | elscreen-previous        | 前一個分頁    |
| C-x t r     | elscreen-screen-nickname | 更改分頁名稱  |
| C-x t <NUM> | elscreen-goto <NUM>      | 跳到 <NUM> 頁 |
| C-x t c     | elscreen-create          | 建立新的分頁  |
| C-x t k     | elscreen-kill            | 關閉當前分頁  |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x t n") 'elscreen-next)
  (global-set-key (kbd "C-x t p") 'elscreen-previous)
  (global-set-key (kbd "C-x t r") 'elscreen-screen-nickname)
  (global-set-key (kbd "C-x t c") 'elscreen-create)
  (global-set-key (kbd "C-x t k") 'elscreen-kill)
  (global-set-key (kbd "C-x t 0") '(lambda () (interactive) (elscreen-goto 0)))
  (global-set-key (kbd "C-x t 1") '(lambda () (interactive) (elscreen-goto 1)))
  (global-set-key (kbd "C-x t 2") '(lambda () (interactive) (elscreen-goto 2)))
  (global-set-key (kbd "C-x t 3") '(lambda () (interactive) (elscreen-goto 3)))
  (global-set-key (kbd "C-x t 4") '(lambda () (interactive) (elscreen-goto 4)))
  (global-set-key (kbd "C-x t 5") '(lambda () (interactive) (elscreen-goto 5)))
  (global-set-key (kbd "C-x t 6") '(lambda () (interactive) (elscreen-goto 6)))
  (global-set-key (kbd "C-x t 7") '(lambda () (interactive) (elscreen-goto 7)))
  (global-set-key (kbd "C-x t 8") '(lambda () (interactive) (elscreen-goto 8)))
  (global-set-key (kbd "C-x t 9") '(lambda () (interactive) (elscreen-goto 9)))
#+end_src

** Ctrl-r 暫存器、書籤、快速跳轉、矩型處理
預設的 C-r 其實是 isearch-backward, 這裡將他改掉。

| 按鍵           | 命令                       | 用途                                     |
|----------------+----------------------------+------------------------------------------|
| C-r s <char>   | copy-to-register           | 將區域(選擇)存入暫存器                   |
| C-r r <char>   | copy-rectangle-to-register | 將矩型區域存入暫存器                     |
| C-r i <char>   | insert-register            | 將暫存器內的東西插入                     |
| C-r SPC <char> | point-to-register          | 將檔案或是緩衝區位置存入暫存器           |
| C-r j <char>   | jump-to-register           | 跳轉到暫存的檔案或是緩衝區位置           |
| C-r n          | cua-sequence-rectangel     | 對選取的矩型區域每行加入相對應的續列數字 |

#+begin_src emacs-lisp
  (global-set-key (kbd "C-r j") 'jump-to-register)
  (global-set-key (kbd "C-r r") 'copy-rectangle-to-register)
  (global-set-key (kbd "C-r i") 'insert-register)
  (global-set-key (kbd "C-r <SPC>") 'point-to-register)
  (global-set-key (kbd "C-r j") 'jump-to-register)
  (global-set-key (kbd "C-r n") 'cua-sequence-rectangle)
#+end_src

** Ctrl-Meta Prefix
#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-n") 'scroll-other-window)
  (global-set-key (kbd "C-M-p") 'scroll-other-window-down)
#+end_src

** Meta Prefix

#+begin_src emacs-lisp
  (global-set-key (kbd "M-l") 'backward-delete-word)
  (global-set-key (kbd "M-n") 'scroll-up)
  (global-set-key (kbd "M-p") 'scroll-down)
  (global-set-key (kbd "M-.") 'helm-etags+-select)
#+end_src

* 部若格                                                      :blog:
** 基本設定

- 設定我的部若格資料夾位置

  #+begin_src emacs-lisp :tangle no
    (defvar coldnew-blog-dir
      (concat coldnew-sparkleshare-dir "/coldnew.github.io")
      "My blog directory")
  #+end_src

- 設定我的部若格主檔案資料夾

  #+begin_src emacs-lisp :tangle no
    (defvar coldnew-blog-src-dir
      (concat coldnew-blog-dir "/blog-src")
      "My blog-src directory")
  #+end_src

- 設定我的主要 blog 檔案位置

  #+begin_src emacs-lisp :tangle no
    (defvar coldnew-blog-file
      (concat coldnew-blog-src-dir "/blog.org"))
  #+end_src

** blogit variables

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/Workspace/emacs-lisp/emacs-blogit")
  (require 'blogit)

  (setq blogit-publish-draft t)
  (defvar coldnew/blogit-after-publish-hook nil)
  (defvar coldnew/blog-after-publish-hook nil)

  (defun coldnew/blogit-compile-less-source ()
    (let* ((output-dir (blogit-project-info :publishing-directory))
           (output-style-dir
            (concat output-dir "/" (blogit-project-info :style-directory-name)))
           (input-file
            (concat output-style-dir "/blogit.less"))
           (output-file
            (concat output-style-dir "/blogit.css"))
           (lessc
            (concat output-style-dir "/less.js/bin/lessc")))

      ;; compile blog.less to blog.css and add it to css folder
      (shell-command (concat lessc " -x " input-file " > " output-file))))

  (defun coldnew/blogit-copy-rss-to-index ()
    (let* ((output-dir (blogit-project-info :publishing-directory))
           (rss-file
            (concat output-dir "rss.xml"))
           (index-file
            (concat output-dir "index.xml")))

      ;; copy rss.xml to index.xml
      (shell-command (concat "cp " rss-file " " index-file))))

  (add-hook 'coldnew/blogit-after-publish-hook 'coldnew/blogit-compile-less-source)
  (add-hook 'coldnew/blog-after-publish-hook 'coldnew/blogit-compile-less-source)
  (add-hook 'coldnew/blog-after-publish-hook 'coldnew/blogit-copy-rss-to-index)

  ;; tmp disable blogit post
  ;; add test post

  (setq blogit-project-alist
        '(;;("blogit"
          ;; :base-directory "~/Workspace/emacs-lisp/emacs-blogit/example/"
          ;; :publishing-directory "~/SparkleShare/coldnew.github.io/blogit"
          ;; :blog-url "http://coldnew.github.io/blogit"
          ;; :blog-title "emacs blogit"
          ;; :default-language "en"
          ;; :google-analytics "UA-42122243-1"
          ;; :disqus    "coldnew"
          ;; :lloogg "2b0e4f72854"
          ;; :after-publish-hook coldnew/blogit-after-publish-hook
          ;; )
          ("coldnew's blog"
           :base-directory "~/SparkleShare/blog-src"
           :publishing-directory "~/SparkleShare/coldnew.github.io/"
           :blog-url "http://coldnew.github.io"
           :blog-title "coldnew's blog"
           :default-language "zh_TW"
           :google-analytics "UA-42122243-1"
           :disqus    "coldnew"
           :lloogg "2b0e4f72854"
           :after-publish-hook coldnew/blog-after-publish-hook
           )
          ;; ("test"
          ;;  :base-directory "~/SparkleShare/test"
          ;;  :publishing-directory "~/SparkleShare/coldnew.github.io/test"
          ;;  :blog-url "http://coldnew.github.io"
          ;;  :blog-title "coldnew's blog"
          ;;  :default-language "zh_TW"
          ;;  :google-analytics "UA-42122243-1"
          ;;  :disqus    "coldnew"
          ;;  :lloogg "2b0e4f72854"
          ;;  :after-publish-hook coldnew/blog-after-publish-hook
          ;;  )
          ))

#+END_SRC

** blog function

#+BEGIN_SRC emacs-lisp
  (require 'generic-x)

  (define-generic-mode 'u-mode
    ;; comments
    '(("//")  ("/*" . "*/"))
    ;; keywords
    '("Name" "Tel" "Password")
    ;; other syntax
    nil
    ;; filetype
    '("\\.u$")
    ;; init func
    nil
    "a emacs major-mode for u-language")
#+END_SRC

* 其他

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/Workspace/emacs-lisp/org-ioslide")
  (require 'ox-ioslide nil 'noerror)
#+END_SRC
* TODO ----------------- Following are re-write ---------------------------------
* 按鍵設定

** 將按鍵表格轉換成 HTML 表格以及 elisp

這個設定主要是針對按鍵設定而增加，我希望可以使用表格來管理並分類我不同
的 emacs 按鍵設定，參照了 [[http://steckerhalter.co.vu/steckemacs.html][steckemacs]] 的設定，增加一些特殊的程式碼來將
org-mode 的表格轉換成 emacs 的按鍵設定程式碼。

#+NAME: keys-doc
#+BEGIN_SRC emacs-lisp :var keys=keys :tangle no :results output raw :exports results
  (let* ((header (car keys))
         (keys (delq header keys))
         (category))
    (pop keys)
    (mapcar (lambda (l) (if (listp l)
                       (progn
                         (unless (string= (nth 0 l) category)
                           (setq category (nth 0 l))
                           (princ (format "*** %s\n" category))
                           (princ "#+ATTR_HTML: :rules all :cellpadding 4\n")
                           (princ "| / | <r> | | \n")
                           )
                         (princ (format "| # | =%s= | %s |\n" (nth 1 l) (nth 2 l))))
                     (princ "|-\n")))
            keys))
  (princ "\n")
#+END_SRC

#+NAME: gen-keys
#+BEGIN_SRC emacs-lisp :var keys=keys :results output :tangle no :exports none :colnames nil
(mapcar (lambda (l)
          (let* ((key (nth 1 l))
                 (def (if (string-match "^[[:alnum:]]\\{2\\}$" (format "%s" key))
                          (format "key-chord-define-global \"%s\"" key)
                        (format "global-set-key (kbd \"%s\")" key)))
                 (command (car (last l))))
                 (princ (format "(%s %s)\n" def command))))
          keys)
#+END_SRC

將按鍵設定產生在 config.el
#+BEGIN_SRC emacs-lisp :noweb yes :results silent
<<gen-keys()>>
#+END_SRC

** 全域性按鍵設定 (global-set-key) :noexport:

#+TBLNAME: keys
| 類別     | 按鍵    | 描述               | 命令               |
|----------+---------+--------------------+--------------------|
| 文字編輯 | s-<RET> | 插入空白行         | 'insert-empty-line |
| 緩衝區   | C-x C-b | 切換到 ibuffer     | 'ibuffer           |
| 資料夾   | C-x C-d | 切換到 dired       | 'dired             |
| 視窗切換 | C-x F   | 將視窗切換成全螢幕 | 'fullscreen-window |
| Shell    | C-x s   | 執行 shell 命令    | 'shell-command     |

* 最後的初始化設定

在 [[*%E4%BD%BF%E7%94%A8%20req-package%20%E7%B0%A1%E5%8C%96%20use-package%20%E7%9A%84%E8%A8%AD%E5%AE%9A][使用 req-package 簡化 use-package 的設定]] 有提到說要再使用
=req-package-finish= 來完成所有套件的安裝，因此我們在 emacs 設定檔案最尾
巴要進行這項工作。

#+BEGIN_SRC emacs-lisp
  (req-package-finish)
#+END_SRC
